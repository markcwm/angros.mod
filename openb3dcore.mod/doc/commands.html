<html><head><title>OpenB3D core functions reference</title>
<link rel=stylesheet Type=text/css href='../../../../doc/bmxstyle.css'>
</head><body>
<table width=100% cellspacing=0><tr align=center><td class=small>&nbsp;</td>
<td class=small width=1%><b>Openb3d.Openb3dcore:</b></td>
<td class=small width=1%><a href=#functions class=small>Functions</a></td>
<td class=small width=1%><a href=#types class=small>Types</a></td>
<td class=small width=1%><a href=#modinfo class=small>Modinfo</a></td>
<td class=small width=1%><a href='../../../../mod/openb3d.mod/openb3dcore.mod/openb3dcore.bmx' class=small>Source</a></td>
<td class=small>&nbsp;</td></tr></table>
<h1>OpenB3D core functions</h1>
Core 3D functions and extra functions not in Blitz3D.
<h2><a name=functions></a>Functions Summary</h2><table class=doc width=100%>
<tr><td class=docleft width=1%><a href=#ActFadeTo>ActFadeTo</a></td><td class=docright>
Fades entity to the given alpha value (0..1) at the speed of rate.
</td></tr>
<tr><td class=docleft width=1%><a href=#ActMoveBy>ActMoveBy</a></td><td class=docright>
Moves entity by an x y z position increment at the speed of rate.
</td></tr>
<tr><td class=docleft width=1%><a href=#ActMoveTo>ActMoveTo</a></td><td class=docright>
Moves entity to the given x y z position at the speed of rate.
</td></tr>
<tr><td class=docleft width=1%><a href=#ActNewtonian>ActNewtonian</a></td><td class=docright>
Translates entity in the direction it is moving, rate should be below 1.
</td></tr>
<tr><td class=docleft width=1%><a href=#ActScaleTo>ActScaleTo</a></td><td class=docright>
Scales entity to the given x y z dimensions at the speed of rate.
</td></tr>
<tr><td class=docleft width=1%><a href=#ActTintTo>ActTintTo</a></td><td class=docright>
Tints entity to the given r g b value (0..255) at the speed of rate.
</td></tr>
<tr><td class=docleft width=1%><a href=#ActTrackByDistance>ActTrackByDistance</a></td><td class=docright>
Tracks target entity up to a given distance at the speed of rate.
</td></tr>
<tr><td class=docleft width=1%><a href=#ActTrackByPoint>ActTrackByPoint</a></td><td class=docright>
Tracks target entity at a given point from the entity at the speed of rate.
</td></tr>
<tr><td class=docleft width=1%><a href=#ActTurnBy>ActTurnBy</a></td><td class=docright>
Turns entity by an x y z rotation increment at the speed of rate.
</td></tr>
<tr><td class=docleft width=1%><a href=#ActTurnTo>ActTurnTo</a></td><td class=docright>
Turns entity to the given x y z rotation at the speed of rate.
</td></tr>
<tr><td class=docleft width=1%><a href=#ActVector>ActVector</a></td><td class=docright>
Positions entity according the given x y z vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#AddAnimSeq>AddAnimSeq</a></td><td class=docright>
Creates an animation sequence for an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#AddMesh>AddMesh</a></td><td class=docright>
Adds the source mesh to the destination mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#AddRenderTarget>AddRenderTarget</a></td><td class=docright>
undocumented.
</td></tr>
<tr><td class=docleft width=1%><a href=#AddSurface>AddSurface</a></td><td class=docright>
Add an existing surface to a mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#AddTriangle>AddTriangle</a></td><td class=docright>
Adds a triangle to a surface and returns the triangle's index number.
</td></tr>
<tr><td class=docleft width=1%><a href=#AddVertex>AddVertex</a></td><td class=docright>
Adds a vertex to the specified surface and returns the vertices' index number.
</td></tr>
<tr><td class=docleft width=1%><a href=#AlignToVector>AlignToVector</a></td><td class=docright>
Aligns an entity axis to a vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#AlphaDiscard>AlphaDiscard</a></td><td class=docright>
Set discard value (as 0..1) above which to ignore pixel's alpha value, default is 1 (only if flag 2)
</td></tr>
<tr><td class=docleft width=1%><a href=#AmbientLight>AmbientLight</a></td><td class=docright>
Sets the ambient lighting colour.
</td></tr>
<tr><td class=docleft width=1%><a href=#AmbientShader>AmbientShader</a></td><td class=docright>
Set default shader for surfaces.
</td></tr>
<tr><td class=docleft width=1%><a href=#Animate>Animate</a></td><td class=docright>
Animates an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#Animating>Animating</a></td><td class=docright>
Returns true if the specified entity is currently animating.
</td></tr>
<tr><td class=docleft width=1%><a href=#AnimLength>AnimLength</a></td><td class=docright>
Returns the length of the specified entity's current animation sequence.
</td></tr>
<tr><td class=docleft width=1%><a href=#AnimSeq>AnimSeq</a></td><td class=docright>
Returns the specified entity's current animation sequence.
</td></tr>
<tr><td class=docleft width=1%><a href=#AnimTime>AnimTime</a></td><td class=docright>
Returns the current animation time of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#AntiAlias>AntiAlias</a></td><td class=docright>
Enables or disables fullscreen antialiasing.
</td></tr>
<tr><td class=docleft width=1%><a href=#AppendAction>AppendAction</a></td><td class=docright>
Adds action to the end of another one, where act1 happens before act2.
</td></tr>
<tr><td class=docleft width=1%><a href=#AttachFragShader>AttachFragShader</a></td><td class=docright>
Attaches a fragment shader object to a program object, attach vertex first or older compilers will crash.
</td></tr>
<tr><td class=docleft width=1%><a href=#AttachVertShader>AttachVertShader</a></td><td class=docright>
Attaches a vertex shader object to a program object.
</td></tr>
<tr><td class=docleft width=1%><a href=#BackBufferToTex>BackBufferToTex</a></td><td class=docright>
Copy the contents of the backbuffer to a texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#BeginMax2D>BeginMax2D</a></td><td class=docright>
Old begin function as in Minib3d is 0, new begin function is 1 (default)
</td></tr>
<tr><td class=docleft width=1%><a href=#BrushAlpha>BrushAlpha</a></td><td class=docright>
Sets the alpha level of a brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#BrushBlend>BrushBlend</a></td><td class=docright>
Sets the blending mode for a brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#BrushColor>BrushColor</a></td><td class=docright>
Sets the colour of a brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#BrushFX>BrushFX</a></td><td class=docright>
Sets miscellaneous effects for a brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#BrushGLBlendFunc>BrushGLBlendFunc</a></td><td class=docright>
GL equivalent, experimental.
</td></tr>
<tr><td class=docleft width=1%><a href=#BrushGLColor>BrushGLColor</a></td><td class=docright>
GL equivalent, experimental.
</td></tr>
<tr><td class=docleft width=1%><a href=#BrushShininess>BrushShininess</a></td><td class=docright>
Sets the specular shininess of a brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#BrushTexture>BrushTexture</a></td><td class=docright>
Assigns a texture to a brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#BufferToTex>BufferToTex</a></td><td class=docright>
Copy pixmap buffer to texture, buffer must be a byte ptr.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraClsColor>CameraClsColor</a></td><td class=docright>
Sets camera background color.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraClsMode>CameraClsMode</a></td><td class=docright>
Sets camera clear mode.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraFogColor>CameraFogColor</a></td><td class=docright>
Sets camera fog color.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraFogMode>CameraFogMode</a></td><td class=docright>
Sets the camera fog mode.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraFogRange>CameraFogRange</a></td><td class=docright>
Sets camera fog range.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraPick>CameraPick</a></td><td class=docright>
Picks the entity positioned at the specified viewport coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraProject>CameraProject</a></td><td class=docright>
Projects the world coordinates x.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraProjMatrix>CameraProjMatrix</a></td><td class=docright>
undocumented.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraProjMode>CameraProjMode</a></td><td class=docright>
Sets the camera projection mode.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraRange>CameraRange</a></td><td class=docright>
Sets camera range.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraToTex>CameraToTex</a></td><td class=docright>
Copy rendered camera view to texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraViewport>CameraViewport</a></td><td class=docright>
Sets the camera viewport position and size.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraZoom>CameraZoom</a></td><td class=docright>
Sets zoom factor for a camera.
</td></tr>
<tr><td class=docleft width=1%><a href=#CheckFramebufferStatus>CheckFramebufferStatus</a></td><td class=docright>
Check for framebuffer errors.
</td></tr>
<tr><td class=docleft width=1%><a href=#ClearCollisions>ClearCollisions</a></td><td class=docright>
Clears the collision information list.
</td></tr>
<tr><td class=docleft width=1%><a href=#ClearSurface>ClearSurface</a></td><td class=docright>
Removes all vertices and/or triangles from a surface.
</td></tr>
<tr><td class=docleft width=1%><a href=#ClearTextureFilters>ClearTextureFilters</a></td><td class=docright>
Clears the current texture filter list.
</td></tr>
<tr><td class=docleft width=1%><a href=#ClearWorld>ClearWorld</a></td><td class=docright>
Clears all entities.
</td></tr>
<tr><td class=docleft width=1%><a href=#CollisionEntity>CollisionEntity</a></td><td class=docright>
Returns the other entity involved in a particular collision.
</td></tr>
<tr><td class=docleft width=1%><a href=#CollisionNX>CollisionNX</a></td><td class=docright>
Returns the x component of the normal of a particular collision.
</td></tr>
<tr><td class=docleft width=1%><a href=#CollisionNY>CollisionNY</a></td><td class=docright>
Returns the y component of the normal of a particular collision.
</td></tr>
<tr><td class=docleft width=1%><a href=#CollisionNZ>CollisionNZ</a></td><td class=docright>
Returns the z component of the normal of a particular collision.
</td></tr>
<tr><td class=docleft width=1%><a href=#Collisions>Collisions</a></td><td class=docright>
Enables collisions between two different entity types.
</td></tr>
<tr><td class=docleft width=1%><a href=#CollisionSurface>CollisionSurface</a></td><td class=docright>
Returns the handle of the surface belonging to the specified entity that was closest to the point of a particular collision.
</td></tr>
<tr><td class=docleft width=1%><a href=#CollisionTime>CollisionTime</a></td><td class=docright>
Returns the time taken to calculate a particular collision.
</td></tr>
<tr><td class=docleft width=1%><a href=#CollisionTriangle>CollisionTriangle</a></td><td class=docright>
Returns the index number of the triangle belonging to the specified entity  that was closest to the point of a particular collision.
</td></tr>
<tr><td class=docleft width=1%><a href=#CollisionX>CollisionX</a></td><td class=docright>
Returns the world x coordinate of a particular collision.
</td></tr>
<tr><td class=docleft width=1%><a href=#CollisionY>CollisionY</a></td><td class=docright>
Returns the world y coordinate of a particular collision.
</td></tr>
<tr><td class=docleft width=1%><a href=#CollisionZ>CollisionZ</a></td><td class=docright>
Returns the world z coordinate of a particular collision.
</td></tr>
<tr><td class=docleft width=1%><a href=#CopyBrush>CopyBrush</a></td><td class=docright>
Returns a copy of the new brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#CopyEntity>CopyEntity</a></td><td class=docright>
Creates a copy of an entity and returns the handle of the newly created copy.
</td></tr>
<tr><td class=docleft width=1%><a href=#CopyList>CopyList</a></td><td class=docright>
Copy a list or vector. To copy a field list use as a method.
</td></tr>
<tr><td class=docleft width=1%><a href=#CopyMesh>CopyMesh</a></td><td class=docright>
Creates a copy of a mesh and returns the newly-created mesh's handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CopyRect>CopyRect</a></td><td class=docright>
Copy rectangle of source pixmap pixels to destination, not exactly like B3D.
</td></tr>
<tr><td class=docleft width=1%><a href=#CopySurface>CopySurface</a></td><td class=docright>
Returns a copy of the new surface.
</td></tr>
<tr><td class=docleft width=1%><a href=#CopyTexture>CopyTexture</a></td><td class=docright>
Returns a copy of the new texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#CountChildren>CountChildren</a></td><td class=docright>
Returns the number of children of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#CountCollisions>CountCollisions</a></td><td class=docright>
Returns how many collisions an entity was involved in during the last UpdateWorld.
</td></tr>
<tr><td class=docleft width=1%><a href=#CountMipmaps>CountMipmaps</a></td><td class=docright>
Returns the number of mipmaps a texture has.
</td></tr>
<tr><td class=docleft width=1%><a href=#CountSurfaces>CountSurfaces</a></td><td class=docright>
Returns the number of surfaces in a mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#CountTriangles>CountTriangles</a></td><td class=docright>
Returns the number of triangles in a surface.
</td></tr>
<tr><td class=docleft width=1%><a href=#CountVertices>CountVertices</a></td><td class=docright>
Returns the number of vertices in a surface.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateBlob>CreateBlob</a></td><td class=docright>
Create blob from a fluid mesh where radius is the size of the blob.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateBone>CreateBone</a></td><td class=docright>
Create bone.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateBrush>CreateBrush</a></td><td class=docright>
Creates a brush and returns a brush handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateCamera>CreateCamera</a></td><td class=docright>
Creates a camera entity and returns its handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateCone>CreateCone</a></td><td class=docright>
Creates a cone mesh/entity and returns its handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateConstraint>CreateConstraint</a></td><td class=docright>
Create constraint force between two entities of given length, doesn't affect rotation.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateCube>CreateCube</a></td><td class=docright>
Creates a cube mesh/entity and returns its handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateCylinder>CreateCylinder</a></td><td class=docright>
Creates a cylinder mesh/entity and returns its handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateFluid>CreateFluid</a></td><td class=docright>
Create fluid mesh for blobs to use.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateFragShader>CreateFragShader</a></td><td class=docright>
Returns a new frag shader object from file.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateFragShaderString>CreateFragShaderString</a></td><td class=docright>
Returns a new frag shader object from string.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateGeosphere>CreateGeosphere</a></td><td class=docright>
Create geodesic sphere and set terrain size.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateLight>CreateLight</a></td><td class=docright>
Creates a light.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateMesh>CreateMesh</a></td><td class=docright>
Create a 'blank' mesh entity and returns its handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateOcTree>CreateOcTree</a></td><td class=docright>
Create octree and set its width, height and depth.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateParticleEmitter>CreateParticleEmitter</a></td><td class=docright>
Create particle emitter and set sprite for it to use.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreatePivot>CreatePivot</a></td><td class=docright>
Creates a pivot entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreatePlane>CreatePlane</a></td><td class=docright>
Creates a plane entity and returns its handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreatePostFX>CreatePostFX</a></td><td class=docright>
undocumented.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateQuad>CreateQuad</a></td><td class=docright>
Create flat quad.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateRigidBody>CreateRigidBody</a></td><td class=docright>
Create rigid physics body attached to four entities.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateShader>CreateShader</a></td><td class=docright>
Load shader from two strings, vertex and fragment.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateShaderMaterial>CreateShaderMaterial</a></td><td class=docright>
Returns a new shader material without creating any shader objects.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateShaderVGF>CreateShaderVGF</a></td><td class=docright>
Load shader from three strings, vertex, geometry and fragment.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateShadow>CreateShadow</a></td><td class=docright>
Create stencil shadow, static is for static or dynamic shadows.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateSphere>CreateSphere</a></td><td class=docright>
Creates a sphere mesh/entity and returns its handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateSprite>CreateSprite</a></td><td class=docright>
Creates a sprite entity and returns its handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateStencil>CreateStencil</a></td><td class=docright>
Create stencil object.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateSurface>CreateSurface</a></td><td class=docright>
Creates a surface attached to a mesh and returns the surface's handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateTerrain>CreateTerrain</a></td><td class=docright>
Creates a terrain entity and returns its handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateTexture>CreateTexture</a></td><td class=docright>
Creates a texture and returns its handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateVertShader>CreateVertShader</a></td><td class=docright>
Returns a new vert shader object from file.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateVertShaderString>CreateVertShaderString</a></td><td class=docright>
Returns a new vert shader object from string.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateVoxelSprite>CreateVoxelSprite</a></td><td class=docright>
Create voxel sprite where slices is the number of sprites.
</td></tr>
<tr><td class=docleft width=1%><a href=#DeleteFragShader>DeleteFragShader</a></td><td class=docright>
Deletes a frag shader object from a program object.
</td></tr>
<tr><td class=docleft width=1%><a href=#DeleteVertShader>DeleteVertShader</a></td><td class=docright>
Deletes a vert shader object from a program object.
</td></tr>
<tr><td class=docleft width=1%><a href=#DeltaPitch>DeltaPitch</a></td><td class=docright>
Returns the pitch angle.
</td></tr>
<tr><td class=docleft width=1%><a href=#DeltaYaw>DeltaYaw</a></td><td class=docright>
Returns the yaw angle.
</td></tr>
<tr><td class=docleft width=1%><a href=#DepthBufferToTex>DepthBufferToTex</a></td><td class=docright>
Copy the contents of the depth buffer to a texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#EmitterParticleAlpha>EmitterParticleAlpha</a></td><td class=docright>
Set particles alpha at start and end, range is 0..1.
</td></tr>
<tr><td class=docleft width=1%><a href=#EmitterParticleColor>EmitterParticleColor</a></td><td class=docright>
Set particles RGB color at start and end, default is 255,255,255.
</td></tr>
<tr><td class=docleft width=1%><a href=#EmitterParticleFunction>EmitterParticleFunction</a></td><td class=docright>
Points to callback function for emitter.
</td></tr>
<tr><td class=docleft width=1%><a href=#EmitterParticleLife>EmitterParticleLife</a></td><td class=docright>
Set particles start, end and random lifespan.
</td></tr>
<tr><td class=docleft width=1%><a href=#EmitterParticleRotate>EmitterParticleRotate</a></td><td class=docright>
Set particles rotation angle at start and end.
</td></tr>
<tr><td class=docleft width=1%><a href=#EmitterParticleScale>EmitterParticleScale</a></td><td class=docright>
Set particles scale at start and end, default is 1.
</td></tr>
<tr><td class=docleft width=1%><a href=#EmitterParticleSpeed>EmitterParticleSpeed</a></td><td class=docright>
Set particles start and end speed.
</td></tr>
<tr><td class=docleft width=1%><a href=#EmitterRate>EmitterRate</a></td><td class=docright>
Rate between each emission, range is 0.01..1.01.
</td></tr>
<tr><td class=docleft width=1%><a href=#EmitterVariance>EmitterVariance</a></td><td class=docright>
Set random variance of particles, range is 0.001..0.1.
</td></tr>
<tr><td class=docleft width=1%><a href=#EmitterVector>EmitterVector</a></td><td class=docright>
Set emitters start and end 3d vectors.
</td></tr>
<tr><td class=docleft width=1%><a href=#EndAction>EndAction</a></td><td class=docright>
Ends action so it can be freed, 1 = automatically ended, 2 = manually ended.
</td></tr>
<tr><td class=docleft width=1%><a href=#EndMax2D>EndMax2D</a></td><td class=docright>
Old end function as in Minib3d is 0, new end function is 1 (default)
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityAlpha>EntityAlpha</a></td><td class=docright>
Sets the entity alpha level of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityBlend>EntityBlend</a></td><td class=docright>
Sets the blending mode of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityBox>EntityBox</a></td><td class=docright>
Sets the dimensions of an entity's collision box.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityClass>EntityClass</a></td><td class=docright>
Returns a string containing the class of the specified entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityCollided>EntityCollided</a></td><td class=docright>
Returns the handle of the entity of the specified type that collided with  the specified entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityColor>EntityColor</a></td><td class=docright>
Sets the color of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityDistance>EntityDistance</a></td><td class=docright>
Returns the distance between src_entity and dest_entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityFX>EntityFX</a></td><td class=docright>
Sets miscellaneous effects for an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityInView>EntityInView</a></td><td class=docright>
Returns true if the specified entity is visible to the specified camera.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityMatrix>EntityMatrix</a></td><td class=docright>
undocumented.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityName>EntityName</a></td><td class=docright>
Returns the name of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityOrder>EntityOrder</a></td><td class=docright>
Sets the drawing order for an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityParent>EntityParent</a></td><td class=docright>
Attaches an entity to a parent.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityPick>EntityPick</a></td><td class=docright>
Returns the nearest entity 'ahead' of the specified entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityPickMode>EntityPickMode</a></td><td class=docright>
Sets the pick mode for an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityPitch>EntityPitch</a></td><td class=docright>
Returns the pitch angle of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityRadius>EntityRadius</a></td><td class=docright>
Sets the radius of an entity's collision ellipsoid.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityRoll>EntityRoll</a></td><td class=docright>
Returns the roll angle of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityScaleX>EntityScaleX</a></td><td class=docright>
Returns the scale for the x axis of an entity set with ScaleEntity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityScaleY>EntityScaleY</a></td><td class=docright>
Returns the scale for the y axis of an entity set with ScaleEntity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityScaleZ>EntityScaleZ</a></td><td class=docright>
Returns the scale for the z axis of an entity set with ScaleEntity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityShininess>EntityShininess</a></td><td class=docright>
Sets the specular shininess of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityTexture>EntityTexture</a></td><td class=docright>
Applies a texture to an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityType>EntityType</a></td><td class=docright>
Sets the collision type for an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityVisible>EntityVisible</a></td><td class=docright>
Returns true if src_entity and dest_entity can 'see' each other.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityX>EntityX</a></td><td class=docright>
The X-coordinate of the entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityY>EntityY</a></td><td class=docright>
The Y-coordinate of the entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityYaw>EntityYaw</a></td><td class=docright>
Returns the yaw angle of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityZ>EntityZ</a></td><td class=docright>
The Z-coordinate of the entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#ExtractAnimSeq>ExtractAnimSeq</a></td><td class=docright>
This command allows you to convert an animation with an MD2-style series  of anim sequences into a pure Blitz anim sequence.
</td></tr>
<tr><td class=docleft width=1%><a href=#FindChild>FindChild</a></td><td class=docright>
Returns the first child of the specified entity with name matching child_name$
</td></tr>
<tr><td class=docleft width=1%><a href=#FindSurface>FindSurface</a></td><td class=docright>
Attempts to find a surface attached to the specified mesh and created with  the specified brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#FitMesh>FitMesh</a></td><td class=docright>
Scales and translates all vertices of a mesh so that the mesh occupies the specified box.
</td></tr>
<tr><td class=docleft width=1%><a href=#FlipMesh>FlipMesh</a></td><td class=docright>
Flips all the triangles in a mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#FluidArray>FluidArray</a></td><td class=docright>
Create custom rendering array data for fluid mesh and set width, height and depth.
</td></tr>
<tr><td class=docleft width=1%><a href=#FluidFunction>FluidFunction</a></td><td class=docright>
Set custom rendering callback function for fluid mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#FluidThreshold>FluidThreshold</a></td><td class=docright>
Set threshold value used in fluid rendering algorithm, 0.5 is default.
</td></tr>
<tr><td class=docleft width=1%><a href=#FreeAction>FreeAction</a></td><td class=docright>
Frees action from memory when it has ended.
</td></tr>
<tr><td class=docleft width=1%><a href=#FreeBrush>FreeBrush</a></td><td class=docright>
Frees up a brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#FreeBrushTextures>FreeBrushTextures</a></td><td class=docright>
Frees all brush textures, FreeBrush does not free textures.
</td></tr>
<tr><td class=docleft width=1%><a href=#FreeEntity>FreeEntity</a></td><td class=docright>
FreeEntity will free up the internal resources associated  with a particular entity and remove it from the scene.
</td></tr>
<tr><td class=docleft width=1%><a href=#FreeShader>FreeShader</a></td><td class=docright>
Frees a shader material.
</td></tr>
<tr><td class=docleft width=1%><a href=#FreeShadow>FreeShadow</a></td><td class=docright>
Free stencil shadow.
</td></tr>
<tr><td class=docleft width=1%><a href=#FreeStencil>FreeStencil</a></td><td class=docright>
Frees a stencil object.
</td></tr>
<tr><td class=docleft width=1%><a href=#FreeSurface>FreeSurface</a></td><td class=docright>
Frees VBO data and brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#FreeTexture>FreeTexture</a></td><td class=docright>
Frees up a texture from memory.
</td></tr>
<tr><td class=docleft width=1%><a href=#GeosphereHeight>GeosphereHeight</a></td><td class=docright>
Set terrain height normalizing value, 0.05 is default.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetBrushTexture>GetBrushTexture</a></td><td class=docright>
Returns the texture that is applied to the specified brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetChild>GetChild</a></td><td class=docright>
Returns a child of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetEntityBrush>GetEntityBrush</a></td><td class=docright>
Returns a brush with the same properties as is applied to the specified entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetEntityType>GetEntityType</a></td><td class=docright>
Returns the collision type of an entity as set by the EntityType command.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMatElement>GetMatElement</a></td><td class=docright>
Returns the value of an element from within an entity's transformation matrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMeshLoader>GetMeshLoader</a></td><td class=docright>
Returns a mesh loader capable of loading <b>extension</b>.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetParent>GetParent</a></td><td class=docright>
Returns an entity's parent.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetShaderProgram>GetShaderProgram</a></td><td class=docright>
Get a shader program object reference.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetString>GetString</a></td><td class=docright>
Gets a Blitz string from a C string.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetSurface>GetSurface</a></td><td class=docright>
Returns the handle of the surface attached to the specified mesh and with  the specified index number.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetSurfaceBrush>GetSurfaceBrush</a></td><td class=docright>
Returns a brush with the same properties as is applied to the specified mesh surface.
</td></tr>
<tr><td class=docleft width=1%><a href=#GlobalAnIsotropic>GlobalAnIsotropic</a></td><td class=docright>
Set global texture anisotropic (default for all), TextureAnIsotropic overrides it.
</td></tr>
<tr><td class=docleft width=1%><a href=#GlobalHeight>GlobalHeight</a></td><td class=docright>
Returns global height of screen resolution.
</td></tr>
<tr><td class=docleft width=1%><a href=#GlobalResolution>GlobalResolution</a></td><td class=docright>
Sets global width and height of screen resolution.
</td></tr>
<tr><td class=docleft width=1%><a href=#GlobalWidth>GlobalWidth</a></td><td class=docright>
Returns global width of screen resolution.
</td></tr>
<tr><td class=docleft width=1%><a href=#HandleSprite>HandleSprite</a></td><td class=docright>
Sets a sprite handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#HideEntity>HideEntity</a></td><td class=docright>
Hides an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#LightColor>LightColor</a></td><td class=docright>
Sets the color of a light.
</td></tr>
<tr><td class=docleft width=1%><a href=#LightConeAngles>LightConeAngles</a></td><td class=docright>
Sets the 'cone' angle for a 'spot' light.
</td></tr>
<tr><td class=docleft width=1%><a href=#LightMesh>LightMesh</a></td><td class=docright>
Performs a 'fake' lighting operation on a mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#LightRange>LightRange</a></td><td class=docright>
Sets the range of a light.
</td></tr>
<tr><td class=docleft width=1%><a href=#LinePick>LinePick</a></td><td class=docright>
Returns the first entity between x.
</td></tr>
<tr><td class=docleft width=1%><a href=#LinkShader>LinkShader</a></td><td class=docright>
Link shader to a program object, as created by CreateShaderMaterial.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadAnimMesh>LoadAnimMesh</a></td><td class=docright>
Loads an anim mesh, see MeshLoader.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadAnimSeq>LoadAnimSeq</a></td><td class=docright>
Appends an animation sequence from a file to an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadBrush>LoadBrush</a></td><td class=docright>
Creates a brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadGeosphere>LoadGeosphere</a></td><td class=docright>
Load geodesic sphere terrain from heightmap image.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadMaterial>LoadMaterial</a></td><td class=docright>
Load a texture from image for 3D texture sampling, use with voxelsprites.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadMD2>LoadMD2</a></td><td class=docright>
Loads an md2 entity and returns its handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadMesh>LoadMesh</a></td><td class=docright>
Loads a single mesh, see MeshLoader.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadShader>LoadShader</a></td><td class=docright>
Load shader from two files, vertex and fragment.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadShaderVGF>LoadShaderVGF</a></td><td class=docright>
Load shader from three files, vertex, geometry and fragment.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadSprite>LoadSprite</a></td><td class=docright>
Creates a sprite entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadTerrain>LoadTerrain</a></td><td class=docright>
Loads a terrain from an image file and returns the terrain's handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#MeshCSG>MeshCSG</a></td><td class=docright>
Method 0 subtracts mesh2 from mesh1, 1 adds meshes, 2 intersects meshes. Returns a new mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#MeshCullRadius>MeshCullRadius</a></td><td class=docright>
Equivalent of Blitz3D's MeshCullBox command. It sets the radius of a mesh's 'cull sphere'
</td></tr>
<tr><td class=docleft width=1%><a href=#MeshDepth>MeshDepth</a></td><td class=docright>
Returns the depth of a mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#MeshesIntersect>MeshesIntersect</a></td><td class=docright>
Returns true if the specified meshes are currently intersecting.
</td></tr>
<tr><td class=docleft width=1%><a href=#MeshHeight>MeshHeight</a></td><td class=docright>
Returns the height of a mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#MeshWidth>MeshWidth</a></td><td class=docright>
Returns the width of a mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#ModifyGeosphere>ModifyGeosphere</a></td><td class=docright>
Set height of a given point, like ModifyTerrain.
</td></tr>
<tr><td class=docleft width=1%><a href=#ModifyTerrain>ModifyTerrain</a></td><td class=docright>
Sets the height of a point on a terrain.
</td></tr>
<tr><td class=docleft width=1%><a href=#MoveEntity>MoveEntity</a></td><td class=docright>
Moves an entity relative to its current position and orientation.
</td></tr>
<tr><td class=docleft width=1%><a href=#MSAntiAlias>MSAntiAlias</a></td><td class=docright>
Enables or disables hardware multisample antialiasing if supported.
</td></tr>
<tr><td class=docleft width=1%><a href=#NameEntity>NameEntity</a></td><td class=docright>
Sets an entity's name.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewAnimationKeys>NewAnimationKeys</a></td><td class=docright>
Create a new TAnimationKeys object.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewBone>NewBone</a></td><td class=docright>
Create a new TBone object.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewMatPtr>NewMatPtr</a></td><td class=docright>
Create a new TMatPtr object, returns a Float Ptr matrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewMesh>NewMesh</a></td><td class=docright>
Create a new TMesh object.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewQuatPtr>NewQuatPtr</a></td><td class=docright>
Create a new TQuatPtr object, returns a Float Ptr quaternion.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewSprite>NewSprite</a></td><td class=docright>
Create a new TSprite object.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewSurface>NewSurface</a></td><td class=docright>
Create a new TSurface object.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewTexture>NewTexture</a></td><td class=docright>
Create a new TTexture object.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewVecPtr>NewVecPtr</a></td><td class=docright>
Create a new TVecPtr object, returns a Float Ptr vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#OctreeBlock>OctreeBlock</a></td><td class=docright>
Place mesh into a node of an octree, the mesh can be duplicated using no more memory.
</td></tr>
<tr><td class=docleft width=1%><a href=#OctreeMesh>OctreeMesh</a></td><td class=docright>
Place mesh into a node of an octree, the mesh can't be duplicated so to do that use CopyEntity.
</td></tr>
<tr><td class=docleft width=1%><a href=#PaintEntity>PaintEntity</a></td><td class=docright>
Paints a entity with a brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#PaintMesh>PaintMesh</a></td><td class=docright>
Paints a mesh with a brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#PaintSurface>PaintSurface</a></td><td class=docright>
Paints a surface with a brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#ParticleColor>ParticleColor</a></td><td class=docright>
Sets color of batch particle trails.
</td></tr>
<tr><td class=docleft width=1%><a href=#ParticleTrail>ParticleTrail</a></td><td class=docright>
Sets number of batch particles in trail.
</td></tr>
<tr><td class=docleft width=1%><a href=#ParticleVector>ParticleVector</a></td><td class=docright>
Sets 3d vector of batch particle trails.
</td></tr>
<tr><td class=docleft width=1%><a href=#PickedEntity>PickedEntity</a></td><td class=docright>
Returns the entity 'picked' by the most recently executed Pick command.
</td></tr>
<tr><td class=docleft width=1%><a href=#PickedNX>PickedNX</a></td><td class=docright>
Returns the x component of the normal of the most recently executed Pick  command.
</td></tr>
<tr><td class=docleft width=1%><a href=#PickedNY>PickedNY</a></td><td class=docright>
Returns the y component of the normal of the most recently executed Pick  command.
</td></tr>
<tr><td class=docleft width=1%><a href=#PickedNZ>PickedNZ</a></td><td class=docright>
Returns the z component of the normal of the most recently executed Pick  command.
</td></tr>
<tr><td class=docleft width=1%><a href=#PickedSurface>PickedSurface</a></td><td class=docright>
Returns the handle of the surface that was 'picked' by the most recently  executed Pick command.
</td></tr>
<tr><td class=docleft width=1%><a href=#PickedTime>PickedTime</a></td><td class=docright>
Returns the time taken to calculate the most recently executed Pick command.
</td></tr>
<tr><td class=docleft width=1%><a href=#PickedTriangle>PickedTriangle</a></td><td class=docright>
Returns the index number of the triangle that was 'picked' by the most recently  executed Pick command.
</td></tr>
<tr><td class=docleft width=1%><a href=#PickedX>PickedX</a></td><td class=docright>
Returns the world x coordinate of the most recently executed Pick command.
</td></tr>
<tr><td class=docleft width=1%><a href=#PickedY>PickedY</a></td><td class=docright>
Returns the world y coordinate of the most recently executed Pick command.
</td></tr>
<tr><td class=docleft width=1%><a href=#PickedZ>PickedZ</a></td><td class=docright>
Returns the world z coordinate of the most recently executed Pick command.
</td></tr>
<tr><td class=docleft width=1%><a href=#PointEntity>PointEntity</a></td><td class=docright>
Points one entity at another.
</td></tr>
<tr><td class=docleft width=1%><a href=#PositionAnimMesh>PositionAnimMesh</a></td><td class=docright>
Moves all vertices of mesh and every child mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#PositionEntity>PositionEntity</a></td><td class=docright>
Positions an entity at an absolute position in 3D space.
</td></tr>
<tr><td class=docleft width=1%><a href=#PositionMesh>PositionMesh</a></td><td class=docright>
Moves all vertices of a mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#PositionTexture>PositionTexture</a></td><td class=docright>
Positions a texture at an absolute position.
</td></tr>
<tr><td class=docleft width=1%><a href=#PostFXBuffer>PostFXBuffer</a></td><td class=docright>
undocumented.
</td></tr>
<tr><td class=docleft width=1%><a href=#PostFXFunction>PostFXFunction</a></td><td class=docright>
undocumented.
</td></tr>
<tr><td class=docleft width=1%><a href=#PostFXShader>PostFXShader</a></td><td class=docright>
undocumented.
</td></tr>
<tr><td class=docleft width=1%><a href=#PostFXShaderPass>PostFXShaderPass</a></td><td class=docright>
undocumented.
</td></tr>
<tr><td class=docleft width=1%><a href=#PostFXTexture>PostFXTexture</a></td><td class=docright>
undocumented.
</td></tr>
<tr><td class=docleft width=1%><a href=#ProjectedX>ProjectedX</a></td><td class=docright>
Returns the viewport x coordinate of the most recently executed CameraProject.
</td></tr>
<tr><td class=docleft width=1%><a href=#ProjectedY>ProjectedY</a></td><td class=docright>
Returns the viewport y coordinate of the most recently executed CameraProject.
</td></tr>
<tr><td class=docleft width=1%><a href=#ProjectedZ>ProjectedZ</a></td><td class=docright>
Returns the viewport z coordinate of the most recently executed CameraProject.
</td></tr>
<tr><td class=docleft width=1%><a href=#RenderWorld>RenderWorld</a></td><td class=docright>
Renders the current scene to the BackBuffer onto the rectangle defined by each cameras CameraViewport( )
</td></tr>
<tr><td class=docleft width=1%><a href=#RepeatMesh>RepeatMesh</a></td><td class=docright>
Like CopyMesh but for instancing effects.
</td></tr>
<tr><td class=docleft width=1%><a href=#ResetEntity>ResetEntity</a></td><td class=docright>
Resets the collision state of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#ResetShadow>ResetShadow</a></td><td class=docright>
Reset created flag to update static shadow.
</td></tr>
<tr><td class=docleft width=1%><a href=#RotateAnimMesh>RotateAnimMesh</a></td><td class=docright>
Rotates all vertices of mesh and every child mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#RotateEntity>RotateEntity</a></td><td class=docright>
Rotates an entity so that it is at an absolute orientation.
</td></tr>
<tr><td class=docleft width=1%><a href=#RotateMesh>RotateMesh</a></td><td class=docright>
Rotates all vertices of a mesh by the specified rotation.
</td></tr>
<tr><td class=docleft width=1%><a href=#RotateSprite>RotateSprite</a></td><td class=docright>
Rotates a sprite.
</td></tr>
<tr><td class=docleft width=1%><a href=#RotateTexture>RotateTexture</a></td><td class=docright>
Rotates a texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#ScaleAnimMesh>ScaleAnimMesh</a></td><td class=docright>
Scales all vertices of mesh and every child mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#ScaleEntity>ScaleEntity</a></td><td class=docright>
Scales an entity so that it is of an absolute size.
</td></tr>
<tr><td class=docleft width=1%><a href=#ScaleMesh>ScaleMesh</a></td><td class=docright>
Scales all vertices of a mesh by the specified scaling factors.
</td></tr>
<tr><td class=docleft width=1%><a href=#ScaleSprite>ScaleSprite</a></td><td class=docright>
Scales a sprite.
</td></tr>
<tr><td class=docleft width=1%><a href=#ScaleTexture>ScaleTexture</a></td><td class=docright>
Scales a texture by an absolute amount.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetAnimKey>SetAnimKey</a></td><td class=docright>
Sets an animation key for the specified entity at the specified frame.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetAnimTime>SetAnimTime</a></td><td class=docright>
SetAnimTime allows you to manually animate entities.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetCubeFace>SetCubeFace</a></td><td class=docright>
Selects a cube face for direct rendering to a texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetCubeMode>SetCubeMode</a></td><td class=docright>
Set the rendering mode of a cubemap texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetFloat>SetFloat</a></td><td class=docright>
Set a shader variable name of a uniform float type to a float value.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetFloat2>SetFloat2</a></td><td class=docright>
Set a shader variable name of a uniform vec2 type to 2 float values.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetFloat3>SetFloat3</a></td><td class=docright>
Set a shader variable name of a uniform vec3 type to 3 float values.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetFloat4>SetFloat4</a></td><td class=docright>
Set a shader variable name of a uniform vec4 type to 4 float values.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetInteger>SetInteger</a></td><td class=docright>
Set a shader variable name of a uniform int type to an integer value.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetInteger2>SetInteger2</a></td><td class=docright>
Set a shader variable name of a uniform ivec2 type to 2 integer values.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetInteger3>SetInteger3</a></td><td class=docright>
Set a shader variable name of a uniform ivec3 type to 3 integer values.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetInteger4>SetInteger4</a></td><td class=docright>
Set a shader variable name of a uniform ivec4 type to 4 integer values.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetShadowColor>SetShadowColor</a></td><td class=docright>
Set color R/G/B in range 0..255 and A in range 0..1.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetString>SetString</a></td><td class=docright>
Sets a C string from a Blitz string.
</td></tr>
<tr><td class=docleft width=1%><a href=#ShadeEntity>ShadeEntity</a></td><td class=docright>
Apply shader to an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#ShadeMesh>ShadeMesh</a></td><td class=docright>
Apply shader to a mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#ShaderFunction>ShaderFunction</a></td><td class=docright>
undocumented.
</td></tr>
<tr><td class=docleft width=1%><a href=#ShaderMaterial>ShaderMaterial</a></td><td class=docright>
Set a 3d texture for sampling.
</td></tr>
<tr><td class=docleft width=1%><a href=#ShaderTexture>ShaderTexture</a></td><td class=docright>
Load a texture for 2D texture sampling.
</td></tr>
<tr><td class=docleft width=1%><a href=#ShadeSurface>ShadeSurface</a></td><td class=docright>
Apply shader to a surface.
</td></tr>
<tr><td class=docleft width=1%><a href=#ShowEntity>ShowEntity</a></td><td class=docright>
Shows an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#SkinMesh>SkinMesh</a></td><td class=docright>
Set animated surface for each of the bone no and weights arrays.
</td></tr>
<tr><td class=docleft width=1%><a href=#SpriteRenderMode>SpriteRenderMode</a></td><td class=docright>
If mode is 1 rendering is normal, 2 is for batch sprites like particles.
</td></tr>
<tr><td class=docleft width=1%><a href=#SpriteViewMode>SpriteViewMode</a></td><td class=docright>
Sets the view mode of a sprite.
</td></tr>
<tr><td class=docleft width=1%><a href=#StencilAlpha>StencilAlpha</a></td><td class=docright>
Set stencil alpha value.
</td></tr>
<tr><td class=docleft width=1%><a href=#StencilClsColor>StencilClsColor</a></td><td class=docright>
Set stencil clear screen color in range 0..255.
</td></tr>
<tr><td class=docleft width=1%><a href=#StencilClsMode>StencilClsMode</a></td><td class=docright>
Set stencil clear screen modes.
</td></tr>
<tr><td class=docleft width=1%><a href=#StencilMesh>StencilMesh</a></td><td class=docright>
Set mesh to be used as stencil.
</td></tr>
<tr><td class=docleft width=1%><a href=#StencilMode>StencilMode</a></td><td class=docright>
Set stencil render modes.
</td></tr>
<tr><td class=docleft width=1%><a href=#StringPtr>StringPtr</a></td><td class=docright>
Returns string cast of byte pointer.
</td></tr>
<tr><td class=docleft width=1%><a href=#SurfsRendered>SurfsRendered</a></td><td class=docright>
Number of surfaces currently being rendered.
</td></tr>
<tr><td class=docleft width=1%><a href=#TerrainCountTriangles>TerrainCountTriangles</a></td><td class=docright>
Returns terrain triangles count.
</td></tr>
<tr><td class=docleft width=1%><a href=#TerrainCountVertices>TerrainCountVertices</a></td><td class=docright>
Returns terrain vertices count.
</td></tr>
<tr><td class=docleft width=1%><a href=#TerrainDetail>TerrainDetail</a></td><td class=docright>
Set terrain level of detail, default is 100 and maximum is 2000.
</td></tr>
<tr><td class=docleft width=1%><a href=#TerrainHeight>TerrainHeight</a></td><td class=docright>
Returns the height of the terrain at terrain grid coordinates x.
</td></tr>
<tr><td class=docleft width=1%><a href=#TerrainScaleTexCoords>TerrainScaleTexCoords</a></td><td class=docright>
Set terrain texture coordinates scale, range is 1 to terrain size.
</td></tr>
<tr><td class=docleft width=1%><a href=#TerrainX>TerrainX</a></td><td class=docright>
Returns the interpolated x coordinate on a terrain.
</td></tr>
<tr><td class=docleft width=1%><a href=#TerrainY>TerrainY</a></td><td class=docright>
Returns the interpolated y coordinate on a terrain.
</td></tr>
<tr><td class=docleft width=1%><a href=#TerrainZ>TerrainZ</a></td><td class=docright>
Returns the interpolated z coordinate on a terrain.
</td></tr>
<tr><td class=docleft width=1%><a href=#TexToBuffer>TexToBuffer</a></td><td class=docright>
Copy texture to a pixmap buffer, buffer must be a byte ptr.
</td></tr>
<tr><td class=docleft width=1%><a href=#TextureAnIsotropic>TextureAnIsotropic</a></td><td class=docright>
Set texture anisotropic factor, usually from 2-16.
</td></tr>
<tr><td class=docleft width=1%><a href=#TextureBlend>TextureBlend</a></td><td class=docright>
Sets the blending mode for a texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#TextureCoords>TextureCoords</a></td><td class=docright>
Sets the texture coordinate mode for a texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#TextureFilter>TextureFilter</a></td><td class=docright>
Adds a texture filter.
</td></tr>
<tr><td class=docleft width=1%><a href=#TextureFlags>TextureFlags</a></td><td class=docright>
Set texture flags, see LoadTexture for values.
</td></tr>
<tr><td class=docleft width=1%><a href=#TextureGLTexEnvf>TextureGLTexEnvf</a></td><td class=docright>
GL equivalent, param is a float, limited to 12 calls per texture, experimental.
</td></tr>
<tr><td class=docleft width=1%><a href=#TextureGLTexEnvi>TextureGLTexEnvi</a></td><td class=docright>
GL equivalent, param is a const, limited to 12 calls per texture, experimental.
</td></tr>
<tr><td class=docleft width=1%><a href=#TextureHeight>TextureHeight</a></td><td class=docright>
Returns the height of a texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#TextureMultitex>TextureMultitex</a></td><td class=docright>
Set texture multitex factor, used in interpolate and custom TexBlend options.
</td></tr>
<tr><td class=docleft width=1%><a href=#TextureName>TextureName</a></td><td class=docright>
Returns a texture's absolute filename.
</td></tr>
<tr><td class=docleft width=1%><a href=#TextureWidth>TextureWidth</a></td><td class=docright>
Returns the width of a texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#TFormedX>TFormedX</a></td><td class=docright>
Returns the X component of the last TFormPoint.
</td></tr>
<tr><td class=docleft width=1%><a href=#TFormedY>TFormedY</a></td><td class=docright>
Returns the Y component of the last TFormPoint.
</td></tr>
<tr><td class=docleft width=1%><a href=#TFormedZ>TFormedZ</a></td><td class=docright>
Returns the Z component of the last TFormPoint.
</td></tr>
<tr><td class=docleft width=1%><a href=#TFormNormal>TFormNormal</a></td><td class=docright>
Transforms between coordinate systems.
</td></tr>
<tr><td class=docleft width=1%><a href=#TFormPoint>TFormPoint</a></td><td class=docright>
Transforms between coordinate systems.
</td></tr>
<tr><td class=docleft width=1%><a href=#TFormVector>TFormVector</a></td><td class=docright>
Transforms between coordinate systems.
</td></tr>
<tr><td class=docleft width=1%><a href=#TranslateEntity>TranslateEntity</a></td><td class=docright>
Translates an entity relative to its current position and not its  orientation.
</td></tr>
<tr><td class=docleft width=1%><a href=#TriangleVertex>TriangleVertex</a></td><td class=docright>
Returns the vertex of a triangle corner.
</td></tr>
<tr><td class=docleft width=1%><a href=#TrisRendered>TrisRendered</a></td><td class=docright>
Number of triangles currently being rendered.
</td></tr>
<tr><td class=docleft width=1%><a href=#TurnEntity>TurnEntity</a></td><td class=docright>
Turns an entity relative to its current orientation.
</td></tr>
<tr><td class=docleft width=1%><a href=#UpdateNormals>UpdateNormals</a></td><td class=docright>
Recalculates all normals in a mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#UpdateTexCoords>UpdateTexCoords</a></td><td class=docright>
Recalculates the surface's uvw coord set 1 based on vertices.
</td></tr>
<tr><td class=docleft width=1%><a href=#UpdateWorld>UpdateWorld</a></td><td class=docright>
Animates all entities in the world.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseAssimpStreamMeshes>UseAssimpStreamMeshes</a></td><td class=docright>
Loader flags for Assimp meshes.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseCubemapFlip>UseCubemapFlip</a></td><td class=docright>
Flip cubemap texture flag.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseEntity>UseEntity</a></td><td class=docright>
undocumented.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseFloat>UseFloat</a></td><td class=docright>
Bind a float variable to a shader variable name of a uniform float type.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseFloat2>UseFloat2</a></td><td class=docright>
Bind 2 float variables to a shader variable name of a uniform vec2 Type.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseFloat3>UseFloat3</a></td><td class=docright>
Bind 3 float variables to a shader variable name of a uniform vec3 type.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseFloat4>UseFloat4</a></td><td class=docright>
Bind 4 float variables to a shader variable name of a uniform vec4 type.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseInteger>UseInteger</a></td><td class=docright>
Bind an integer variable to a shader variable name of a uniform int type.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseInteger2>UseInteger2</a></td><td class=docright>
Bind 2 integer variables to a shader variable name of a uniform ivec2 type.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseInteger3>UseInteger3</a></td><td class=docright>
Bind 3 integer variables to a shader variable name of a uniform ivec3 type.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseInteger4>UseInteger4</a></td><td class=docright>
Bind 4 integer variables to a shader variable name of a uniform ivec4 type.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseLibraryMeshes>UseLibraryMeshes</a></td><td class=docright>
Loader flag for meshes.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseLibraryTextures>UseLibraryTextures</a></td><td class=docright>
Loader flag for textures.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseMatrix>UseMatrix</a></td><td class=docright>
Sends matrix data to a shader variable name of a uniform mat4 type.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseMatrix3DS>UseMatrix3DS</a></td><td class=docright>
Set 3DS model loader coordinates system (matrix), values should be 0,1,-1.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseMatrixMD2>UseMatrixMD2</a></td><td class=docright>
Set MD2 model loader coordinates system (matrix), values should be 0,1,-1.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseMeshDebugLog>UseMeshDebugLog</a></td><td class=docright>
Debug all mesh loaders.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseMeshTextureFlags>UseMeshTextureFlags</a></td><td class=docright>
Set mesh texture flags.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseMeshTransform>UseMeshTransform</a></td><td class=docright>
Transform mesh loaders.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseStencil>UseStencil</a></td><td class=docright>
Stencil to use, set to Null to disable stencil.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseSurface>UseSurface</a></td><td class=docright>
Sends surface data to a shader variable name.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseTextureFaces>UseTextureFaces</a></td><td class=docright>
Order for cubemap faces.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseTextureFrames>UseTextureFrames</a></td><td class=docright>
Order for anim texture frames.
</td></tr>
<tr><td class=docleft width=1%><a href=#VectorPitch>VectorPitch</a></td><td class=docright>
Returns the pitch value of a vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#VectorYaw>VectorYaw</a></td><td class=docright>
Returns the yaw value of a vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexAlpha>VertexAlpha</a></td><td class=docright>
Returns the alpha component of a vertices color.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexBlue>VertexBlue</a></td><td class=docright>
Returns the blue component of a vertices color.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexColor>VertexColor</a></td><td class=docright>
Sets the color of an existing vertex.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexCoords>VertexCoords</a></td><td class=docright>
Sets the geometric coordinates of an existing vertex.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexGreen>VertexGreen</a></td><td class=docright>
Returns the green component of a vertices color.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexNormal>VertexNormal</a></td><td class=docright>
Sets the normal of an existing vertex.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexNX>VertexNX</a></td><td class=docright>
Returns the x component of a vertices normal.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexNY>VertexNY</a></td><td class=docright>
Returns the y component of a vertices normal.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexNZ>VertexNZ</a></td><td class=docright>
Returns the z component of a vertices normal.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexRed>VertexRed</a></td><td class=docright>
Returns the red component of a vertices color.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexTexCoords>VertexTexCoords</a></td><td class=docright>
Sets the texture coordinates of an existing vertex.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexU>VertexU</a></td><td class=docright>
Returns the texture u coordinate of a vertex.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexV>VertexV</a></td><td class=docright>
Returns the texture v coordinate of a vertex.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexW>VertexW</a></td><td class=docright>
Returns the texture w coordinate of a vertex.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexX>VertexX</a></td><td class=docright>
Returns the x coordinate of a vertex.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexY>VertexY</a></td><td class=docright>
Returns the y coordinate of a vertex.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexZ>VertexZ</a></td><td class=docright>
Returns the z coordinate of a vertex.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertsRendered>VertsRendered</a></td><td class=docright>
Number of vertices currently being rendered.
</td></tr>
<tr><td class=docleft width=1%><a href=#VoxelSpriteMaterial>VoxelSpriteMaterial</a></td><td class=docright>
Set material for voxel sprite.
</td></tr>
<tr><td class=docleft width=1%><a href=#Wireframe>Wireframe</a></td><td class=docright>
Enables or disables wireframe rendering.
</td></tr>
</table>
<h2><a name=types></a>Types Summary</h2><table class=doc width=100%>
<tr><td class=docleft width=1%><a href=#TAction>TAction</a></td><td class=docright>
Action.
</td></tr>
<tr><td class=docleft width=1%><a href=#TAnimationKeys>TAnimationKeys</a></td><td class=docright>
AnimationKeys data.
</td></tr>
<tr><td class=docleft width=1%><a href=#TBlitz2D>TBlitz2D</a></td><td class=docright>
Blitz2D.
</td></tr>
<tr><td class=docleft width=1%><a href=#TBlob>TBlob</a></td><td class=docright>
Blob entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TBone>TBone</a></td><td class=docright>
Bone entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TBrush>TBrush</a></td><td class=docright>
Brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#TCamera>TCamera</a></td><td class=docright>
Camera entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TConstraint>TConstraint</a></td><td class=docright>
Constraint.
</td></tr>
<tr><td class=docleft width=1%><a href=#TEntity>TEntity</a></td><td class=docright>
Entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TFluid>TFluid</a></td><td class=docright>
Fluid mesh entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TGeosphere>TGeosphere</a></td><td class=docright>
Geosphere terrain entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TGlobal3D>TGlobal3D</a></td><td class=docright>
Global.
</td></tr>
<tr><td class=docleft width=1%><a href=#THardwareInfo>THardwareInfo</a></td><td class=docright>
Hardware info.
</td></tr>
<tr><td class=docleft width=1%><a href=#TLight>TLight</a></td><td class=docright>
Light entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TMaterial>TMaterial</a></td><td class=docright>
Material texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#TMatPtr>TMatPtr</a></td><td class=docright>
MatPtr functions (Openb3d)
</td></tr>
<tr><td class=docleft width=1%><a href=#TMatrix>TMatrix</a></td><td class=docright>
Matrix functions (Minib3d)
</td></tr>
<tr><td class=docleft width=1%><a href=#TMesh>TMesh</a></td><td class=docright>
Mesh entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TMeshLoader>TMeshLoader</a></td><td class=docright>
Mesh loader.
</td></tr>
<tr><td class=docleft width=1%><a href=#TOcTree>TOcTree</a></td><td class=docright>
Octree terrain entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TParticleBatch>TParticleBatch</a></td><td class=docright>
Particle Batch mesh entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TParticleEmitter>TParticleEmitter</a></td><td class=docright>
Particle Emitter entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TPick>TPick</a></td><td class=docright>
Pick.
</td></tr>
<tr><td class=docleft width=1%><a href=#TPivot>TPivot</a></td><td class=docright>
Pivot entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TPostFX>TPostFX</a></td><td class=docright>
Post effects object.
</td></tr>
<tr><td class=docleft width=1%><a href=#TQuaternion>TQuaternion</a></td><td class=docright>
Quaternion functions (Minib3d)
</td></tr>
<tr><td class=docleft width=1%><a href=#TQuatPtr>TQuatPtr</a></td><td class=docright>
QuatPtr functions (Openb3d)
</td></tr>
<tr><td class=docleft width=1%><a href=#TRigidBody>TRigidBody</a></td><td class=docright>
Rigid Body.
</td></tr>
<tr><td class=docleft width=1%><a href=#TShader>TShader</a></td><td class=docright>
Shader.
</td></tr>
<tr><td class=docleft width=1%><a href=#TShaderObject>TShaderObject</a></td><td class=docright>
Shader object.
</td></tr>
<tr><td class=docleft width=1%><a href=#TShadowObject>TShadowObject</a></td><td class=docright>
Shadow object.
</td></tr>
<tr><td class=docleft width=1%><a href=#TSprite>TSprite</a></td><td class=docright>
Sprite mesh entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TStencil>TStencil</a></td><td class=docright>
Stencil.
</td></tr>
<tr><td class=docleft width=1%><a href=#TSurface>TSurface</a></td><td class=docright>
Surface.
</td></tr>
<tr><td class=docleft width=1%><a href=#TTerrain>TTerrain</a></td><td class=docright>
Terrain entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TTexture>TTexture</a></td><td class=docright>
Texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#TUse>TUse</a></td><td class=docright>
Loader flags for meshes and textures.
</td></tr>
<tr><td class=docleft width=1%><a href=#TVecPtr>TVecPtr</a></td><td class=docright>
TVecPtr functions (Openb3d)
</td></tr>
<tr><td class=docleft width=1%><a href=#TVector>TVector</a></td><td class=docright>
TVector functions (Minib3d)
</td></tr>
<tr><td class=docleft width=1%><a href=#TVoxelSprite>TVoxelSprite</a></td><td class=docright>
Voxelsprite mesh entity.
</td></tr>
</table>
<h2
 id=functionsdet>Functions
</h2>
<table class=doc width=100% cellspacing=3 id=ActFadeTo>
<tr><td class=doctop colspan=2>Function ActFadeTo:TAction( ent:TEntity,a:Float,rate:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Fades entity to the given alpha value (0..1) at the speed of rate.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ActMoveBy>
<tr><td class=doctop colspan=2>Function ActMoveBy:TAction( ent:TEntity,a:Float,b:Float,c:Float,rate:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Moves entity by an x y z position increment at the speed of rate.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ActMoveTo>
<tr><td class=doctop colspan=2>Function ActMoveTo:TAction( ent:TEntity,a:Float,b:Float,c:Float,rate:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Moves entity to the given x y z position at the speed of rate.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ActNewtonian>
<tr><td class=doctop colspan=2>Function ActNewtonian:TAction( ent:TEntity,rate:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Translates entity in the direction it is moving, rate should be below 1.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ActScaleTo>
<tr><td class=doctop colspan=2>Function ActScaleTo:TAction( ent:TEntity,a:Float,b:Float,c:Float,rate:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Scales entity to the given x y z dimensions at the speed of rate.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ActTintTo>
<tr><td class=doctop colspan=2>Function ActTintTo:TAction( ent:TEntity,a:Float,b:Float,c:Float,rate:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Tints entity to the given r g b value (0..255) at the speed of rate.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ActTrackByDistance>
<tr><td class=doctop colspan=2>Function ActTrackByDistance:TAction( ent:TEntity,target:TEntity,a:Float,rate:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Tracks target entity up to a given distance at the speed of rate.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ActTrackByPoint>
<tr><td class=doctop colspan=2>Function ActTrackByPoint:TAction( ent:TEntity,target:TEntity,a:Float,b:Float,c:Float,rate:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Tracks target entity at a given point from the entity at the speed of rate.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ActTurnBy>
<tr><td class=doctop colspan=2>Function ActTurnBy:TAction( ent:TEntity,a:Float,b:Float,c:Float,rate:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Turns entity by an x y z rotation increment at the speed of rate.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ActTurnTo>
<tr><td class=doctop colspan=2>Function ActTurnTo:TAction( ent:TEntity,a:Float,b:Float,c:Float,rate:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Turns entity to the given x y z rotation at the speed of rate.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ActVector>
<tr><td class=doctop colspan=2>Function ActVector:TAction( ent:TEntity,a:Float,b:Float,c:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Positions entity according the given x y z vector.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AddAnimSeq>
<tr><td class=doctop colspan=2>Function AddAnimSeq:Int( ent:TEntity,length:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates an animation sequence for an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
length -
<p>
<b>Description</b>:
<p>
Creates an animation sequence for an entity. This must be done before any  animation keys set by SetAnimKey can be used in  an actual animation however this is optional. You may use it to "bake" the frames you have added previously using SetAnimKey.
<p>
Returns the animation sequence number added.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AddMesh>
<tr><td class=doctop colspan=2>Function AddMesh( mesh1:TMesh,mesh2:TMesh )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Adds the source mesh to the destination mesh.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
source_mesh - source mesh handle
<p>
dest_mesh - destination mesh handle
<p>
<b>Description</b>:
<p>
Adds the source mesh to the destination mesh.
<p>
AddMesh works best with  meshes that have previously only had mesh commands used with them.
<p>
So if you want to manipulate a mesh before adding it to another mesh, make  sure you use ScaleMesh, PositionMesh, PaintMesh etc rather than ScaleEntity,  PositionEntity, EntityTexture etc before using AddMesh.
<p>
However, something to be aware of when using commands such as RotateMesh  is that all mesh commands work from a global origin of 0,0,0. Therefore it is  generally a good idea to scale and rotate a mesh before positioning it, otherwise  your mesh could end up in unexpected positions. Also, when using AddMesh, the  origin of the new all-in-one mesh will be set at 0,0,0.
<p>
After using AddMesh, the original source_mesh will still exist, therefore  use FreeEntity to delete it if you wish to do so.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AddRenderTarget>
<tr><td class=doctop colspan=2>Function AddRenderTarget( fx:TPostFX,pass_no:Int,numColBufs:Int,depth:Int,format:Int=8,scale:Float=1.0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>undocumented.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AddSurface>
<tr><td class=doctop colspan=2>Function AddSurface( mesh:TMesh,surf:TSurface,anim_surf%=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Add an existing surface to a mesh.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AddTriangle>
<tr><td class=doctop colspan=2>Function AddTriangle:Int( surf:TSurface,v0:Int,v1:Int,v2:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Adds a triangle to a surface and returns the triangle's index number.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
v0 - index number of first vertex of triangle
<p>
v1 - index number of second vertex of triangle
<p>
v2 - index number of third vertex of triangle
<p>
<b>Description</b>:
<p>
Adds a triangle to a surface and returns the triangle's index number, starting  from 0.
<p>
The v0, v1 and v2 parameters are the index numbers of the vertices  created using AddVertex.
<p>
Depending on how the vertices are arranged, then the triangle will only be  visible from a certain side. Imagine that a triangle's vertex points are like  dot-to-dot pattern, each numbered v0, v1, v2. If these dots, starting from v0,  through to V2, form a clockwise pattern relative to the viewer, then the triangle  will be visible. If these dots form an anti-clockwise pattern relative to the  viewer, then the triangle will not be visible.
<p>
The reason for having one-sided triangles is that it reduces the amount of  triangles that need to be rendered when one side faces the side of an object  which won't be seen (such as the inside of a snooker ball). However, if you  wish for a triangle to be two-sided, then you can either create two triangles,  using the same set of vertex numbers for both but assigning them in opposite  orders, or you can use CopyEntity and FlipMesh together.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AddVertex>
<tr><td class=doctop colspan=2>Function AddVertex:Int( surf:TSurface,x:Float,y:Float,z:Float,u:Float=0,v:Float=0,w:Float=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Adds a vertex to the specified surface and returns the vertices' index number.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
x# - x coordinate of vertex
<p>
y# - y coordinate of vertex
<p>
z# - z coordinate of vertex
<p>
u# (optional) - u texture coordinate of vertex
<p>
v# (optional) - v texture coordinate of vertex
<p>
w# (optional) - w texture coordinate of vertex - not used, included for future expansion
<p>
<b>Description</b>:
<p>
Adds a vertex to the specified surface and returns the vertices' index number,  starting from 0.
<p>
x,y,z are the geometric coordinates of the vertex, and u,v,w are texture mapping coordinates.
<p>
A vertex is a point in 3D space which is used to connect edges of a triangle together. Without any vertices, you can't have any triangles. At least three  vertices are needed to create one triangle; one for each corner.
<p>
The optional u, v and w parameters allow you to specify texture coordinates for a vertex, which will determine how any triangle created using those vertices will be texture mapped. The u, v and w parameters specified will take effect on both texture coordinate sets (0 and 1). This works on the following basis:
<p>
The top left of an image has the uv coordinates 0,0.
The top right has coordinates 1,0
The bottom right is 1,1.
The bottom left 0,1.
<p>
Thus, uv coordinates for a vertex correspond to a point in the image. For example, coordinates 0.9,0.1 would be near the upper right corner of the image.
<p>
So now imagine you have a normal equilateral triangle. By assigning the bottom left vertex a uv coordinate of 0,0, the bottom right a coordinate of 1,0 and the top centre 0.5,1, this will texture map the triangle with an image that fits it.
<p>
When adding a vertex its default color is 255,255,255,255.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AlignToVector>
<tr><td class=doctop colspan=2>Function AlignToVector( entity:TEntity,x:Float,y:Float,z:Float,axis:Int,rate:Int=1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Aligns an entity axis to a vector.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
vector_x# - vector x
<p>
vector_y# - vector y
<p>
vector_z# - vector z
<p>

axis - axis of entity that will be aligned to vector
<p>
1: x-axis
<p>
2: y-axis
<p>
3: z-axis
<p>

rate# (optional) - rate at which entity is aligned from current  orientation to vector orientation. Should be in the range 0 to 1, 0 for smooth  transition and 1 for 'snap' transition. Defaults to 1.
<p>
<b>Description</b>:
<p>
Aligns an entity axis to a vector.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AlphaDiscard>
<tr><td class=doctop colspan=2>Function AlphaDiscard( tex:TTexture,alpha:Float=0.01 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set discard value (as 0..1) above which to ignore pixel's alpha value, default is 1 (only if flag 2)</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AmbientLight>
<tr><td class=doctop colspan=2>Function AmbientLight( r:Float,g:Float,b:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the ambient lighting colour.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
red# - red ambient light value
<p>
green# - green ambient light value
<p>
blue# - blue ambient light value
<p>

The green, red and blue values should be  in the range 0-255. The default ambient light colour is 127,127,127.
<p>
<b>Description</b>:
<p>
Sets the ambient lighting colour.
<p>
Ambient light is a light source that affects all points on a 3D object equally.  So with ambient light only, all 3D objects will appear flat, as there will be  no shading.
<p>
Ambient light is useful for providing a certain level of light, before adding  other lights to provide a realistic lighting effect.
<p>
An ambient light level of 0,0,0 will result in no ambient light being displayed.
<p>
See also: <a href=#CreateLight>CreateLight</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AmbientShader>
<tr><td class=doctop colspan=2>Function AmbientShader( material:TShader )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set default shader for surfaces.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=Animate>
<tr><td class=doctop colspan=2>Function Animate( ent:TEntity,Mode:Int=1,speed:Float=1,seq:Int=0,trans:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Animates an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>

mode (optional) - mode of animation.
<p>
0: stop animation
<p>
1: loop animation (default)
<p>
2: ping-pong animation
<p>
3: one-shot animation
<p>

speed# (optional) - speed of animation. Defaults to 1.
<p>
sequence (optional) - specifies which sequence of animation frames to play.  Defaults to 0.
<p>
transition# (optional) - used to tween between an entities current position  rotation and the first frame of animation. Defaults to 0.
<p>
<b>Description</b>:
<p>
Animates an entity.
<p>
More info about the optional parameters:
<p>
speed# - a negative speed will play the animation backwards.
<p>
sequence - Initially, an entity loaded with LoadAnimMesh  will have a single animation sequence. More sequences can be added using either LoadAnimSeq or AddAnimSeq.  Animation sequences are numbered 0,1,2...etc.
<p>
transition# - A value of 0 will cause an instant 'leap' to the first frame,  while values greater than 0 will cause a smooth transition.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=Animating>
<tr><td class=doctop colspan=2>Function Animating:Int( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns true if the specified entity is currently animating.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Returns true if the specified entity is currently animating.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AnimLength>
<tr><td class=doctop colspan=2>Function AnimLength:Int( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the length of the specified entity's current animation sequence.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Returns the length of the specified entity's current animation sequence.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AnimSeq>
<tr><td class=doctop colspan=2>Function AnimSeq:Int( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the specified entity's current animation sequence.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Returns the specified entity's current animation sequence.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AnimTime>
<tr><td class=doctop colspan=2>Function AnimTime:Float( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the current animation time of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Returns the current animation time of an entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AntiAlias>
<tr><td class=doctop colspan=2>Function AntiAlias( samples:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enables or disables fullscreen antialiasing.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
enable - True to enable fullscreen antialiasing, False to disable.
<p>

The default AntiAlias mode is False.
<p>
<b>Description</b>:
<p>
Enables or disables fullscreen antialiasing.
<p>
Fullscreen antialiasing is a technique used to smooth out the entire screen,  so that jagged lines are made less noticeable.
<p>
Some 3D cards have built-in support for fullscreen antialiasing, which should  allow you to enable the effect without much slowdown. However, for cards without  built-in support for fullscreen antialiasing, enabling the effect may cause  severe slowdown.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AppendAction>
<tr><td class=doctop colspan=2>Function AppendAction( act1:TAction,act2:TAction )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Adds action to the end of another one, where act1 happens before act2.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AttachFragShader>
<tr><td class=doctop colspan=2>Function AttachFragShader:Int( shader:TShader,myShader:TShaderObject )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Attaches a fragment shader object to a program object, attach vertex first or older compilers will crash.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AttachVertShader>
<tr><td class=doctop colspan=2>Function AttachVertShader:Int( shader:TShader,myShader:TShaderObject )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Attaches a vertex shader object to a program object.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=BackBufferToTex>
<tr><td class=doctop colspan=2>Function BackBufferToTex( tex:TTexture,mipmap_no:Int=0,frame:Int=0,fastinvert:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy the contents of the backbuffer to a texture.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>OpenB3D does not have the same buffer commands as Blitz3D.
The region copied from the backbuffer will start at 0,0 and end at the texture's width and height.
So if you want to copy a 3D scene to a texture, first resize the camera viewport to the texture size,
use RenderWorld to render the camera, then use this command.
Back buffer is upside-down so set fastinvert to True to invert texture uvs, False to flip texture data (slower).</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=BeginMax2D>
<tr><td class=doctop colspan=2>Function BeginMax2D( version:Int=1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Old begin function as in Minib3d is 0, new begin function is 1 (default)</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=BrushAlpha>
<tr><td class=doctop colspan=2>Function BrushAlpha( brush:TBrush,a:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the alpha level of a brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
brush - brush handle
<p>
alpha# - alpha level of brush
<p>
<b>Description</b>:
<p>
Sets the alpha level of a brush.
<p>
The alpha# value should be in the range  0-1. The default brush alpha setting is 1.
<p>
The alpha level is how transparent an entity is. A value of 1 will mean the  entity is non-transparent, i.e. opaque. A value of 0 will mean the entity is  completely transparent, i.e. invisible. Values between 0 and 1 will cause varying  amount of transparency accordingly, useful for imitating the look of objects  such as glass and ice.
<p>
An BrushAlpha value of 0 is especially useful as Blitz3D will not render  entities with such a value, but will still involve the entities in collision  tests. This is unlike HideEntity, which doesn't  involve entities in collisions.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=BrushBlend>
<tr><td class=doctop colspan=2>Function BrushBlend( brush:TBrush,blend:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the blending mode for a brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
brush - brush handle
<p>
blend -
<p>
1: alpha (default)
<p>
2: multiply
<p>
3: add
<p>
<b>Description</b>:
<p>
Sets the blending mode for a brush.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=BrushColor>
<tr><td class=doctop colspan=2>Function BrushColor( brush:TBrush,r:Float,g:Float,b:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the colour of a brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
brush - brush handle
<p>
red# - red value of brush
<p>
green# - green value of brush
<p>
blue# - blue value of brush
<p>
<b>Description</b>:
<p>
Sets the colour of a brush.
<p>
The green, red and blue values should be in  the range 0-255. The default brush color is  255,255,255.
<p>
Please note that if EntityFX or  BrushFX flag 2 is being used, brush colour will have no effect and vertex  colours will be used instead.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=BrushFX>
<tr><td class=doctop colspan=2>Function BrushFX( brush:TBrush,fx:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets miscellaneous effects for a brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
brush - brush handle
<p>

fx -
<p>
0: nothing (default)
<p>
1: full-bright
<p>
2: use vertex colors instead of brush color
<p>
4: flatshaded
<p>
8: disable fog
<p>
16: disable backface culling
<p>
<b>Description</b>:
<p>
Sets miscellaneous effects for a brush.
<p>
Flags can be added to combine  two or more effects. For example, specifying a flag of 3 (1+2) will result in  a full-bright and vertex-coloured brush.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=BrushGLBlendFunc>
<tr><td class=doctop colspan=2>Function BrushGLBlendFunc( brush:TBrush,sfactor:Int,dfactor:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>GL equivalent, experimental.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=BrushGLColor>
<tr><td class=doctop colspan=2>Function BrushGLColor( brush:TBrush,r:Float,g:Float,b:Float,a:Float=1.0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>GL equivalent, experimental.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=BrushShininess>
<tr><td class=doctop colspan=2>Function BrushShininess( brush:TBrush,s:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the specular shininess of a brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
brush - brush handle
<p>
shininess# - shininess of brush
<p>
<b>Description</b>:
<p>
Sets the specular shininess of a brush.
<p>
The shininess# value should be  in the range 0-1. The default shininess setting is 0.
<p>
Shininess is how much brighter certain areas of an object will appear to  be when a light is shone directly at them.
<p>
Setting a shininess value of 1 for a medium to high poly sphere, combined  with the creation of a light shining in the direction of it, will give it the  appearance of a shiny snooker ball.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=BrushTexture>
<tr><td class=doctop colspan=2>Function BrushTexture( brush:TBrush,tex:TTexture,frame:Int=0,index:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Assigns a texture to a brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
brush - brush handle
<p>
texture - texture handle
<p>
frame (optional) - texture frame. Defaults to 0.
<p>
index (optional) - texture index. Defaults to 0.
<p>
<b>Description</b>:
<p>
Assigns a texture to a brush.
<p>
The optional frame parameter specifies which  animation frame, if any exist, should be assigned to the brush.
<p>
The optional index parameter specifies texture layer that the texture should  be assigned to. Brushes have up to four texture layers, 0-3 inclusive.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=BufferToTex>
<tr><td class=doctop colspan=2>Function BufferToTex( tex:TTexture,buffer:Byte Ptr,frame:Int=0 ) ' frame currently does nothing</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy pixmap buffer to texture, buffer must be a byte ptr.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraClsColor>
<tr><td class=doctop colspan=2>Function CameraClsColor( cam:TCamera,r:Float,g:Float,b:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets camera background color.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
camera - camera handle
<p>
red# - red value of camera background color
<p>
green# - green value of camera background color
<p>
blue# - blue value of camera background color
<p>
<b>Description</b>:
<p>
Sets camera background color. Defaults to 0,0,0.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraClsMode>
<tr><td class=doctop colspan=2>Function CameraClsMode( cam:TCamera,cls_depth:Int,cls_zbuffer:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets camera clear mode.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
camera - camera handle
<p>
cls_color - true to clear the color buffer, false not to
<p>
cls_zbuffer - true to clear the z-buffer, false not to
<p>
<b>Description</b>:
<p>
Sets camera clear mode.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraFogColor>
<tr><td class=doctop colspan=2>Function CameraFogColor( cam:TCamera,r:Float,g:Float,b:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets camera fog color.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
camera - camera handle
<p>
red# - red value of value
<p>
green# - green value of fog
<p>
blue# - blue value of fog
<p>
<b>Description</b>:
<p>
Sets camera fog color.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraFogMode>
<tr><td class=doctop colspan=2>Function CameraFogMode( cam:TCamera,Mode:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the camera fog mode.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
camera - camera handle
<p>

mode -
<p>
0: no fog (default)
<p>
1: linear fog
<p>
<b>Description</b>:
<p>
Sets the camera fog mode.
<p>
This will enable/disable fogging, a technique  used to gradually fade out graphics the further they are away from the camera.  This can be used to avoid 'pop-up', the moment at which 3D objects suddenly  appear on the horizon.
<p>
The default fog colour is black and the default fog range is 1-1000, although  these can be changed by using CameraFogColor  and CameraFogRange respectively.
<p>
Each camera can have its own fog mode, for multiple on-screen fog effects.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraFogRange>
<tr><td class=doctop colspan=2>Function CameraFogRange( cam:TCamera,nnear:Float,nfar:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets camera fog range.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
camera - camera handle
<p>
near# - distance in front of camera that fog starts
<p>
far# - distance in front of camera that fog ends
<p>
<b>Description</b>:
<p>
Sets camera fog range.
<p>
The near parameter specifies at what distance  in front of the camera that the fogging effect will start; all 3D object  before this point will not be faded.
<p>
The far parameter specifies at what distance in front of the camera that  the fogging effect will end; all 3D objects beyond this point will be  completely faded out.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraPick>
<tr><td class=doctop colspan=2>Function CameraPick:TEntity( cam:TCamera,x:Float,y:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Picks the entity positioned at the specified viewport coordinates.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
camera - camera handle
<p>
viewport_x# - 2D viewport coordinate
<p>
viewport_z# - 2D viewport coordinate
<p>
<b>Description</b>:
<p>
Picks the entity positioned at the specified viewport coordinates.
<p>
Returns  the entity picked, or 0 if none there.
<p>
An entity must have its EntityPickMode set  to a non-0 value value to be 'pickable'.
<p>
See also: <a href=#EntityPick>EntityPick</a>, <a href=#LinePick>LinePick</a>, <a href=#CameraPick>CameraPick</a>, <a href=#EntityPickMode>EntityPickMode</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraProject>
<tr><td class=doctop colspan=2>Function CameraProject( cam:TCamera,x:Float,y:Float,z:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Projects the world coordinates x.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
camera - camera handle
<p>
x# - world coordinate x
<p>
y# - world coordinate y
<p>
z# - world coordinate z
<p>
<b>Description</b>:
<p>
Projects the world coordinates x,y,z on to the 2D screen.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraProjMatrix>
<tr><td class=doctop colspan=2>Function CameraProjMatrix:Float Ptr( cam:TCamera )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>undocumented.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraProjMode>
<tr><td class=doctop colspan=2>Function CameraProjMode( cam:TCamera,Mode:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the camera projection mode.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
camera - camera handle
<p>
mode - projection mode:
<p>
0: no projection - disables camera (faster than HideEntity)
<p>
1: perspective projection (default)
<p>
2: orthographic projection
<p>
<b>Description</b>:
<p>
Sets the camera projection mode.
<p>
The projection mode is the the technique  used by Blitz to display 3D graphics on the screen. Using projection mode 0,  nothing is displayed on the screen, and this is the fastest method of hiding  a camera. Using camera projection mode 1, the graphics are displayed in their  'correct' form - and this is the default mode for a camera. Camera projection  mode 2 is a special type of projection, used for displaying 3D graphics on screen,  but in a 2D form - that is, no sense of perspective will be given to the graphics.  Two identical objects at varying distances from the camera will both appear  to be the same size. Orthographic projection is useful for 3D editors, where  a sense of perspective is unimportant, and also certain games.
<p>
Use 'CameraZoom' to control the scale of graphics rendered with orthographic  projection. As a general rule, using orthographic projection with the default  camera zoom setting of 1 will result in graphics that are too 'zoomed-in' -  changing the camera zoom to 0.1 should fix this.
<p>
One thing to note with using camera project mode 2, is that terrains will  not be displayed correctly - this is because the level of detail algorithm used  by terrains relies on perspective in order to work properly.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraRange>
<tr><td class=doctop colspan=2>Function CameraRange( cam:TCamera,nnear:Float,nfar:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets camera range.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
camera - camera handle
<p>
near - distance in front of camera that 3D objects start being drawn
<p>
far - distance in front of camera that 3D object stop being drawn
<p>
<b>Description</b>:
<p>
Sets camera range.
<p>
Try and keep the ratio of far/near as small as possible  for optimal z-buffer performance. Defaults to 1,1000.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraToTex>
<tr><td class=doctop colspan=2>Function CameraToTex( tex:TTexture,cam:TCamera,frame:Int=0 ) ' frame currently does nothing</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy rendered camera view to texture.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraViewport>
<tr><td class=doctop colspan=2>Function CameraViewport( cam:TCamera,x:Int,y:Int,width:Int,height:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the camera viewport position and size.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
camera - camera handle
<p>
x - x coordinate of top left hand corner of viewport
<p>
y - y coordinate of top left hand corner of viewport
<p>
width - width of viewport
<p>
height - height of viewport
<p>
<b>Description</b>:
<p>
Sets the camera viewport position and size.
<p>
The camera viewport is the  area of the 2D screen that the 3D graphics as viewed by the camera are  displayed in.
<p>
Setting the camera viewport allows you to achieve spilt-screen and  rear-view mirror effects.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraZoom>
<tr><td class=doctop colspan=2>Function CameraZoom( cam:TCamera,zoom:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets zoom factor for a camera.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
camera - camera handle
<p>
zoom# - zoom factor of camera
<p>
<b>Description</b>:
<p>
Sets zoom factor for a camera. Defaults to 1.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CheckFramebufferStatus>
<tr><td class=doctop colspan=2>Function CheckFramebufferStatus( target% )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Check for framebuffer errors.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ClearCollisions>
<tr><td class=doctop colspan=2>Function ClearCollisions()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Clears the collision information list.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Clears the collision information list.
<p>
Whenever you use the Collisions command to enable collisions between  two different entity types, information is added to the collision list. This  command clears that list, so that no collisions will be detected until the Collisions  command is used again.
<p>
The command will not clear entity collision information. For example, entity  radius, type etc.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ClearSurface>
<tr><td class=doctop colspan=2>Function ClearSurface( surf:TSurface,clear_verts:Int=True,clear_tris:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Removes all vertices and/or triangles from a surface.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
clear_verts (optional) - true to remove all vertices from the specified surface,  false not to. Defaults to true.
<p>
clear_triangles (optional) - true to remove all triangles from the specified  surface, false not to. Defaults to true.
<p>
<b>Description</b>:
<p>
Removes all vertices and/or triangles from a surface.
<p>
This is useful for  clearing sections of mesh. The results will be instantly visible.
<p>
After clearing a surface, you may wish to add vertices and triangles to it  again but with a slightly different polygon count for dynamic level of detail  (LOD).</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ClearTextureFilters>
<tr><td class=doctop colspan=2>Function ClearTextureFilters()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Clears the current texture filter list.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Clears the current texture filter list.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ClearWorld>
<tr><td class=doctop colspan=2>Function ClearWorld( entities:Int=True,brushes:Int=True,textures:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Clears all entities.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entities (optional) - True to clear all entities, False not to. Defaults  to true.
<p>
brushes (optional) - True to clear all brushes, False not to. Defaults to true.
<p>
textures (optional) - True to clear all textures, False not to. Defaults to  true.
<p>
<b>Description</b>:
<p>
Clears all entities, brushes and/or textures from the screen and from memory.
<p>
As soon as you clear something, you will not be able to use it again until you  reload it. Trying to do so will cause a runtime error.
<p>
This command is useful for when a level has finished and you wish to load  a different level with new entities, brushes and textures.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CollisionEntity>
<tr><td class=doctop colspan=2>Function CollisionEntity:TEntity( ent:TEntity,index:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the other entity involved in a particular collision.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
index - index of collision
<p>
<b>Description</b>:
<p>
Returns the other entity involved in a particular collision. Index should  be in the range 1...CountCollisions( entity  ), inclusive.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CollisionNX>
<tr><td class=doctop colspan=2>Function CollisionNX:Float( ent:TEntity,index:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the x component of the normal of a particular collision.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
index - index of collision
<p>
<b>Description</b>:
<p>
Returns the x component of the normal of a particular collision.
<p>
Index  should be in the range 1...CountCollisions(  entity ) inclusive.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CollisionNY>
<tr><td class=doctop colspan=2>Function CollisionNY:Float( ent:TEntity,index:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the y component of the normal of a particular collision.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
index - index of collision
<p>
<b>Description</b>:
<p>
Returns the y component of the normal of a particular collision.
<p>
Index  should be in the range 1...CountCollisions(  entity ) inclusive.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CollisionNZ>
<tr><td class=doctop colspan=2>Function CollisionNZ:Float( ent:TEntity,index:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the z component of the normal of a particular collision.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
index - index of collision
<p>
<b>Description</b>:
<p>
Returns the z component of the normal of a particular collision.
<p>
Index  should be in the range 1...CountCollisions(  entity ) inclusive.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=Collisions>
<tr><td class=doctop colspan=2>Function Collisions( src_no:Int,dest_no:Int,method_no:Int,response_no:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enables collisions between two different entity types.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
src_type - entity type to be checked for collisions.
<p>
dest_type - entity type to be collided with.
<p>

<p>
method - collision detection method.
<p>
1: ellipsoid-to-ellipsoid collisions
<p>
2: ellipsoid-to-polygon collisions
<p>
3: ellipsoid-to-box collisions
<p>

<p>
response - what the source entity does when a collision occurs.
<p>
1: stop
<p>
2: slide1 - full sliding collision
<p>
3: slide2 - prevent entities from sliding down slopes
<p>
<b>Description</b>:
<p>
Enables collisions between two different entity types.
<p>
Entity types are just numbers you assign to an entity using EntityType. Blitz then uses the entity types to check for collisions between all the entities that have those entity types.
<p>
Blitz has many ways of checking for collisions, as denoted by the method parameter. However, collision checking is always ellipsoid to something. In order for Blitz to know what size a source entity is, you must first assign an entity radius to all source entities using EntityRadius.
<p>
In the case of collision detection method 1 being selected (ellipsoid-to-ellipsoid), then the destination entities concerned will need to have an EntityRadius assigned to them too. In the case of method 3 being selected (ellipsoid-to-box), then the destination entities  will need to have an EntityBox assigned to them. Method 2 (ellipsoid-to-polygon) requires nothing to be assigned to the destination entities.
<p>
Not only does Blitz check for collisions, but it acts upon them when it detects them too, as denoted by the response parameter. You have three options in this situation. You can either choose to make the source entity stop, slide or only slide upwards.
<p>
All collision checking occurs, and collision responses are acted out, when UpdateWorld is called.
<p>
Finally, every time the Collision command is used, collision information is added to the collision information list. This can be cleared at any time using the ClearCollisions command.
<p>
See also: <a href=#EntityBox>EntityBox</a>, <a href=#EntityRadius>EntityRadius</a>, <a href=#Collisions>Collisions</a>, <a href=#EntityType>EntityType</a>, <a href=#ResetEntity>ResetEntity</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CollisionSurface>
<tr><td class=doctop colspan=2>Function CollisionSurface:TSurface( ent:TEntity,index:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the handle of the surface belonging to the specified entity that was closest to the point of a particular collision.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
index - index of collision
<p>
<b>Description</b>:
<p>
Returns the handle of the surface belonging to the specified entity that was closest to the point of a particular collision.
<p>
Index should be in  the range 1...CountCollisions( entity ), inclusive.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CollisionTime>
<tr><td class=doctop colspan=2>Function CollisionTime:Float( ent:TEntity,index:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the time taken to calculate a particular collision.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
index - index of collision
<p>
<b>Description</b>:
<p>
Returns the time taken to calculate a particular collision.
<p>
Index should be in the range 1...CountCollisions(  entity ) inclusive.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CollisionTriangle>
<tr><td class=doctop colspan=2>Function CollisionTriangle:Int( ent:TEntity,index:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the index number of the triangle belonging to the specified entity  that was closest to the point of a particular collision.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
index - index of collision
<p>
<b>Description</b>:
<p>
Returns the index number of the triangle belonging to the specified entity  that was closest to the point of a particular collision.
<p>
Index should be in the range 1...CountCollisions(  entity ), inclusive.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CollisionX>
<tr><td class=doctop colspan=2>Function CollisionX:Float( ent:TEntity,index:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the world x coordinate of a particular collision.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
index - index of collision
<p>
<b>Description</b>:
<p>
Returns the world x coordinate of a particular collision.
<p>
Index should  be in the range 1...CountCollisions( entity  ) inclusive.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CollisionY>
<tr><td class=doctop colspan=2>Function CollisionY:Float( ent:TEntity,index:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the world y coordinate of a particular collision.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
index - index of collision
<p>
<b>Description</b>:
<p>
Returns the world y coordinate of a particular collision.
<p>
Index should  be in the range 1...CountCollisions( entity  ) inclusive.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CollisionZ>
<tr><td class=doctop colspan=2>Function CollisionZ:Float( ent:TEntity,index:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the world z coordinate of a particular collision.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
index - index of collision
<p>
<b>Description</b>:
<p>
Returns the world z coordinate of a particular collision.
<p>
Index should  be in the range 1...CountCollisions( entity  ) inclusive.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CopyBrush>
<tr><td class=doctop colspan=2>Function CopyBrush:TBrush( brush:TBrush )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a copy of the new brush.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CopyEntity>
<tr><td class=doctop colspan=2>Function CopyEntity:TEntity( ent:TEntity,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a copy of an entity and returns the handle of the newly created copy.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - Entity Handle
<p>
parent (optional) - Entity that will act as Parent to the copy.
<p>
<b>Description</b>:
<p>
Creates a copy of an entity and returns the handle of the newly created copy. This is a new entity instance of an existing entity's mesh! Anything you do to the original Mesh (such as RotateMesh) will effect all the copies. Other properties (such as EntityColor, Position etc.) since they are 'Entity' properties, will be individual to the copy.
<p>
If a parent entity is specified, the copied entity will be created at the parent entity's position. Otherwise, it will be created at 0,0,0.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CopyList>
<tr><td class=doctop colspan=2>Function CopyList( list:TList )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy a list or vector. To copy a field list use as a method.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Use either mesh with surf_list/anim_surf_list/bones or ent with child_list.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CopyMesh>
<tr><td class=doctop colspan=2>Function CopyMesh:TMesh( mesh:TMesh,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a copy of a mesh and returns the newly-created mesh's handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - handle of mesh to be copied
<p>
parent (optional) - handle of entity to be made parent of mesh
<p>
<b>Description</b>:
<p>
Creates a copy of a mesh and returns the newly-created mesh's handle.
<p>
The difference between CopyMesh and CopyEntity  is that CopyMesh performs a 'deep' copy of a mesh.
<p>
CopyMesh is identical to performing new_mesh=CreateMesh() : AddMesh mesh,new_mesh.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CopyRect>
<tr><td class=doctop colspan=2>Function CopyRect( srcX:Int,srcY:Int,srcW:Int,srcH:Int,dstW:Int,dstH:Int,src:Byte Ptr,dst:Byte Ptr,bPP:Int=4,invert:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy rectangle of source pixmap pixels to destination, not exactly like B3D.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>srcW/H is src size, srcX/srcY top-left position, dstW/H is dst size, bytes per pixel defaults to 4.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CopySurface>
<tr><td class=doctop colspan=2>Function CopySurface:TSurface( surf:TSurface )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a copy of the new surface.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CopyTexture>
<tr><td class=doctop colspan=2>Function CopyTexture:TTexture( tex:TTexture,flags:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a copy of the new texture.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CountChildren>
<tr><td class=doctop colspan=2>Function CountChildren:Int( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the number of children of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Returns the number of children of an entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CountCollisions>
<tr><td class=doctop colspan=2>Function CountCollisions:Int( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns how many collisions an entity was involved in during the last UpdateWorld.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Returns how many collisions an entity was involved in during the last UpdateWorld.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CountMipmaps>
<tr><td class=doctop colspan=2>Function CountMipmaps:Int( tex:TTexture )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the number of mipmaps a texture has.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CountSurfaces>
<tr><td class=doctop colspan=2>Function CountSurfaces:Int( mesh:TMesh )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the number of surfaces in a mesh.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
<b>Description</b>:
<p>
Returns the number of surfaces in a mesh.
<p>
Surfaces are sections of mesh.  A mesh may contain only one section, or very many.
<p>
See also: <a href=#GetSurface>GetSurface</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CountTriangles>
<tr><td class=doctop colspan=2>Function CountTriangles:Int( surf:TSurface )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the number of triangles in a surface.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
<b>Description</b>:
<p>
Returns the number of triangles in a surface.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CountVertices>
<tr><td class=doctop colspan=2>Function CountVertices:Int( surf:TSurface )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the number of vertices in a surface.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
<b>Description</b>:
<p>
Returns the number of vertices in a surface.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateBlob>
<tr><td class=doctop colspan=2>Function CreateBlob:TBlob( fluid:TFluid,radius:Float,parent_ent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create blob from a fluid mesh where radius is the size of the blob.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateBone>
<tr><td class=doctop colspan=2>Function CreateBone:TBone( mesh:TMesh,parent_ent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create bone.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateBrush>
<tr><td class=doctop colspan=2>Function CreateBrush:TBrush( r:Float=255,g:Float=255,b:Float=255 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a brush and returns a brush handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
red# (optional) - brush red value
<p>
green# (optional) - brush green value
<p>
blue# (optional) - brush blue value
<p>
<b>Description</b>:
<p>
Creates a brush and returns a brush handle.
<p>
The optional green, red and  blue values allow you to set the colour of the brush. Values should be in the  range 0-255. If omitted the values default to 255.
<p>
A brush is a collection of properties such as Colour, Alpha, Shininess, Texture  etc that are all stored as part of the brush. Then, all these properties can  be applied to an entity, mesh or surface at once just by using PaintEntity, PaintMesh  or PaintSurface.
<p>
When creating your own mesh, if you wish for certain surfaces to look differently  from one another, then you will need to use brushes to paint individual surfaces.  Using commands such as EntityColor, EntityAlpha will apply the effect to all  surfaces at once, which may not be what you wish to achieve.
<p>
See also: <a href=#LoadBrush>LoadBrush</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateCamera>
<tr><td class=doctop colspan=2>Function CreateCamera:TCamera( parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a camera entity and returns its handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
parent (optional) - parent entity of camera
<p>
<b>Description</b>:
<p>
Creates a camera entity and returns its handle.
<p>
Without  at least one camera, you won't be able to see anything in your 3D world. With more than one camera, you will be to achieve effect such as  split-screen modes and rear-view mirrors.
<p>
A camera can only render to the backbuffer. If you wish to display 3D  graphics on an image or a texture then copy the contents of the backbuffer  to the appropriate buffer.
<p>
The optional parent parameter allow you to specify a parent entity for  the camera so that when the parent is moved the child camera will move with  it. However, this relationship is one way; applying movement commands to the  child will not affect the parent.
<p>
Specifying a parent entity will still result in the camera being created  at position 0,0,0 rather than at the parent entity's position.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateCone>
<tr><td class=doctop colspan=2>Function CreateCone:TMesh( segments:Int=8,solid:Int=True,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a cone mesh/entity and returns its handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
segments (optional) - cone detail. Defaults to 8.
<p>
solid (optional) - true for a cone with a base, false for a cone without a base.  Defaults to true.
<p>
parent (optional) - parent entity of cone
<p>
<b>Description</b>:
<p>
Creates a cone mesh/entity and returns its handle.
<p>
The cone will be centred  at 0,0,0 and the base of the cone will have a radius of 1.
<p>
The segments value must be in the range 3-100 inclusive, although this is  only checked in debug mode. A common mistake is to leave debug mode off and  specify the parent parameter (usually an eight digit memory address) in the  place of the segments value. As the amount of polygons used to create a cone  is exponentially proportional to the segments value, this will result in Blitz  trying to create a cone with unimaginable amounts of polygons! Depending on  how unlucky you are, your computer will then crash.
<p>
Example segments values (solid=true):
4: 6 polygons - a pyramid
8: 14 polygons - bare minimum amount of polygons for a cone
16: 30 polygons - smooth cone at medium-high distances
32: 62 polygons - smooth cone at close distances
<p>
The optional parent parameter allow you to specify a parent entity for the  cone so that when the parent is moved the child cone will move with it. However,  this relationship is one way; applying movement commands to the child will not  affect the parent.
<p>
Specifying a parent entity will still result in the cone being created at  position 0,0,0 rather than at the parent entity's position.
<p>
See also: <a href=#CreateCube>CreateCube</a>, <a href=#CreateSphere>CreateSphere</a>, <a href=#CreateCylinder>CreateCylinder</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateConstraint>
<tr><td class=doctop colspan=2>Function CreateConstraint:TConstraint( p1:TEntity,p2:TEntity,l:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create constraint force between two entities of given length, doesn't affect rotation.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateCube>
<tr><td class=doctop colspan=2>Function CreateCube:TMesh( parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a cube mesh/entity and returns its handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
[parent] (optional) - This allows you to set the parent entity of Cube.
<p>
<b>Description</b>:
<p>
Creates a cube mesh/entity and returns its handle.
<p>
The cube will extend from  -1,-1,-1 to +1,+1,+1.
<p>
The optional parent parameter allow you to specify a parent entity for  the cube so that when the parent is moved the child cube will move with it.  However, this relationship is one way; applying movement commands to the  child will not affect the parent.
<p>
Specifying a parent entity will still result in the cube being created at  position 0,0,0 rather than at the parent entity's position.
<p>
Creation of cubes, cylinders and cones are a great way of getting scenes set up quickly, as they can act as placeholders for more complex pre-modeled meshes later on in program development.
<p>
See also: <a href=#CreateSphere>CreateSphere</a>, <a href=#CreateCylinder>CreateCylinder</a>, <a href=#CreateCone>CreateCone</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateCylinder>
<tr><td class=doctop colspan=2>Function CreateCylinder:TMesh( segments:Int=8,solid:Int=True,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a cylinder mesh/entity and returns its handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
segments (optional) - cylinder detail. Defaults to 8.
<p>
solid (optional) - true for a cylinder, false for a tube. Defaults to true.
<p>
parent (optional) - parent entity of cylinder
<p>
<b>Description</b>:
<p>
Creates a cylinder mesh/entity and returns its handle.
<p>
The cylinder will  be centred at 0,0,0 and will have a radius of 1.
<p>
The segments value must be in the range 3-100 inclusive, although this is  only checked in debug mode. A common mistake is to leave debug mode off and  specify the parent parameter (usually an eight digit memory address) in the  place of the segments value. As the amount of polygons used to create a cylinder  is exponentially proportional to the segments value, this will result in Blitz  trying to create a cylinder with unimaginable amounts of polygons! Depending  on how unlucky you are, your computer may then crash.
<p>
Example segments values (solid=true):
3: 8 polygons - a prism
8: 28 polygons - bare minimum amount of polygons for a cylinder
16: 60 polygons - smooth cylinder at medium-high distances
32: 124 polygons - smooth cylinder at close distances
<p>
The optional parent parameter allow you to specify a parent entity for the  cylinder so that when the parent is moved the child cylinder will move with  it. However, this relationship is one way; applying movement commands to the  child will not affect the parent.
<p>
Specifying a parent entity will still result in the cylinder being created  at position 0,0,0 rather than at the parent entity's position.
<p>
See also: <a href=#CreateCube>CreateCube</a>, <a href=#CreateSphere>CreateSphere</a>, <a href=#CreateCone>CreateCone</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateFluid>
<tr><td class=doctop colspan=2>Function CreateFluid:TFluid()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create fluid mesh for blobs to use.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateFragShader>
<tr><td class=doctop colspan=2>Function CreateFragShader:TShaderObject( shader:TShader,shaderFileName:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a new frag shader object from file.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateFragShaderString>
<tr><td class=doctop colspan=2>Function CreateFragShaderString:TShaderObject( shader:TShader,shadercode:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a new frag shader object from string.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateGeosphere>
<tr><td class=doctop colspan=2>Function CreateGeosphere:TGeosphere( size:Int,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create geodesic sphere and set terrain size.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateLight>
<tr><td class=doctop colspan=2>Function CreateLight:TLight( light_type:Int=1,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a light.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
type (optional) - type of light
<p>
1: directional (default)
<p>
2: point
<p>
3: spot
<p>

parent (optional) - parent entity of light
<p>
<b>Description</b>:
<p>
Creates a light.
<p>
Lights work by affecting the colour of all vertices within  the light's range. You need at to create at least one light if you wish to use 3D graphics otherwise everything will appear flat.
<p>
The optional type parameter allows you to specify the type of light you wish to create. A value of 1 creates a directional light. This works similar to a  sun shining on a house. All walls facing a certain direction are lit the same.  How much they are lit by depends on the angle of the light reaching them.  Directional lights have infinite 'position' and infinite range.
<p>
A value of 2 creates a point (or omni) light. This works a little bit like a light bulb  in a house, starting from a central point and gradually fading outwards.
<p>
A value of 3 creates a spot light. This is a cone of light. This works similar  to shining a torch in a house. It starts with an inner angle of light, and then  extends towards an outer angle of light.  You can adjust the angles of a 'spot' light with the LightConeAngles command.
<p>
The optional parent parameter allow you to specify a parent entity for the  light so that when the parent is moved the child light will move with it. However,  this relationship is one way; applying movement commands to the child will not affect the parent.
<p>
Specifying a parent entity will still result in the light being created at  position 0,0,0 rather than at the parent entity's position.
<p>

Other notes:
There is a DirectX limit on the number of lights available per scene - this is either 8 or 16 depending on your video card, but you should always assume 8.
<p>
Also, you should remember that each light added effects the rendering speed.
<p>
Lights do not cast shadows, like they do in real life.
<p>
Most games get around these issues by the use of a pre-calculated 'baked' lightmap texture for the static geometry in the scene.
<p>
Other lighting techniques include: adjusting vertex colors, dynamic shadows, and/or dynamic lights (ie. moving the lights around in the scene as they are needed).
<p>
See also: <a href=#LightRange>LightRange</a>, <a href=#LightColor>LightColor</a>, <a href=#LightConeAngles>LightConeAngles</a>, <a href=#AmbientLight>AmbientLight</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateMesh>
<tr><td class=doctop colspan=2>Function CreateMesh:TMesh( parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a 'blank' mesh entity and returns its handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
parent (optional) - This optional parameter allows you to specify another entity which will act as the parent to this mesh.
<p>
<b>Description</b>:
<p>
Create a 'blank' mesh entity and returns its handle.
<p>
When a mesh is first created it has no surfaces, vertices or triangles associated with it.
<p>
To add geometry to this mesh, you will need to:
<p>
CreateSurface() ; To make a surface
AddVertex ; You will need to add at least 3 to make a Triangle
AddTriangle ; This will add a triangle by connecting the Vertices (points) you added to the mesh.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateOcTree>
<tr><td class=doctop colspan=2>Function CreateOcTree:TOcTree( w:Float,h:Float,d:Float,parent_ent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create octree and set its width, height and depth.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateParticleEmitter>
<tr><td class=doctop colspan=2>Function CreateParticleEmitter:TParticleEmitter( particle:TEntity,parent_ent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create particle emitter and set sprite for it to use.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreatePivot>
<tr><td class=doctop colspan=2>Function CreatePivot:TPivot( parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a pivot entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
parent (optional) - parent entity of pivot
<p>
<b>Description</b>:
<p>
Creates a pivot entity.
<p>
A pivot entity is an invisible  point in 3D space that's main use is to act as a parent entity to other entities.  The pivot can then be used to control lots of entities at once, or act as new  centre of rotation for other entities.
<p>
To enforce this relationship; use EntityParent  or make use of the optional parent entity parameter available with all entity  load/creation commands.
<p>
Indeed, this parameter is also available with the CreatePivot command if  you wish for the pivot to have a parent entity itself.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreatePlane>
<tr><td class=doctop colspan=2>Function CreatePlane:TMesh( divisions:Int=1,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a plane entity and returns its handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
sub_divs (optional) - sub divisions of plane. Should be in the range 1-16.  The default value is 1.
<p>
parent (optional) - parent entity of plane
<p>
<b>Description</b>:
<p>
Creates a plane entity and returns its handle.
<p>
A plane entity is basically  a flat, infinite 'ground'. It is useful for outdoor games where you never want  the player to see/reach the edge of the game world.
<p>
The optional sub_divs parameter determines how many sub divisions of polygons  the plane will have. Although a plane is flat and so adding extra polygons will  not make it smoother, adding more polygons will allow more vertices to be lit  for more detailed lighting effects.
<p>
The optional parent parameter allows you to specify a parent  entity for the plane so that when the parent is moved the child plane will move  with it. However, this relationship is one way; applying movement commands to  the child will not affect the parent.
<p>
Specifying a parent entity will still result in the plane being created at  position 0,0,0 rather than at the parent entity's position.
<p>
See also: <a href=#CreateMirror>CreateMirror</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreatePostFX>
<tr><td class=doctop colspan=2>Function CreatePostFX:TPostFX( cam:TCamera,passes:Int=1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>undocumented.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateQuad>
<tr><td class=doctop colspan=2>Function CreateQuad:TMesh( parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create flat quad.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateRigidBody>
<tr><td class=doctop colspan=2>Function CreateRigidBody:TRigidBody( body:TEntity,p1:TEntity,p2:TEntity,p3:TEntity,p4:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create rigid physics body attached to four entities.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateShader>
<tr><td class=doctop colspan=2>Function CreateShader:TShader( ShaderName:String,VshaderString:String,FshaderString:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Load shader from two strings, vertex and fragment.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateShaderMaterial>
<tr><td class=doctop colspan=2>Function CreateShaderMaterial:TShader( ShaderName:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a new shader material without creating any shader objects.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateShaderVGF>
<tr><td class=doctop colspan=2>Function CreateShaderVGF:TShader( ShaderName:String,VshaderString:String,GshaderString:String,FshaderString:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Load shader from three strings, vertex, geometry and fragment.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateShadow>
<tr><td class=doctop colspan=2>Function CreateShadow:TShadowObject( parent:TMesh,Static:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create stencil shadow, static is for static or dynamic shadows.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateSphere>
<tr><td class=doctop colspan=2>Function CreateSphere:TMesh( segments:Int=8,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a sphere mesh/entity and returns its handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
segments (optional) - sphere detail. Defaults to 8.
<p>
parent (optional) - parent entity of sphere
<p>
<b>Description</b>:
<p>
Creates a sphere mesh/entity and returns its handle.
<p>
The sphere will  be centred  at 0,0,0 and will have a radius of 1.
<p>
The segments value must be in the range 2-100 inclusive, although this is  only checked in debug mode. A common mistake  is to leave debug mode off and specify the parent parameter  (usually an eight digit memory address) in the place of the segments value.  As the amount of polygons used to create a sphere is exponentially  proportional to the segments value, this will result in Blitz trying to create a sphere  with unimaginable amounts of polygons! Depending on how unlucky you are,  your computer will then crash.
<p>
Example segments values:
8: 224 polygons - bare minimum amount of polygons for a sphere
16: 960 polygons - smooth looking sphere at medium-high distances
32: 3968 polygons - smooth sphere at close distances
<p>
The  optional parent parameter allow you to specify a parent entity for the  sphere so that when the parent is moved the child sphere will move with it.  However, this relationship is one way; applying movement commands to the  child will not affect the parent.
<p>
Specifying a parent entity will still result in the sphere being created  at position 0,0,0 rather than at the parent entity's position.
<p>
See also: <a href=#CreateCube>CreateCube</a>, <a href=#CreateCylinder>CreateCylinder</a>, <a href=#CreateCone>CreateCone</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateSprite>
<tr><td class=doctop colspan=2>Function CreateSprite:TSprite( parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a sprite entity and returns its handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
parent (optional) - parent entity of sprite
<p>
<b>Description</b>:
<p>
Creates a sprite entity and returns its handle.  Sprites are simple flat (usually textured) rectangles made from two triangles.  Unlike other entity objects they don't actually have a mesh that can be manipulated.
<p>
The sprite will be positioned  at 0,0,0 and extend from 1,-1 to +1,+1.
<p>
Sprites have two real strengths. The first is that they consist of only two  polygons; meaning you can use many of them at once. This makes them ideal for  particle effects and 2D-using-3D games where you want lots of sprites on-screen  at once.
<p>
Secondly, sprites can be assigned a view mode using SpriteViewMode. By default this view mode is  set to 1, which means the sprite will always face the camera. So no matter what  the orientation of the camera is relative to the sprite, you will never actually  notice that they are flat; by giving them a spherical texture, you can make  them appear to look no different than a normal sphere.
<p>
The optional parent parameter allow you to specify a parent entity for the  sprite so that when the parent is moved the child sprite will move with it.  However, this relationship is one way; applying movement commands to the child  will not affect the parent.
<p>
Specifying a parent entity will still result in the sprite being created  at position 0,0,0 rather than at the parent entity's position.
<p>
Note:  Sprites have their own commands for rotation and scaling.
<p>
See also: <a href=#LoadSprite>LoadSprite</a>, <a href=#RotateSprite>RotateSprite</a>, <a href=#ScaleSprite>ScaleSprite</a>, <a href=#HandleSprite>HandleSprite</a>, <a href=#SpriteViewMode>SpriteViewMode</a>, <a href=#PositionEntity>PositionEntity</a>, <a href=#MoveEntity>MoveEntity</a>, <a href=#TranslateEntity>TranslateEntity</a>, <a href=#EntityAlpha>EntityAlpha</a>, <a href=#FreeEntity>FreeEntity</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateStencil>
<tr><td class=doctop colspan=2>Function CreateStencil:TStencil()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create stencil object.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateSurface>
<tr><td class=doctop colspan=2>Function CreateSurface:TSurface( mesh:TMesh,brush:TBrush=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a surface attached to a mesh and returns the surface's handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
brush (optional) - brush handle
<p>
<b>Description</b>:
<p>
Creates a surface attached to a mesh and returns the surface's handle.
<p>
Surfaces are sections of mesh which are then used to attach triangles to. You  must have at least one surface per mesh in order to create a visible mesh, however  you can use as many as you like. Splitting a mesh up into lots of sections allows  you to affect those sections individually, which can be a lot more useful than  if all the surfaces are combined into just one.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateTerrain>
<tr><td class=doctop colspan=2>Function CreateTerrain:TTerrain( size:Int,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a terrain entity and returns its handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
grid_size - no of grid squares along each side of terrain, and must be a  power of 2 value, e.g. 32, 64, 128, 256, 512, 1024.
<p>
parent (optional) - parent entity of terrain
<p>
<b>Description</b>:
<p>
Creates a terrain entity and returns its handle.
<p>
The terrain  extends from 0,0,0 to grid_size,1,grid_size.
<p>
A terrain is a special type of polygon object that uses real-time level of  detail (LOD) to display landscapes which should theoretically consist of over  a million polygons with only a few thousand. The way it does this is by constantly  rearranging a certain amount of polygons to display high levels of detail close  to the viewer and low levels further away.
<p>
This constant rearrangement of polygons is occasionally noticeable however,  and is a well-known side-effect of all LOD landscapes. This 'pop-in' effect  can be reduced in lots of ways though, as the other terrain help files will  go on to explain.
<p>
The optional parent parameter allows you to specify a parent entity for the  terrain so that when the parent is moved the child terrain will move with it.  However, this relationship is one way; applying movement commands to the child  will not affect the parent.
<p>
Specifying a parent entity will still result in the terrain being created  at position 0,0,0 rather than at the parent entity's position.
<p>
See also: <a href=#LoadTerrain>LoadTerrain</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateTexture>
<tr><td class=doctop colspan=2>Function CreateTexture:TTexture( width:Int,height:Int,flags:Int=9,frames:Int=1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a texture and returns its handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
width - width of texture
<p>
height - height of texture
<p>

flags (optional) - texture flag:
<p>
1: Color (default)
<p>
2: Alpha
<p>
4: Masked
<p>
8: Mipmapped
<p>
16: Clamp U
<p>
32: Clamp V
<p>
64: Spherical environment map
<p>
128: Cubic environment map
<p>
256: Store texture in vram
<p>
512: Force the use of high color textures
<p>

frames (optional) - no of frames texture will have. Defaults to 1.
<p>
<b>Description</b>:
<p>
Creates a texture and returns its handle.
<p>
Width and height are the size  of the texture. Note that the actual texture size may be different from the  width and height requested, as different types of 3D hardware support different  sizes of texture.
<p>
The optional flags parameter allows you to apply certain effects to the texture.  Flags can be added to combine two or more effects, e.g. 3 (1+2) = texture with  color and alpha maps.
<p>
Here some more detailed descriptions of the flags:
<p>
1: Color - colour map, what you see is what you get.
<p>
2: Alpha - alpha map. If an image contains an alpha map, this will be used to  make certain areas of the texture transparent. Otherwise, the colour map will  be used as an alpha map. With alpha maps, the dark areas always equal high-transparency,  light areas equal low-transparency.
<p>
4: Masked - all areas of a texture coloured 0,0,0 will not be drawn to the screen.
<p>
8: Mipmapped - low detail versions of the texture will be used at high distance.  Results in a smooth, blurred look.
<p>
16: Clamp u - Any part of a texture that lies outsides the U coordinates of 0-1 will not be drawn. Prevents texture-wrapping.
<p>
32: Clamp v - Any part of a texture that lies outsides the v coordinates of 0-1 will not be drawn. Prevents texture-wrapping.
<p>
64: Spherical environment map - a form of environment mapping. This works by taking a single image, and then applying it to a 3D mesh in such a way that the image appears to be reflected. When used with a texture that contains light sources, it can give some meshes such as a teapot a shiny appearance.
<p>
128: Cubic environment map - a form of environment mapping. Cube mapping is similar to spherical mapping, except it uses six images each representing a particular 'face' of an imaginary cube, to give the appearance of an image that perfectly reflects its surroundings.
<p>
When creating cubic environment maps with the CreateTexture command, cubemap textures *must* be square 'power of 2' sizes. See the <a href=#SetCubeFace>SetCubeFace</a> command for information on how to then draw to the cubemap.
<p>
When loading cubic environments maps into Blitz using LoadTexture, all six images relating to the six faces of the cube must be contained within the one texture, and be laid out in a horizontal strip in the following order - left, forward, right, backward, up, down. The images comprising the cubemap must all be power of two sizes.
<p>
Please note that not some older graphics cards do not support cubic mapping. In order to find out if a user's graphics card can support it, use <a href=#GfxDriverCaps3D>GfxDriverCaps3D</a> .
<p>
256: Store texture in vram. In some circumstances, this makes for much faster dynamic textures - ie. when using CopyRect between two textures. When drawing to cube maps in real-time, it is preferable to use this flag.
<p>
512: Force the use of high color textures in low bit depth graphics modes. This is useful for when you are in 16-bit color mode, and wish to create/load textures with the alpha flag - it should give better results.
<p>
Once you have created a texture, use SetBuffer TextureBuffer to draw to it. However, to display 2D graphics on a texture, it is usually quicker to draw to an image and then copy it to the texturebuffer, and to display 3D graphics on a texture, your only option is to copy from the backbuffer to the texturebuffer.
<p>
See also: <a href=#LoadTexture>LoadTexture</a>, <a href=#LoadAnimTexture>LoadAnimTexture</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateVertShader>
<tr><td class=doctop colspan=2>Function CreateVertShader:TShaderObject( shader:TShader,shaderFileName:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a new vert shader object from file.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateVertShaderString>
<tr><td class=doctop colspan=2>Function CreateVertShaderString:TShaderObject( shader:TShader,shadercode:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a new vert shader object from string.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateVoxelSprite>
<tr><td class=doctop colspan=2>Function CreateVoxelSprite:TVoxelSprite( slices:Int=64,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create voxel sprite where slices is the number of sprites.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=DeleteFragShader>
<tr><td class=doctop colspan=2>Function DeleteFragShader( myShader:TShaderObject )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Deletes a frag shader object from a program object.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=DeleteVertShader>
<tr><td class=doctop colspan=2>Function DeleteVertShader( myShader:TShaderObject )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Deletes a vert shader object from a program object.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=DeltaPitch>
<tr><td class=doctop colspan=2>Function DeltaPitch:Float( ent1:TEntity,ent2:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the pitch angle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
src_entity - source entity handle
<p>
dest_entity - destination entity handle
<p>
<b>Description</b>:
<p>
Returns the pitch angle, that src_entity should be rotated by in order to face dest_entity.
<p>
This command can be used to be point one entity at another, rotating on the x axis only.
<p>
See also: <a href=#DeltaYaw>DeltaYaw</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=DeltaYaw>
<tr><td class=doctop colspan=2>Function DeltaYaw:Float( ent1:TEntity,ent2:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the yaw angle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
src_entity - source entity handle
<p>
dest_entity - destination entity handle
<p>
<b>Description</b>:
<p>
Returns the yaw angle, that src_entity should be rotated by in order to face dest_entity.
<p>
This command can be used to be point one entity at another, rotating on the y axis only.
<p>
See also: <a href=#DeltaPitch>DeltaPitch</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=DepthBufferToTex>
<tr><td class=doctop colspan=2>Function DepthBufferToTex( tex:TTexture,cam:TCamera=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy the contents of the depth buffer to a texture.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EmitterParticleAlpha>
<tr><td class=doctop colspan=2>Function EmitterParticleAlpha( emit:TParticleEmitter,starta:Float,enda:Float,mida:Float=0,midlife:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set particles alpha at start and end, range is 0..1.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EmitterParticleColor>
<tr><td class=doctop colspan=2>Function EmitterParticleColor( emit:TParticleEmitter,startr:Float,startg:Float,startb:Float,endr:Float,endg:Float,endb:Float,midr:Float=255,midg:Float=255,midb:Float=255,midlife:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set particles RGB color at start and end, default is 255,255,255.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EmitterParticleFunction>
<tr><td class=doctop colspan=2>Function EmitterParticleFunction( emit:TParticleEmitter,EmitterFunction( ent:Byte Ptr,life:Int ) )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Points to callback function for emitter.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This gives access to each particle and also current life left.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EmitterParticleLife>
<tr><td class=doctop colspan=2>Function EmitterParticleLife( emit:TParticleEmitter,startl:Int,endl:Int,randl:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set particles start, end and random lifespan.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>startl sets when a particle becomes visible, endl is full life and randl is the random range.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EmitterParticleRotate>
<tr><td class=doctop colspan=2>Function EmitterParticleRotate( emit:TParticleEmitter,startr:Float,endr:Float,midr:Float=0,midlife:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set particles rotation angle at start and end.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Minus values will rotate clockwise.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EmitterParticleScale>
<tr><td class=doctop colspan=2>Function EmitterParticleScale( emit:TParticleEmitter,startx:Float,starty:Float,endx:Float,endy:Float,midsx:Float=1,midsy:Float=1,midlife:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set particles scale at start and end, default is 1.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EmitterParticleSpeed>
<tr><td class=doctop colspan=2>Function EmitterParticleSpeed( emit:TParticleEmitter,starts:Float,ends:Float=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set particles start and end speed.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Minus end values can be used to slow particles down.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EmitterRate>
<tr><td class=doctop colspan=2>Function EmitterRate( emit:TParticleEmitter,r:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rate between each emission, range is 0.01..1.01.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This is a way to slow particle emissions down. A rate of 1.01 is full rate.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EmitterVariance>
<tr><td class=doctop colspan=2>Function EmitterVariance( emit:TParticleEmitter,v:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set random variance of particles, range is 0.001..0.1.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Variance will be increasing chaotic above 0.1.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EmitterVector>
<tr><td class=doctop colspan=2>Function EmitterVector( emit:TParticleEmitter,startx:Float,starty:Float,startz:Float,endx:Float,endy:Float,endz:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set emitters start and end 3d vectors.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Vectors are affected by speed. Minus end values can be used to slow particles.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EndAction>
<tr><td class=doctop colspan=2>Function EndAction( act:TAction )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Ends action so it can be freed, 1 = automatically ended, 2 = manually ended.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EndMax2D>
<tr><td class=doctop colspan=2>Function EndMax2D( version:Int=1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Old end function as in Minib3d is 0, new end function is 1 (default)</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityAlpha>
<tr><td class=doctop colspan=2>Function EntityAlpha( ent:TEntity,alpha:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the entity alpha level of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
Entity - entity handle
<p>
Alpha# - alpha level of entity
<p>
<b>Description</b>:
<p>
Sets the entity alpha level of an entity.
<p>
The alpha# value should be in a floating point value in the range 0-1. The default entity alpha setting is 1.
<p>
The alpha level is how transparent an entity is. A value of 1 will mean the entity is opaque. A value of 0 will mean the entity is completely transparent, i.e. invisible. Values between 0 and 1 will cause varying amount of transparency. This is useful for imitating the look of objects such as glass and other translucent materials.
<p>
An EntityAlpha value of 0 is especially useful as Blitz3D will not render entities with such a value, but will still involve the entities in collision tests. This is unlike HideEntity, which doesn't involve entities in collisions.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityBlend>
<tr><td class=doctop colspan=2>Function EntityBlend( ent:TEntity,blend:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the blending mode of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
Entity - Entity handle
<p>

Blend - Blend mode of the entity.
<p>
1: Alpha (default)
<p>
2: Multiply
<p>
3: Add
<p>
<b>Description</b>:
<p>
Sets the blending mode of an entity. This blending mode determines the way in which the new RGBA of the pixel being rendered is combined with the RGB of the background.
<p>
To calculate the new RGBA of the pixel being rendered, the texture RGBA for the pixel (see <a href=#TextureBlend>TextureBlend</a> for more information on how the texture RGBA is calculated) is taken, its alpha component multiplied by the entities/brushes (where applicable) alpha value and its color compentent multiplied by the entities/brushes colour. This is the RGBA which will then be blended into the background pixel, and how this is done depends on the EntityBlend value.
<p>
Alpha:
This blends the pixels according to the Alpha value. This is rougly done to the formula:
<p>
Rr = ( An * Rn ) + ( ( 1.0 - An ) * Ro )
Gr = ( An * Gn ) + ( ( 1.0 - An ) * Go )
Br = ( An * Bn ) + ( ( 1.0 - An ) * Bo )
<p>
Where R = Red, G = Green, B = Blue, n = new pixel colour values, r = resultant colour values, o = old pixel colour values.
<p>
Alpha blending is the default blending mode and is used with most world objects.
<p>
Multiply:
This blend mode will darken the underlying pixels. If you think of each RGB value as being on a scale from 0% to 100%, where 0 = 0% and 255 = 100%, the multiply blend mode will multiply the red, green and blue values individually together in order to get the new RGB value, roughly according to:
<p>
Rr = ( ( Rn / 255.0 ) * ( Ro / 255.0 ) ) * 255.0
Gr = ( ( Gn / 255.0 ) * ( Go / 255.0 ) ) * 255.0
Br = ( ( Bn / 255.0 ) * ( Bo / 255.0 ) ) * 255.0
<p>
The alpha value has no effect with multiplicative blending. Blending a RGB value of 255, 255, 255 will make no difference, while an RGB value of 128, 128, 128 will darken the pixels by a factor of 2 and an RGB value of 0, 0, 0 will completely blacken out the resultant pixels. An RGB value of 0, 255, 255 will remove the red component of the underlying pixel while leaving the other color values
untouched.
<p>
Multiply blending is most often used for lightmaps, shadows or anything else that needs to 'darken' the resultant pixels.
<p>
Add:
Additive blending will add the new color values to the old, roughly according to:
<p>
Rr = ( Rn * An ) + Ro
Gr = ( Gn * An ) + Go
Br = ( Bn * An ) + Bo
<p>
The resultant RGB values are clipped out at 255, meaning that multiple additive effects can quickly cause visible banding from smooth gradients.
<p>
Additive blending is extremely useful for effects such as laser shots and fire.
<p>
See also: <a href=#TextureBlend>TextureBlend</a>, <a href=#EntityAlpha>EntityAlpha</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityBox>
<tr><td class=doctop colspan=2>Function EntityBox( ent:TEntity,x:Float,y:Float,z:Float,w:Float,h:Float,d:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the dimensions of an entity's collision box.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle#
<p>
x# - x position of entity's collision box
<p>
y# - y position of entity's collision box
<p>
z# - z position of entity's collision box
<p>
width# - width of entity's collision box
<p>
height# - height of entity's collision box
<p>
depth# - depth of entity's collision box
<p>
<b>Description</b>:
<p>
Sets the dimensions of an entity's collision box.
<p>
See also: <a href=#EntityRadius>EntityRadius</a>, <a href=#Collisions>Collisions</a>, <a href=#EntityType>EntityType</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityClass>
<tr><td class=doctop colspan=2>Function EntityClass:String( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a string containing the class of the specified entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - a valid entity handle
<p>
<b>Description</b>:
<p>
Returns a string containing the class of the specified entity.
<p>
Possible return values are:
<p>
Pivot
Light
Camera
Mirror
Listener
Sprite
Terrain
Plane
Mesh
MD2
BSP
<p>
Note that the command will fail if a valid entity handle is not supplied, and will not just return an empty string.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityCollided>
<tr><td class=doctop colspan=2>Function EntityCollided:TEntity( ent:TEntity,type_no:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the handle of the entity of the specified type that collided with  the specified entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
type - type of entity
<p>
<b>Description</b>:
<p>
Returns the handle of the entity of the specified type that collided with  the specified entity.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityColor>
<tr><td class=doctop colspan=2>Function EntityColor( ent:TEntity,red:Float,green:Float,blue:Float,recursive:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the color of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
Red# - red value of entity
<p>
Green# - green value of entity
<p>
Blue# - blue value of entity
<p>
<b>Description</b>:
<p>
Sets the color of an entity.
<p>
The Red, Green and Blue values should be in the range 0-255 with 0 being darkest and 255 brightest. The default entity color is 255,255,255 (White).</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityDistance>
<tr><td class=doctop colspan=2>Function EntityDistance:Float( ent1:TEntity,ent2:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the distance between src_entity and dest_entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
src_entity - source entity handle
<p>
dest_entity - destination entity handle
<p>
<b>Description</b>:
<p>
Returns the distance between src_entity and dest_entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityFX>
<tr><td class=doctop colspan=2>Function EntityFX( ent:TEntity,fx:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets miscellaneous effects for an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>

fx -
<p>
0: nothing (default)
<p>
1: full-bright
<p>
2: use vertex colors instead of brush color
<p>
4: flatshaded
<p>
8: disable fog
<p>
16: disable backface culling
<p>
32: force alpha-blending
<p>
<b>Description</b>:
<p>
Sets miscellaneous effects for an entity.
<p>
Flags can be added to combine  two or more effects. For example, specifying a flag of 3 (1+2) will result in  a full-bright and vertex-coloured brush.
<p>
Flag 32, to force alpha-blending, must be used in order to enable vertex alpha (see VertexColor).
<p>
See also: <a href=#VertexColor>VertexColor</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityInView>
<tr><td class=doctop colspan=2>Function EntityInView:Int( ent:TEntity,cam:TCamera )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns true if the specified entity is visible to the specified camera.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
camera - camera handle
<p>
<b>Description</b>:
<p>
Returns true if the specified entity is visible to the specified camera.
<p>
If the entity is a mesh, its bounding box will be checked for visibility.
<p>
For all other types of entities, only their centre position will be checked.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityMatrix>
<tr><td class=doctop colspan=2>Function EntityMatrix:Float Ptr( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>undocumented.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityName>
<tr><td class=doctop colspan=2>Function EntityName:String( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the name of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Returns the name of an entity. An entity's name may be set in a modelling  program, or manually set using NameEntity.
<p>
See also: <a href=#NameEntity>NameEntity</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityOrder>
<tr><td class=doctop colspan=2>Function EntityOrder( ent:TEntity,order:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the drawing order for an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
order - order that entity will be drawn in
<p>
<b>Description</b>:
<p>
Sets the drawing order for an entity.
<p>
An order value of 0 will mean the  entity is drawn normally. A value greater than 0 will mean that entity is drawn  first, behind everything else. A value less than 0 will mean the entity is drawn  last, in front of everything else.
<p>
Setting an entity's order to non-0 also disables z-buffering for the entity,  so should be only used for simple, convex entities like skyboxes, sprites etc.
<p>
EntityOrder affects the specified entity but none of its child entities,  if any exist.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityParent>
<tr><td class=doctop colspan=2>Function EntityParent( ent:TEntity,parent_ent:TEntity,glob:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Attaches an entity to a parent.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
parent - parent entity handle
<p>
global (optional) - true for the child entity to retain its global position  and orientation. Defaults to true.
<p>
<b>Description</b>:
<p>
Attaches an entity to a parent.
<p>
Parent may be 0, in which case the entity  will have no parent.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityPick>
<tr><td class=doctop colspan=2>Function EntityPick:TEntity( ent:TEntity,Range:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the nearest entity 'ahead' of the specified entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
range# - range of pick area around entity
<p>
<b>Description</b>:
<p>
Returns the nearest entity 'ahead' of the specified entity. An entity must  have a non-zero EntityPickMode to be pickable.
<p>
See also: <a href=#EntityPick>EntityPick</a>, <a href=#LinePick>LinePick</a>, <a href=#CameraPick>CameraPick</a>, <a href=#EntityPickMode>EntityPickMode</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityPickMode>
<tr><td class=doctop colspan=2>Function EntityPickMode( ent:TEntity,pick_mode:Int,obscurer:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the pick mode for an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>

pick_geometry - type of geometry used for picking:
<p>
0: Unpickable (default)
<p>
1: Sphere (EntityRadius is used)
<p>
2: Polygon
<p>
3: Box (EntityBox is used)
<p>

obscurer (optional) - True to determine that the entity 'obscures' other entities  during an EntityVisible call. Defaults to True.
<p>
<b>Description</b>:
<p>
Sets the pick mode for an entity.
<p>
The optional obscurer parameter is used  with EntityVisible to determine just what can  get in the way of the line-of-sight between 2 entities. This allows some entities  to be pickable using the other pick commands, but to be ignored (i.e. 'transparent')  when using EntityVisible. So, its very much EntityVisible specific.
<p>
Please note that only Sphere and Box picking will work with Blitz3D sprites. For polygon picking, you will need a valid mesh.
<p>
See also: <a href=#EntityPick>EntityPick</a>, <a href=#LinePick>LinePick</a>, <a href=#CameraPick>CameraPick</a>, <a href=#EntityPickMode>EntityPickMode</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityPitch>
<tr><td class=doctop colspan=2>Function EntityPitch:Float( ent:TEntity,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the pitch angle of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - name of entity that will have pitch angle returned
<p>
global (optional) - true if the pitch angle returned should be relative to 0 rather than a parent entity's pitch angle. False by default.
<p>
<b>Description</b>:
<p>
Returns the pitch angle of an entity.
<p>
The pitch angle is also the x angle of an entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityRadius>
<tr><td class=doctop colspan=2>Function EntityRadius( ent:TEntity,radius_x:Float,radius_y:Float=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the radius of an entity's collision ellipsoid.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
x_radius# - x radius of entity's collision ellipsoid
<p>
y_radius# (optional) - y radius of entity's collision ellipsoid. If omitted the x_radius# will be used for the y_radius#.
<p>
<b>Description</b>:
<p>
Sets the radius of an entity's collision ellipsoid.
<p>
An entity radius should be set for all entities involved in ellipsoidal collisions, which is all source entities (as collisions are always ellipsoid-to-something), and  whatever destination entities are involved in ellipsoid-to-ellipsoid collisions (collision method No.1).
<p>
See also: <a href=#EntityBox>EntityBox</a>, <a href=#Collisions>Collisions</a>, <a href=#EntityType>EntityType</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityRoll>
<tr><td class=doctop colspan=2>Function EntityRoll:Float( ent:TEntity,glob:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the roll angle of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - name of entity that will have roll angle returned
<p>
global (optional) - true if the roll angle returned should be relative to 0 rather than a parent entity's  roll angle. False by default.
<p>
<b>Description</b>:
<p>
Returns the roll angle of an entity.
<p>
The roll angle is also the z angle of an entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityScaleX>
<tr><td class=doctop colspan=2>Function EntityScaleX:Float( ent:TEntity,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the scale for the x axis of an entity set with ScaleEntity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>If glob is true then it's relative to any parents.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityScaleY>
<tr><td class=doctop colspan=2>Function EntityScaleY:Float( ent:TEntity,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the scale for the y axis of an entity set with ScaleEntity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>If glob is true then it's relative to any parents.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityScaleZ>
<tr><td class=doctop colspan=2>Function EntityScaleZ:Float( ent:TEntity,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the scale for the z axis of an entity set with ScaleEntity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>If glob is true then it's relative to any parents.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityShininess>
<tr><td class=doctop colspan=2>Function EntityShininess( ent:TEntity,shine:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the specular shininess of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
Entity - entity handle
<p>
Shininess# - shininess of entity
<p>
<b>Description</b>:
<p>
Sets the specular shininess of an entity.
<p>
The shininess# value should be a floting point number in the range 0-1. The default shininess setting is 0.
<p>
Shininess is how much brighter certain areas of an object will appear to be when a light is shone directly at them.
<p>
Setting a shininess value of 1 for a medium to high poly sphere, combined  with the creation of a light shining in the direction of it, will give it the  appearance of a shiny snooker ball.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityTexture>
<tr><td class=doctop colspan=2>Function EntityTexture( ent:TEntity,tex:TTexture,frame:Int=0,index:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Applies a texture to an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
texture - texture handle
<p>
frame (optional) - frame of texture. Defaults to 0.
<p>
index (optional) - index number of texture. Should be in the range to 0-7. Defaults  to 0.
<p>
<b>Description</b>:
<p>
Applies a texture to an entity.
<p>
The optional frame parameter specifies  which texture animation frame should be used as the texture.
<p>
The optional index parameter specifies which index number should be assigned  to the texture. Index numbers are used for the purpose of multitexturing. See TextureBlend.
<p>
A little note about multitexturing and slowdown. Graphics cards support a  maximum amount of textures per object, which can be used with very little, if  any, slowdown. For most cards this is two, but for a GeForce3 it is four. However,  once you use more than this amount, Blitz will emulate the effect itself by  duplicating objects and textures. Obviously, this may then cause slowdown.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityType>
<tr><td class=doctop colspan=2>Function EntityType( ent:TEntity,type_no:Int,recursive:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the collision type for an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
collision_type - collision type of entity. Must be in the range 0-999.
<p>
recursive (optional) - true to apply collision type to entity's children. Defaults  to false.
<p>
<b>Description</b>:
<p>
Sets the collision type for an entity.
<p>
A collision_type value of 0 indicates that no collision checking will occur with that entity. A collision value of 1-999 will mean collision checking will occur.
<p>
See also: <a href=#Collisions>Collisions</a>, <a href=#GetEntityType>GetEntityType</a>, <a href=#EntityBox>EntityBox</a>, <a href=#EntityRadius>EntityRadius</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityVisible>
<tr><td class=doctop colspan=2>Function EntityVisible:Int( src_ent:TEntity,dest_ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns true if src_entity and dest_entity can 'see' each other.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
src_entity - source entity handle
<p>
dest_entity - destination entity handle
<p>
<b>Description</b>:
<p>
Returns true if src_entity and dest_entity can 'see' each other.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityX>
<tr><td class=doctop colspan=2>Function EntityX:Float( ent:TEntity,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The X-coordinate of the entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity = handle of Loaded or Created Entity
<p>
global = True for Global coordinates,  False for Local. Optional, defaults to False.
<p>
<b>Description</b>:
<p>
The X-coordinate of the entity.
If the global flag is set to False then the parent's local coordinate system is used.
<p>
NOTE: If the entity has no parent then local and global coordinates are the same.
In this case you can think of the 3d world as the parent.
<p>
Global coordinates refer to the 3d world. Blitz 3D uses a left-handed system:
<p>
X+ is to the right
Y+ is up
Z+ is forward ( into the screen )
<p>
Every entity also has its own Local coordinate system.
<p>
The global system never changes.
But the local system is carried along as an entity moves and turns.
<p>
This same concept is used in the entity movement commands:
<p>
MoveEntity entity, 0,0,1
<p>
No matter what the orientation this moves one unit forward.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityY>
<tr><td class=doctop colspan=2>Function EntityY:Float( ent:TEntity,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The Y-coordinate of the entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity = handle of Loaded or Created Entity
<p>
global = True for Global coordinates,  False for Local. Optional, defaults to False.
<p>
<b>Description</b>:
<p>
The Y-coordinate of the entity.
If the global flag is set to False then the parent's local coordinate system is used.
<p>
See EntityX() for an overview of Local and Global coordinates.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityYaw>
<tr><td class=doctop colspan=2>Function EntityYaw:Float( ent:TEntity,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the yaw angle of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - name of entity that will have yaw angle returned
<p>
global (optional) - true if the yaw angle returned should be relative to 0 rather than a parent entity's  yaw angle. False by default.
<p>
<b>Description</b>:
<p>
Returns the yaw angle of an entity.
<p>
The yaw angle is also the y angle of an entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityZ>
<tr><td class=doctop colspan=2>Function EntityZ:Float( ent:TEntity,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The Z-coordinate of the entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity = handle of Loaded or Created Entity
<p>
global = True for Global coordinates,  False for Local. Optional, defaults to False.
<p>
<b>Description</b>:
<p>
The Z-coordinate of the entity.
If the global flag is set to False then the parent's local coordinate system is used.
<p>
See EntityX() for an overview of Local and Global coordinates.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ExtractAnimSeq>
<tr><td class=doctop colspan=2>Function ExtractAnimSeq:Int( ent:TEntity,first_frame:Int,last_frame:Int,seq:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>This command allows you to convert an animation with an MD2-style series  of anim sequences into a pure Blitz anim sequence.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
first_frame - first frame of anim sequence to extract
<p>
last_frame - last frame of anim sequence to extract
<p>
anim_seq (optional) - anim sequence to extract from. This is usually 0, and  as such defaults to 0.
<p>
<b>Description</b>:
<p>
This command allows you to convert an animation with an MD2-style series  of anim sequences into a pure Blitz anim sequence, and play it back as such  using Animate.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FindChild>
<tr><td class=doctop colspan=2>Function FindChild:TEntity( ent:TEntity,child_name:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the first child of the specified entity with name matching child_name$</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
child_name$ - child name to find within entity
<p>
<b>Description</b>:
<p>
Returns the first child of the specified entity with name matching child_name$.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FindSurface>
<tr><td class=doctop colspan=2>Function FindSurface:TSurface( mesh:TMesh,brush:TBrush )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Attempts to find a surface attached to the specified mesh and created with  the specified brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
brush - brush handle
<p>
<b>Description</b>:
<p>
Attempts to find a surface attached to the specified mesh and created with  the specified brush. Returns the surface handle if found or 0 if not.
<p>
See  also: CountSurfaces, GetSurface.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FitMesh>
<tr><td class=doctop colspan=2>Function FitMesh( mesh:TMesh,x:Float,y:Float,z:Float,width:Float,height:Float,depth:Float,uniform:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Scales and translates all vertices of a mesh so that the mesh occupies the specified box.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
x# - x position of mesh
<p>
y# - y position of mesh
<p>
z# - z position of mesh
<p>
width# - width of mesh
<p>
height# - height of mesh
<p>
depth# - depth of mesh
<p>
uniform (optional) - if true, the mesh will be scaled by the same amounts in x, y and z, so will not be distorted. Defaults to false.
<p>
<b>Description</b>:
<p>
Scales and translates all vertices of a mesh so that the mesh occupies the specified box.
<p>
Do not use a width#, height# or depth# value of 0, otherwise all mesh data will be destroyed and your mesh will not be displayed. Use a value of 0.001 instead for a flat mesh along one axis.
<p>
See also: <a href=#ScaleMesh>ScaleMesh</a>, <a href=#ScaleEntity>ScaleEntity</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FlipMesh>
<tr><td class=doctop colspan=2>Function FlipMesh( mesh:TMesh )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Flips all the triangles in a mesh.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
<b>Description</b>:
<p>
Flips all the triangles in a mesh.
<p>
This is useful for a couple of reasons.  Firstly though, it is important to understand a little bit of the theory behind  3D graphics. A 3D triangle is represented by three points; only when these points  are presented to the viewer in a clockwise-fashion is the triangle visible.  So really, triangles only have one side.
<p>
Normally, for example in the case of a sphere, a model's triangles face the  inside of the model, so it doesn't matter that you can't see them. However,  what about if you wanted to use the sphere as a huge sky for your world, i.e.  so you only needed to see the inside? In this case you would just use FlipMesh.
<p>
Another use for FlipMesh is to make objects two-sided, so you can see them from  the inside and outside if you can't already. In this case, you can copy the  original mesh using CopyEntity, specifying the  original mesh as the parent, and flip it using FlipMesh. You will now have two  meshes occupying the same space - this will make it double-sided, but beware,  it will also double the polygon count!
<p>
The above technique is worth trying when an external modelling program has  exported a model in such a way that some of the triangles appear to be missing.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FluidArray>
<tr><td class=doctop colspan=2>Function FluidArray( fluid:TFluid,Array:Float Var,w:Int,h:Int,d:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create custom rendering array data for fluid mesh and set width, height and depth.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FluidFunction>
<tr><td class=doctop colspan=2>Function FluidFunction( fluid:TFluid,FieldFunction:Float( x:Float,y:Float,z:Float ) )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set custom rendering callback function for fluid mesh.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FluidThreshold>
<tr><td class=doctop colspan=2>Function FluidThreshold( fluid:TFluid,threshold:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set threshold value used in fluid rendering algorithm, 0.5 is default.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FreeAction>
<tr><td class=doctop colspan=2>Function FreeAction( act:TAction )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Frees action from memory when it has ended.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FreeBrush>
<tr><td class=doctop colspan=2>Function FreeBrush( brush:TBrush )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Frees up a brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
brush - brush handle
<p>
<b>Description</b>:
<p>
Frees up a brush.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FreeBrushTextures>
<tr><td class=doctop colspan=2>Function FreeBrushTextures( brush:TBrush )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Frees all brush textures, FreeBrush does not free textures.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FreeEntity>
<tr><td class=doctop colspan=2>Function FreeEntity( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>FreeEntity will free up the internal resources associated  with a particular entity and remove it from the scene.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
EntityHandle - Handle returned by an Entity creating function such as CreateCube(), CreateLight(), LoadMesh() etc.
<p>
<b>Description</b>:
<p>
FreeEntity will free up the internal resources associated  with a particular entity and remove it from the scene.
<p>
This command will also free all children entities parented to the entity.
<p>
Note that the variable holding the handle (and any variables referencing children handles) are not reset as it is up to the Blitz programmer to zero or ignore their contents following a call to FreeEntity().</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FreeShader>
<tr><td class=doctop colspan=2>Function FreeShader( shader:TShader ) ' Spinduluz</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Frees a shader material.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FreeShadow>
<tr><td class=doctop colspan=2>Function FreeShadow( shad:TShadowObject )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Free stencil shadow.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FreeStencil>
<tr><td class=doctop colspan=2>Function FreeStencil( stencil:TStencil ) ' Spinduluz</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Frees a stencil object.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FreeSurface>
<tr><td class=doctop colspan=2>Function FreeSurface( surf:TSurface )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Frees VBO data and brush.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FreeTexture>
<tr><td class=doctop colspan=2>Function FreeTexture( tex:TTexture )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Frees up a texture from memory.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
texture - texture handle
<p>
<b>Description</b>:
<p>
Frees up a texture from memory.
<p>
Freeing a texture means you will not be  able to use it again; however, entities already textured with it will not lose  the texture.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GeosphereHeight>
<tr><td class=doctop colspan=2>Function GeosphereHeight( geo:TGeosphere,h:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set terrain height normalizing value, 0.05 is default.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GetBrushTexture>
<tr><td class=doctop colspan=2>Function GetBrushTexture:TTexture( brush:TBrush,index:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the texture that is applied to the specified brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
brush - brush handle
<p>
index (optional) - index of texture applied to brush, from 0-7. Defaults to 0.
<p>
<b>Description</b>:
<p>
Returns the texture that is applied to the specified brush.
<p>
The optional index parameter allows you to specify which particular texture you'd like returning, if there are more than one textures applied to a brush.
<p>
You should release the texture returned by GetBrushTexture after use to prevent leaks! Use <a href=#FreeTexture>FreeTexture</a> to do this.
<p>
To find out the name of the texture, use <a href=#TextureName>TextureName</a>
<p>
See also: <a href=#TextureName>TextureName</a>, <a href=#FreeTexture>FreeTexture</a>, <a href=#GetEntityBrush>GetEntityBrush</a>, <a href=#GetSurfaceBrush>GetSurfaceBrush</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GetChild>
<tr><td class=doctop colspan=2>Function GetChild:TEntity( ent:TEntity,child_no:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a child of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
index - index of child entity. Should be in the range 1...CountChildren(  entity ) inclusive.
<p>
<b>Description</b>:
<p>
Returns a child of an entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GetEntityBrush>
<tr><td class=doctop colspan=2>Function GetEntityBrush:TBrush( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a brush with the same properties as is applied to the specified entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Returns a brush with the same properties as is applied to the specified entity.
<p>
If this command does not appear to be returning a valid brush, try using <a href=#GetSurfaceBrush>GetSurfaceBrush</a> instead with the first surface available.
<p>
Remember, GetEntityBrush actually creates a new brush so don't forget to free it afterwards using FreeBrush to prevent memory leaks.
<p>
Once you have got the brush handle from an entity, you can use GetBrushTexture and TextureName to get the details of what texture(s) are applied to the brush.
<p>
See also: <a href=#GetSurfaceBrush>GetSurfaceBrush</a>, <a href=#FreeBrush>FreeBrush</a>, <a href=#GetBrushTexture>GetBrushTexture</a>, <a href=#TextureName>TextureName</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GetEntityType>
<tr><td class=doctop colspan=2>Function GetEntityType:Int( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the collision type of an entity as set by the EntityType command.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Returns the collision type of an entity as set by the EntityType command.
<p>
See also: <a href=#EntityType>EntityType</a>, <a href=#EntityBox>EntityBox</a>, <a href=#EntityRadius>EntityRadius</a>, <a href=#Collisions>Collisions</a>, <a href=#ResetEntity>ResetEntity</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GetMatElement>
<tr><td class=doctop colspan=2>Function GetMatElement:Float( ent:TEntity,row:Int,col:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the value of an element from within an entity's transformation matrix.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
row - matrix row index
<p>
column - matrix column index
<p>
<b>Description</b>:
<p>
Returns the value of an element from within an entity's transformation matrix.
<p>
The transformation matrix is what is used by Blitz internally to position, scale and rotate entities.
<p>
GetMatElement is intended for use by advanced users only.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GetMeshLoader>
<tr><td class=doctop colspan=2>Function GetMeshLoader:TMeshLoader(extension:String)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a mesh loader capable of loading <b>extension</b>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GetParent>
<tr><td class=doctop colspan=2>Function GetParent:TEntity( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns an entity's parent.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Returns an entity's parent.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GetShaderProgram>
<tr><td class=doctop colspan=2>Function GetShaderProgram:Int( material:TShader )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get a shader program object reference.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GetString>
<tr><td class=doctop colspan=2>Function GetString:String( obj:Object,strPtr:Byte Ptr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Gets a Blitz string from a C string.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GetSurface>
<tr><td class=doctop colspan=2>Function GetSurface:TSurface( mesh:TMesh,surf_no:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the handle of the surface attached to the specified mesh and with  the specified index number.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
index - index of surface
<p>
<b>Description</b>:
<p>
Returns the handle of the surface attached to the specified mesh and with  the specified index number.
<p>
Index should be in the range 1...CountSurfaces(  mesh ), inclusive.
<p>
You need to 'get a surface', i.e. get its handle, in order to be able to  then use that particular surface with other commands.
<p>
See also: <a href=#CountSurfaces>CountSurfaces</a>, <a href=#FindSurface>FindSurface</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GetSurfaceBrush>
<tr><td class=doctop colspan=2>Function GetSurfaceBrush:TBrush( surf:TSurface )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a brush with the same properties as is applied to the specified mesh surface.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
<b>Description</b>:
<p>
Returns a brush with the same properties as is applied to the specified mesh surface.
<p>
If this command does not appear to be returning a valid brush, try using <a href=#GetEntityBrush>GetEntityBrush</a> instead.
<p>
Remember, GetSurfaceBrush actually creates a new brush so don't forget to free it afterwards using <a href=#FreeBrush>FreeBrush</a> to prevent memory leaks.
<p>
Once you have got the brush handle from a surface, you can use <a href=#GetBrushTexture>GetBrushTexture</a> and <a href=#TextureName>TextureName</a> to get the details of what texture(s) are applied to the brush.
<p>
See also: <a href=#GetEntityBrush>GetEntityBrush</a>, <a href=#FreeBrush>FreeBrush</a>, <a href=#GetSurface>GetSurface</a>, <a href=#GetBrushTexture>GetBrushTexture</a>, <a href=#TextureName>TextureName</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GlobalAnIsotropic>
<tr><td class=doctop colspan=2>Function GlobalAnIsotropic( f:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set global texture anisotropic (default for all), TextureAnIsotropic overrides it.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GlobalHeight>
<tr><td class=doctop colspan=2>Function GlobalHeight:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns global height of screen resolution.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GlobalResolution>
<tr><td class=doctop colspan=2>Function GlobalResolution( width:Int,height:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets global width and height of screen resolution.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Only needed when changing screen resolution, these globals are used in
CreateCamera, CameraViewport, CameraPick, BackBufferToTex and DepthBufferToTex.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GlobalWidth>
<tr><td class=doctop colspan=2>Function GlobalWidth:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns global width of screen resolution.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=HandleSprite>
<tr><td class=doctop colspan=2>Function HandleSprite( sprite:TSprite,h_x:Float,h_y:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets a sprite handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
sprite - sprite handle. Not to be confused with HandleSprite - ie. the handle  used to position the sprite, rather than the sprite's actual handle
<p>
<b>Description</b>:
<p>
Sets a sprite handle. Defaults to 0,0.
<p>
A sprite extends from -1,-1 to +1,+1.
<p>
See also: <a href=#LoadSprite>LoadSprite</a>, <a href=#CreateSprite>CreateSprite</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=HideEntity>
<tr><td class=doctop colspan=2>Function HideEntity( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Hides an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Hides an entity, so that it is no longer visible, and is no longer involved  in collisions.
<p>
The main purpose of hide entity is to allow you to create entities  at the beginning of a program, hide them, then copy them and show as necessary  in the main game. This is more efficient than creating entities mid-game.
<p>
If you wish to hide an entity so that it is no longer visible but still involved  in collisions, then use EntityAlpha 0 instead.  This will make an entity completely transparent.
<p>
HideEntity affects the specified entity and all of its child entities, if  any exist.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LightColor>
<tr><td class=doctop colspan=2>Function LightColor( light:TLight,red:Float,green:Float,blue:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the color of a light.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
light - light handle
<p>
red# - red value of light
<p>
green# - green value of light
<p>
blue# - blue value of light
<p>
<b>Description</b>:
<p>
Sets the color of a light.
<p>
An r,g,b value of 255,255,255 will brighten  anything the light shines on.
<p>
An r,g,b value of 0,0,0 will have no affect on anything it shines on.
<p>
An r,g,b value of -255,-255,-255 will darken anything it shines on. This is  known as 'negative lighting', and is useful for shadow effects.
<p>
See also: <a href=#CreateLight>CreateLight</a>, <a href=#LightRange>LightRange</a>, <a href=#LightConeAngles>LightConeAngles</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LightConeAngles>
<tr><td class=doctop colspan=2>Function LightConeAngles( light:TLight,inner_ang:Float,outer_ang:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the 'cone' angle for a 'spot' light.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
light - light handle
<p>
inner_angle# - inner angle of cone
<p>
outer_angle# - outer angle of cone
<p>
<b>Description</b>:
<p>
Sets the 'cone' angle for a 'spot' light.
<p>
The default light cone angles setting  is 0,90.
<p>
See also: <a href=#CreateLight>CreateLight</a>, <a href=#LightRange>LightRange</a>, <a href=#LightColor>LightColor</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LightMesh>
<tr><td class=doctop colspan=2>Function LightMesh( mesh:TMesh,red:Float,green:Float,blue:Float,range:Float=0,light_x:Float=0,light_y:Float=0,light_z:Float=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Performs a 'fake' lighting operation on a mesh.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>You need to use EntityFX ent,2 to enable vertex colors on the target mesh before you can see any results.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LightRange>
<tr><td class=doctop colspan=2>Function LightRange( light:TLight,Range:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the range of a light.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
light - light handle
<p>
range# - range of light (default: 1000.0)
<p>
<b>Description</b>:
<p>
Sets the range of a light.
<p>
The range of a light is how far it reaches.  Everything outside the range of the light will not be affected by it.
<p>
The value is very approximate, and should be experimented with for best results.
<p>
See also: <a href=#CreateLight>CreateLight</a>, <a href=#LightColor>LightColor</a>, <a href=#LightConeAngles>LightConeAngles</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LinePick>
<tr><td class=doctop colspan=2>Function LinePick:TEntity( x:Float,y:Float,z:Float,dx:Float,dy:Float,dz:Float,radius:Float=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the first entity between x.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
x# - x coordinate of start of line pick
<p>
y# - y coordinate of start of line pick
<p>
z# - z coordinate of start of line pick
<p>
dx# - distance x of line pick
<p>
dy# - distance y of line pick
<p>
dz# - distance z of line pick
<p>
radius (optional) - radius of line pick
<p>
<b>Description</b>:
<p>
Returns the first entity between x,y,z to x+dx,y+dy,z+dz.
<p>
See also: <a href=#EntityPick>EntityPick</a>, <a href=#LinePick>LinePick</a>, <a href=#CameraPick>CameraPick</a>, <a href=#EntityPickMode>EntityPickMode</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LinkShader>
<tr><td class=doctop colspan=2>Function LinkShader:Int( shader:TShader )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Link shader to a program object, as created by CreateShaderMaterial.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadAnimMesh>
<tr><td class=doctop colspan=2>Function LoadAnimMesh:TMesh( url:Object,parent:TEntity=Null,flags:Int = -1 )</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A mesh object with child meshes if any.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Loads an anim mesh, see MeshLoader.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadAnimSeq>
<tr><td class=doctop colspan=2>Function LoadAnimSeq:Int( ent:TEntity,file:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Appends an animation sequence from a file to an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
filename$ - filename of animated 3D object
<p>
<b>Description</b>:
<p>
Appends an animation sequence from a file to an entity.
<p>
Returns the animation  sequence number added.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadBrush>
<tr><td class=doctop colspan=2>Function LoadBrush:TBrush( file:String,flags:Int=9,u_scale:Float=1,v_scale:Float=1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
texture_file$ - filename of texture
<p>
flags - brush flags
<p>

flags (optional) - flags can be added to combine effects:
<p>
1: Color
<p>
2: Alpha
<p>
4: Masked
<p>
8: Mipmapped
<p>
16: Clamp U
<p>
32: Clamp V
<p>
64: Spherical reflection map
<p>

u_scale - brush u_scale
<p>
v_scale - brush v_scale
<p>
<b>Description</b>:
<p>
Creates a brush, loads and assigns a texture to it, and returns a brush handle.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadGeosphere>
<tr><td class=doctop colspan=2>Function LoadGeosphere:TGeosphere( file:String,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Load geodesic sphere terrain from heightmap image.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadMaterial>
<tr><td class=doctop colspan=2>Function LoadMaterial:TMaterial( filename:String,flags:Int,frame_width:Int,frame_height:Int,first_frame:Int,frame_count:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Load a texture from image for 3D texture sampling, use with voxelsprites.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Flags are texture flags, frame width/height is the size in pixels of each slice,
first frame is the index of the slice and frame count is how many slices.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadMD2>
<tr><td class=doctop colspan=2>Function LoadMD2:TMesh( url:Object,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Loads an md2 entity and returns its handle.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadMesh>
<tr><td class=doctop colspan=2>Function LoadMesh:TMesh( url:Object,parent:TEntity=Null,flags:Int = -1 )</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A mesh object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Loads a single mesh, see MeshLoader.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadShader>
<tr><td class=doctop colspan=2>Function LoadShader:TShader( ShaderName:String,VshaderFileName:String,FshaderFileName:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Load shader from two files, vertex and fragment.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadShaderVGF>
<tr><td class=doctop colspan=2>Function LoadShaderVGF:TShader( ShaderName:String,VshaderFileName:String,GshaderFileName:String,FshaderFileName:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Load shader from three files, vertex, geometry and fragment.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadSprite>
<tr><td class=doctop colspan=2>Function LoadSprite:TSprite( tex_file:String,tex_flag:Int=1,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a sprite entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
text_file$ - filename of image file to be used as sprite
<p>

tex_flag (optional) - texture flag:
<p>
1: Color
<p>
2: Alpha
<p>
4: Masked
<p>
8: Mipmapped
<p>
16: Clamp U
<p>
32: Clamp V
<p>
64: Spherical reflection map
<p>

parent - parent of entity
<p>
<b>Description</b>:
<p>
Creates a sprite entity, and assigns a texture to it.
<p>
See also: <a href=#LoadSprite>LoadSprite</a>, <a href=#RotateSprite>RotateSprite</a>, <a href=#ScaleSprite>ScaleSprite</a>, <a href=#HandleSprite>HandleSprite</a>, <a href=#SpriteViewMode>SpriteViewMode</a>, <a href=#PositionEntity>PositionEntity</a>, <a href=#MoveEntity>MoveEntity</a>, <a href=#TranslateEntity>TranslateEntity</a>, <a href=#EntityAlpha>EntityAlpha</a>, <a href=#FreeEntity>FreeEntity</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadTerrain>
<tr><td class=doctop colspan=2>Function LoadTerrain:TTerrain( file:String,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Loads a terrain from an image file and returns the terrain's handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
file$ - filename of image file to be used as height map
<p>
parent (optional) - parent entity of terrain
<p>
<b>Description</b>:
<p>
Loads a terrain from an image file and returns the terrain's handle.
<p>
The  image's red channel is used to determine heights. Terrain is initially the same  width and depth as the image, and 1 unit high.
<p>
Tips on generating nice terrain:
<p>
* Smooth or blur the height map
* Reduce the y scale of the terrain
* Increase the x/z scale of the terrain
* Reduce the camera range
<p>
When texturing an entity, a texture with a scale of 1,1,1 (default) will  be the same size as one of the terrain's grid squares. A texture that is scaled  to the same size as the size of the bitmap used to load it or the no. of grid  square used to create it, will be the same size as the terrain.
<p>
The optional parent parameter allows you to specify a parent  entity for the terrain so that when the parent is moved the child terrain will  move with it. However, this relationship is one way; applying movement commands  to the child will not affect the parent.
<p>
Specifying a parent entity will still result in the terrain being created  at position 0,0,0 rather than at the parent entity's position.
<p>
A heightmaps dimensions (width and height) must be the same and must be a power of 2, e.g. 32, 64, 128, 256, 512, 1024.
<p>
See also: <a href=#CreateTerrain>CreateTerrain</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=MeshCSG>
<tr><td class=doctop colspan=2>Function MeshCSG:TMesh( m1:TMesh,m2:TMesh,method_no:Int=1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Method 0 subtracts mesh2 from mesh1, 1 adds meshes, 2 intersects meshes. Returns a new mesh.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=MeshCullRadius>
<tr><td class=doctop colspan=2>Function MeshCullRadius( ent:TEntity,radius:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Equivalent of Blitz3D's MeshCullBox command. It sets the radius of a mesh's 'cull sphere'</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>If the 'cull sphere' is not inside the viewing area, the mesh will not be rendered.
A mesh's cull radius is set automatically, therefore in most cases you will not have to use this command.
One time you may have to use it is for animated meshes where the default cull radius may not take into
account all animation positions, resulting in the mesh being wrongly culled at extreme positions.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=MeshDepth>
<tr><td class=doctop colspan=2>Function MeshDepth:Float( mesh:TMesh )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the depth of a mesh.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
<b>Description</b>:
<p>
Returns the depth of a mesh. This is calculated by the actual vertex positions and so the scale of the entity (set by ScaleEntity) will not have an effect on the resultant depth. Mesh operations, on the other hand, will effect the result.
<p>
See also: <a href=#MeshWidth>MeshWidth</a>, <a href=#MeshHeight>MeshHeight</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=MeshesIntersect>
<tr><td class=doctop colspan=2>Function MeshesIntersect:Int( mesh1:TMesh,mesh2:TMesh )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns true if the specified meshes are currently intersecting.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh_a - mesh_a handle
<p>
mesh_b - mesh_b handle
<p>
<b>Description</b>:
<p>
Returns true if the specified meshes are currently intersecting.
<p>
This  is a fairly slow routine - use with discretion...
<p>
This command is  currently the only  polygon->polygon collision checking routine available in Blitz3D.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=MeshHeight>
<tr><td class=doctop colspan=2>Function MeshHeight:Float( mesh:TMesh )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the height of a mesh.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
<b>Description</b>:
<p>
Returns the height of a mesh. This is calculated by the actual vertex positions and so the scale of the entity (set by ScaleEntity) will not have an effect on the resultant height. Mesh operations, on the other hand, will effect the result.
<p>
See also: <a href=#MeshWidth>MeshWidth</a>, <a href=#MeshDepth>MeshDepth</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=MeshWidth>
<tr><td class=doctop colspan=2>Function MeshWidth:Float( mesh:TMesh )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the width of a mesh.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
<b>Description</b>:
<p>
Returns the width of a mesh. This is calculated by the actual vertex positions and so the scale of the entity (set by ScaleEntity) will not have an effect on the resultant width. Mesh operations, on the other hand, will effect the result.
<p>
See also: <a href=#MeshHeight>MeshHeight</a>, <a href=#MeshDepth>MeshDepth</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ModifyGeosphere>
<tr><td class=doctop colspan=2>Function ModifyGeosphere( geo:TGeosphere,x:Int,z:Int,new_height:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set height of a given point, like ModifyTerrain.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ModifyTerrain>
<tr><td class=doctop colspan=2>Function ModifyTerrain( terr:TTerrain,x:Int,z:Int,new_height:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the height of a point on a terrain.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
terrain - terrain handle
<p>
grid_x - grid x coordinate of terrain
<p>
grid_y - grid y coordinate of terrain
<p>
height# - height of point on terrain. Should be in the range 0-1.
<p>
realtime (optional) - True to modify terrain immediately. False to modify terrain  when RenderWorld in next called. Defaults to False.
<p>
<b>Description</b>:
<p>
Sets the height of a point on a terrain.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=MoveEntity>
<tr><td class=doctop colspan=2>Function MoveEntity( ent:TEntity,x:Float,y:Float,z:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Moves an entity relative to its current position and orientation.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - name of entity to be moved
<p>
x# - x amount that entity will be moved by
<p>
y# - y amount that entity will be moved by
<p>
z# - z amount that entity will be moved by
<p>
<b>Description</b>:
<p>
Moves an entity relative to its current position and orientation.
<p>
What this means is that an entity will move in whatever direction it is facing. So for example if you have an game character is upright when first loaded into Blitz3D and it remains upright (i.e. turns left or right only), then moving it by a z amount will always see it move forward or backward, moving it by a y amount will always see it move up or down, and moving it by an x amount will always see it strafe.
<p>
See also: <a href=#TranslateEntity>TranslateEntity</a>, <a href=#PositionEntity>PositionEntity</a>, <a href=#PositionMesh>PositionMesh</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=MSAntiAlias>
<tr><td class=doctop colspan=2>Function MSAntiAlias( multisample:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enables or disables hardware multisample antialiasing if supported.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=NameEntity>
<tr><td class=doctop colspan=2>Function NameEntity( ent:TEntity,name:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets an entity's name.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
name$ - name of entity
<p>
<b>Description</b>:
<p>
Sets an entity's name.
<p>
See also: <a href=#EntityName>EntityName</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=NewAnimationKeys>
<tr><td class=doctop colspan=2>Function NewAnimationKeys:TAnimationKeys( bone:TBone=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TAnimationKeys object.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>keys=NewAnimationKeys()</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=NewBone>
<tr><td class=doctop colspan=2>Function NewBone:TBone()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TBone object.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>bone=NewBone()</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=NewMatPtr>
<tr><td class=doctop colspan=2>Function NewMatPtr:TMatPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TMatPtr object, returns a Float Ptr matrix.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>mat=NewMatPtr()</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=NewMesh>
<tr><td class=doctop colspan=2>Function NewMesh:TMesh()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TMesh object.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>mesh=NewMesh()</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=NewQuatPtr>
<tr><td class=doctop colspan=2>Function NewQuatPtr:TQuatPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TQuatPtr object, returns a Float Ptr quaternion.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>quat=NewQuatPtr()</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=NewSprite>
<tr><td class=doctop colspan=2>Function NewSprite:TSprite()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TSprite object.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>spr=NewSprite()</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=NewSurface>
<tr><td class=doctop colspan=2>Function NewSurface:TSurface()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TSurface object.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>surf=NewSurface()</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=NewTexture>
<tr><td class=doctop colspan=2>Function NewTexture:TTexture()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TTexture object.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>tex=NewTexture()</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=NewVecPtr>
<tr><td class=doctop colspan=2>Function NewVecPtr:TVecPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TVecPtr object, returns a Float Ptr vector.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>vec=NewVecPtr()</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=OctreeBlock>
<tr><td class=doctop colspan=2>Function OctreeBlock( octree:TOcTree,mesh:TMesh,level:Int,X:Float,Y:Float,Z:Float,Near:Float=0,Far:Float=1000 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Place mesh into a node of an octree, the mesh can be duplicated using no more memory.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Since a block is not an entity it has no position, etc. it has the properties of the node it is in.
Level defaults to 0, the higher the level the smaller the cell. XYZ is the position in the octree.
Near defaults to 0, this is the minimum distance at which that node is visible, if 0 that node is
always visible, if higher the mesh/block won't be rendered when it's closer.
Far defaults to 1000, this is the maximum distance at which the node can be split in children,
if the node is set at a higher range than the camera, its children won't be rendered.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=OctreeMesh>
<tr><td class=doctop colspan=2>Function OctreeMesh( octree:TOcTree,mesh:TMesh,level:Int,X:Float,Y:Float,Z:Float,Near:Float=0,Far:Float=1000 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Place mesh into a node of an octree, the mesh can't be duplicated so to do that use CopyEntity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PaintEntity>
<tr><td class=doctop colspan=2>Function PaintEntity( ent:TEntity,brush:TBrush )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Paints a entity with a brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
brush - brush handle
<p>
<b>Description</b>:
<p>
Paints a entity with a brush.
<p>
The reason for using PaintEntity to apply  specific properties to a entity using a brush rather than just using EntityTexture,  EntityColor, EntityShininess etc, is that you can pre-define one brush, and  then paint entities over and over again using just the one command rather than  lots of separate ones.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PaintMesh>
<tr><td class=doctop colspan=2>Function PaintMesh( mesh:TMesh,brush:TBrush )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Paints a mesh with a brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
brush - brush handle
<p>
<b>Description</b>:
<p>
Paints a mesh with a brush.
<p>
This has the effect of instantly altering  the visible appearance of the mesh, assuming the brush's properties are different  to what was was applied to the surface before.
<p>
The reason for using PaintMesh to apply specific properties to a mesh using  a brush rather than just using EntityTexture, EntityColor, EntityShininess etc,  is that you can pre-define one brush, and then paint meshes over and over again  using just the one command rather than lots of separate ones.
<p>
See also: <a href=#PaintEntity>PaintEntity</a>, <a href=#PaintSurface>PaintSurface</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PaintSurface>
<tr><td class=doctop colspan=2>Function PaintSurface( surf:TSurface,brush:TBrush )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Paints a surface with a brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
brush - brush handle
<p>
<b>Description</b>:
<p>
Paints a surface with a brush.
<p>
This has the effect of instantly altering  the visible appearance of that particular surface, i.e. section of mesh, assuming  the brush's properties are different to what was applied to the surface before.
<p>
See also: <a href=#PaintEntity>PaintEntity</a>, <a href=#PaintMesh>PaintMesh</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ParticleColor>
<tr><td class=doctop colspan=2>Function ParticleColor( sprite:TSprite,r:Float,g:Float,b:Float,a:Float=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets color of batch particle trails.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Batch particle render mode (3) is not working.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ParticleTrail>
<tr><td class=doctop colspan=2>Function ParticleTrail( sprite:TSprite,length:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets number of batch particles in trail.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Batch particle render mode (3) is not working.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ParticleVector>
<tr><td class=doctop colspan=2>Function ParticleVector( sprite:TSprite,x:Float,y:Float,z:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets 3d vector of batch particle trails.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Batch particle render mode (3) is not working.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PickedEntity>
<tr><td class=doctop colspan=2>Function PickedEntity:TEntity()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the entity 'picked' by the most recently executed Pick command.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the entity 'picked' by the most recently executed Pick command.  This might have been CameraPick, EntityPick or LinePick.
<p>
Returns 0 if no entity was picked.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PickedNX>
<tr><td class=doctop colspan=2>Function PickedNX:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the x component of the normal of the most recently executed Pick  command.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the x component of the normal of the most recently executed Pick  command. This might have been CameraPick, EntityPick or LinePick.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PickedNY>
<tr><td class=doctop colspan=2>Function PickedNY:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the y component of the normal of the most recently executed Pick  command.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the y component of the normal of the most recently executed Pick  command. This might have been CameraPick, EntityPick or LinePick.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PickedNZ>
<tr><td class=doctop colspan=2>Function PickedNZ:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the z component of the normal of the most recently executed Pick  command.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the z component of the normal of the most recently executed Pick  command. This might have been CameraPick, EntityPick or LinePick.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PickedSurface>
<tr><td class=doctop colspan=2>Function PickedSurface:TSurface()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the handle of the surface that was 'picked' by the most recently  executed Pick command.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the handle of the surface that was 'picked' by the most recently  executed Pick command. This might have been CameraPick, EntityPick or LinePick.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PickedTime>
<tr><td class=doctop colspan=2>Function PickedTime:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the time taken to calculate the most recently executed Pick command.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the time taken to calculate the most recently executed Pick command.  This might have been CameraPick, EntityPick or LinePick.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PickedTriangle>
<tr><td class=doctop colspan=2>Function PickedTriangle:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the index number of the triangle that was 'picked' by the most recently  executed Pick command.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the index number of the triangle that was 'picked' by the most recently  executed Pick command. This might have been CameraPick, EntityPick or LinePick.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PickedX>
<tr><td class=doctop colspan=2>Function PickedX:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the world x coordinate of the most recently executed Pick command.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the world x coordinate of the most recently executed Pick command.  This might have been CameraPick, EntityPick or LinePick.
<p>
The coordinate represents the exact point of where something was picked.
<p>
See also: <a href=#PickedY>PickedY</a>, <a href=#PickedZ>PickedZ</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PickedY>
<tr><td class=doctop colspan=2>Function PickedY:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the world y coordinate of the most recently executed Pick command.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the world y coordinate of the most recently executed Pick command.  This might have been CameraPick, EntityPick or LinePick.
<p>
The coordinate represents the exact point of where something was picked.
<p>
See also: <a href=#PickedX>PickedX</a>, <a href=#PickedZ>PickedZ</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PickedZ>
<tr><td class=doctop colspan=2>Function PickedZ:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the world z coordinate of the most recently executed Pick command.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the world z coordinate of the most recently executed Pick command.  This might have been CameraPick, EntityPick or LinePick.
<p>
The coordinate represents the exact point of where something was picked.
<p>
See also: <a href=#PickedX>PickedX</a>, <a href=#PickedY>PickedY</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PointEntity>
<tr><td class=doctop colspan=2>Function PointEntity( ent:TEntity,target_ent:TEntity,roll:Float=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Points one entity at another.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
target - target entity handle
<p>
roll# (optional) - roll angle of entity
<p>
<b>Description</b>:
<p>
Points one entity at another.
<p>
The optional roll parameter allows you to  specify a roll angle as pointing an entity only sets pitch and yaw angles.
<p>
If you wish for an entity to point at a certain position rather than another  entity, simply create a pivot entity at your desired position, point the entity  at this and then free the pivot.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PositionAnimMesh>
<tr><td class=doctop colspan=2>Function PositionAnimMesh( mesh:TMesh,px#,py#,pz# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Moves all vertices of mesh and every child mesh.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PositionEntity>
<tr><td class=doctop colspan=2>Function PositionEntity( ent:TEntity,x:Float,y:Float,z:Float,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Positions an entity at an absolute position in 3D space.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - name of entity to be positioned
<p>
x# - x co-ordinate that entity will be positioned at
<p>
y# - y co-ordinate that entity will be positioned at
<p>
z# - z co-ordinate that entity will be positioned at
<p>
global (optional) - true if the position should be relative to 0,0,0 rather than a parent entity's position. False by default.
<p>
<b>Description</b>:
<p>
Positions an entity at an absolute position in 3D space.
<p>
Entities are positioned using an x,y,z coordinate system. x, y and z each have their own axis, and each axis has its own set of values. By specifying a value for each axis, you can position an entity anywhere in 3D space. 0,0,0 is the centre of 3D space, and if the camera is pointing in the default positive z direction, then positioning an entity with a z value of above 0 will make it appear in front of the camera, whereas a negative z value would see it disappear behind the camera. Changing the x value would see it moving sideways, and changing the y value would see it moving up/down.
<p>
Of course, the direction in which entities appear to move is relative to the position and orientation of the camera.
<p>
See also: <a href=#MoveEntity>MoveEntity</a>, <a href=#TranslateEntity>TranslateEntity</a>, <a href=#PositionMesh>PositionMesh</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PositionMesh>
<tr><td class=doctop colspan=2>Function PositionMesh( mesh:TMesh,px:Float,py:Float,pz:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Moves all vertices of a mesh.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
x# - x position of mesh
<p>
y# - y position of mesh
<p>
z# - z position of mesh
<p>
<b>Description</b>:
<p>
Moves all vertices of a mesh.
<p>
See also: <a href=#PositionEntity>PositionEntity</a>, <a href=#MoveEntity>MoveEntity</a>, <a href=#TranslateEntity>TranslateEntity</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PositionTexture>
<tr><td class=doctop colspan=2>Function PositionTexture( tex:TTexture,u_pos:Float,v_pos:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Positions a texture at an absolute position.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
texture - texture handle
<p>
u_position# - u position of texture
<p>
v_position# - v position of texture
<p>
<b>Description</b>:
<p>
Positions a texture at an absolute position.
<p>
This will have an  immediate effect on all instances of the texture being used.
<p>
Positioning a texture is useful for performing scrolling texture effects,  such as for water etc.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PostFXBuffer>
<tr><td class=doctop colspan=2>Function PostFXBuffer( fx:TPostFX,pass_no:Int,source_pass:Int,index:Int,slot:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>undocumented.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PostFXFunction>
<tr><td class=doctop colspan=2>Function PostFXFunction( fx:TPostFX,pass_no:Int,PassFunction() )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>undocumented.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PostFXShader>
<tr><td class=doctop colspan=2>Function PostFXShader( fx:TPostFX,pass_no:Int,shader:TShader )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>undocumented.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PostFXShaderPass>
<tr><td class=doctop colspan=2>Function PostFXShaderPass( fx:TPostFX,pass_no:Int,name:String,v:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>undocumented.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PostFXTexture>
<tr><td class=doctop colspan=2>Function PostFXTexture( fx:TPostFX,pass_no:Int,tex:TTexture,slot:Int,frame:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>undocumented.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ProjectedX>
<tr><td class=doctop colspan=2>Function ProjectedX:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the viewport x coordinate of the most recently executed CameraProject.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the viewport x coordinate of the most recently executed CameraProject.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ProjectedY>
<tr><td class=doctop colspan=2>Function ProjectedY:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the viewport y coordinate of the most recently executed CameraProject.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the viewport y coordinate of the most recently executed CameraProject.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ProjectedZ>
<tr><td class=doctop colspan=2>Function ProjectedZ:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the viewport z coordinate of the most recently executed CameraProject.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the viewport z coordinate of the most recently executed CameraProject.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=RenderWorld>
<tr><td class=doctop colspan=2>Function RenderWorld()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Renders the current scene to the BackBuffer onto the rectangle defined by each cameras CameraViewport( )</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
tween# (optional) - defaults to 1.
<p>
<b>Description</b>:
<p>
Renders the current scene to the BackBuffer onto the rectangle defined by each cameras CameraViewport( ). Every camera not hidden by HideEntity( ) or with a CameraProjMode( ) of 0 is rendered. Rendering to other buffers is currently not supported by Blitz3D.
<p>
The optional tween parameter should only be specified when RenderWorld is used in conjunction with CaptureWorld. CaptureWorld is used to store the 'old' position, rotation and scale, alpha and colour of each entity in the game world, and a tween value of
<p>
The use of tweening allows you to render more than one frame per game logic update, while still keeping the display smooth. This allows you to cut down on the CPU time that would be required to update your game logic every render. Note, however, that the bottleneck in almost all 3D applications is the graphics card and the CPU time involved in updating game logic is often very little. A good alternative to render tweening is the use of a delta time, that is, moving your entities each frame depending on the time it took for the program to process and render that frame.
<p>
Render tweening is quite an advanced technique, and it is not necessary to  use it, so don't worry if you don't quite understand it. See the castle demo  included in the mak (nickname of Mark Sibly, author of Blitz3D) directory of  the Blitz3D samples section for a demonstration of render tweening.
<p>
See also: <a href=#CaptureWorld>CaptureWorld</a>, <a href=#CameraViewport>CameraViewport</a>, <a href=#CameraProjMode>CameraProjMode</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=RepeatMesh>
<tr><td class=doctop colspan=2>Function RepeatMesh:TMesh( mesh:TMesh,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Like CopyMesh but for instancing effects.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ResetEntity>
<tr><td class=doctop colspan=2>Function ResetEntity( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Resets the collision state of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Resets the collision state of an entity.
<p>
See also: <a href=#EntityBox>EntityBox</a>, <a href=#EntityRadius>EntityRadius</a>, <a href=#Collisions>Collisions</a>, <a href=#EntityType>EntityType</a>, <a href=#GetEntityType>GetEntityType</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ResetShadow>
<tr><td class=doctop colspan=2>Function ResetShadow( shad:TShadowObject )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Reset created flag to update static shadow.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=RotateAnimMesh>
<tr><td class=doctop colspan=2>Function RotateAnimMesh( mesh:TMesh,rx#,ry#,rz# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotates all vertices of mesh and every child mesh.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=RotateEntity>
<tr><td class=doctop colspan=2>Function RotateEntity( ent:TEntity,x:Float,y:Float,z:Float,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotates an entity so that it is at an absolute orientation.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - name of the entity to be rotated
<p>
pitch# - angle in degrees of pitch rotation
<p>
yaw# - angle in degrees of yaw rotation
<p>
roll# - angle in degrees of roll rotation
<p>
global (optional) - true if the angle rotated should be relative to 0,0,0 rather than a parent entity's orientation. False by default.
<p>
<b>Description</b>:
<p>
Rotates an entity so that it is at an absolute orientation.
<p>
Pitch is the same as the x angle of an entity, and is equivalent to tilting forward/backwards.
<p>
Yaw is the same as the y angle of an entity, and is equivalent to turning left/right.
<p>
Roll is the same as the z angle of an entity, and is equivalent to tilting left/right.
<p>
See also: <a href=#TurnEntity>TurnEntity</a>, <a href=#RotateMesh>RotateMesh</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=RotateMesh>
<tr><td class=doctop colspan=2>Function RotateMesh( mesh:TMesh,pitch:Float,yaw:Float,roll:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotates all vertices of a mesh by the specified rotation.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
pitch# - pitch of mesh
<p>
yaw# - yaw of mesh
<p>
roll# - roll of mesh
<p>
<b>Description</b>:
<p>
Rotates all vertices of a mesh by the specified rotation.
<p>
See also: <a href=#RotateEntity>RotateEntity</a>, <a href=#TurnEntity>TurnEntity</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=RotateSprite>
<tr><td class=doctop colspan=2>Function RotateSprite( sprite:TSprite,ang:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotates a sprite.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
sprite - sprite handle
<p>
angle# - absolute angle of sprite rotation
<p>
<b>Description</b>:
<p>
Rotates a sprite.
<p>
See also: <a href=#CreateSprite>CreateSprite</a>, <a href=#LoadSprite>LoadSprite</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=RotateTexture>
<tr><td class=doctop colspan=2>Function RotateTexture( tex:TTexture,ang:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotates a texture.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
texture - texture handle
<p>
angle# - absolute angle of texture rotation
<p>
<b>Description</b>:
<p>
Rotates a texture.
<p>
This will have an immediate effect on all instances  of the texture being used.
<p>
Rotating a texture is useful for performing swirling texture effects,  such as for smoke etc.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ScaleAnimMesh>
<tr><td class=doctop colspan=2>Function ScaleAnimMesh( mesh:TMesh,sx#,sy#,sz# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Scales all vertices of mesh and every child mesh.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ScaleEntity>
<tr><td class=doctop colspan=2>Function ScaleEntity( ent:TEntity,x:Float,y:Float,z:Float,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Scales an entity so that it is of an absolute size.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - name of the entity to be scaled
<p>
x_scale# - x size of entity
<p>
y_scale# - y size of entity
<p>
z_scale# - z size of entity
<p>
global (optional) -
<p>
<b>Description</b>:
<p>
Scales an entity so that it is of an absolute size.
<p>
Scale values of 1,1,1 are the default size when creating/loading entities.
<p>
Scale values of 2,2,2 will double the size of an entity.
<p>
Scale values of 0,0,0 will make an entity disappear.
<p>
Scale values of less than 0,0,0 will invert an entity and make it bigger.
<p>
See also: <a href=#ScaleMesh>ScaleMesh</a>, <a href=#FitMesh>FitMesh</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ScaleMesh>
<tr><td class=doctop colspan=2>Function ScaleMesh( mesh:TMesh,sx:Float,sy:Float,sz:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Scales all vertices of a mesh by the specified scaling factors.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
x_scale# - x scale of mesh
<p>
y_scale# - y scale of mesh
<p>
z_scale# - z scale of mesh
<p>
<b>Description</b>:
<p>
Scales all vertices of a mesh by the specified scaling factors.
<p>
See also: <a href=#FitMesh>FitMesh</a>, <a href=#ScaleEntity>ScaleEntity</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ScaleSprite>
<tr><td class=doctop colspan=2>Function ScaleSprite( sprite:TSprite,s_x:Float,s_y:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Scales a sprite.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
sprite - sprite handle
<p>
x_scale# - x scale of sprite
<p>
y scale# - y scale of sprite
<p>
<b>Description</b>:
<p>
Scales a sprite.
<p>
See also: <a href=#LoadSprite>LoadSprite</a>, <a href=#CreateSprite>CreateSprite</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ScaleTexture>
<tr><td class=doctop colspan=2>Function ScaleTexture( tex:TTexture,u_scale:Float,v_scale:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Scales a texture by an absolute amount.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
texture - name of texture
<p>
u_scale# - u scale
<p>
v_scale# - v scale
<p>
<b>Description</b>:
<p>
Scales a texture by an absolute amount.
<p>
This will have an immediate  effect on all instances of the texture being used.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetAnimKey>
<tr><td class=doctop colspan=2>Function SetAnimKey( ent:TEntity,frame:Float,pos_key:Int=True,rot_key:Int=True,scale_key:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets an animation key for the specified entity at the specified frame.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
frame - frame of animation to be used as anim key
<p>
pos_key (optional) - true to include entity position information when setting  key. Defaults to true.
<p>
rot_key (optional) - true to include entity rotation information when setting  key. Defaults to true.
<p>
scale_key (optional) - true to include entity scale information when setting  key. Defaults to true.
<p>
<b>Description</b>:
<p>
Sets an animation key for the specified entity at the specified frame.  The entity must have a valid animation sequence to work with.
<p>
This is most useful when you've got a character, or a complete set of complicated moves to perform, and you want to perform them en-masse.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetAnimTime>
<tr><td class=doctop colspan=2>Function SetAnimTime( ent:TEntity,time:Float,seq:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>SetAnimTime allows you to manually animate entities.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - a valid entity handle.
<p>
time# - a floating point time value.
<p>
anim_seq - an optional animation sequence number.
<p>
<b>Description</b>:
<p>
SetAnimTime allows you to manually animate entities.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetCubeFace>
<tr><td class=doctop colspan=2>Function SetCubeFace( tex:TTexture,face:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Selects a cube face for direct rendering to a texture.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
texture - texture
<p>
face - face of cube to select. This should be one of the following values:
<p>
0: left (negative X) face
<p>
1: forward (positive Z) face - this is the default.
<p>
2: right (positive X) face
<p>
3: backward (negative Z) face
<p>
4: up (positive Y) face
<p>
5: down (negative Y) face
<p>
<b>Description</b>:
<p>
Selects a cube face for direct rendering to a texture.
<p>
This command should only be used when you wish to draw directly to a cubemap texture in real-time. Otherwise, just loading a pre-rendered cubemap with a flag of 128 will suffice.
<p>
To understand how this command works exactly it is important to recognise that Blitz treats cubemap textures slightly differently to how it treats other textures. Here's how it works...
<p>
A cubemap texture in Blitz actually consists of six images, each of which must be square 'power' of two size - e.g. 32, 64, 128 etc. Each corresponds to a particular cube face. These images are stored internally by Blitz, and the texture handle that is returned by LoadTexture/CreateTexture when specifying the cubemap flag, only provides access to one of these six images at once (by default the first one, or '0' face).
<p>
This is why, when loading a cubemap texture into Blitz using LoadTexture, all the six cubemap images must be laid out in a specific order (0-5, as described above), in a horizontal strip. Then Blitz takes this texture and internally converts it into six separate images.
<p>
So seeing as the texture handle returned by <a href=#CreateTexture>CreateTexture</a> / <a href=#LoadTexture>LoadTexture</a> only provides access to one of these images at once (no. 1 by default), how do we get access to the other five images? This is where SetCubeFace comes in. It will tell Blitz that whenever you next draw to a cubemap texture, to draw to the particular image representing the face you have specified with the face parameter.
<p>
Now you have the ability to draw to a cubemap in real-time.
<p>
To give you some idea of how this works in code, here's a function that updates a cubemap in real-time. It works by rendering six different views and copying them to the cubemap texture buffer, using SetCubeFace to specify which particular cubemap image should be drawn to.
<p>
; Start of code
<p>
Function UpdateCubeMap( tex,camera )
<p>
tex_sz=TextureWidth(tex)
<p>
; do left view
SetCubeFace tex,0
RotateEntity camera,0,90,0
RenderWorld
<p>
; copy contents of backbuffer to cubemap
CopyRect 0,0,tex_sz,tex_sz,0,0,BackBuffer(),TextureBuffer(tex)
<p>
; do forward view
SetCubeFace tex,1
RotateEntity camera,0,0,0
RenderWorld
CopyRect 0,0,tex_sz,tex_sz,0,0,BackBuffer(),TextureBuffer(tex)
<p>
; do right view
SetCubeFace tex,2
RotateEntity camera,0,-90,0
RenderWorld
CopyRect 0,0,tex_sz,tex_sz,0,0,BackBuffer(),TextureBuffer(tex)
<p>
; do backward view
SetCubeFace tex,3
RotateEntity camera,0,180,0
RenderWorld
CopyRect 0,0,tex_sz,tex_sz,0,0,BackBuffer(),TextureBuffer(tex)
<p>
; do up view
SetCubeFace tex,4
RotateEntity camera,-90,0,0
RenderWorld
CopyRect 0,0,tex_sz,tex_sz,0,0,BackBuffer(),TextureBuffer(tex)
<p>
; do down view
SetCubeFace tex,5
RotateEntity camera,90,0,0
RenderWorld
CopyRect 0,0,tex_sz,tex_sz,0,0,BackBuffer(),TextureBuffer(tex)
<p>
EndFunction
<p>
; End of code
<p>
All rendering to a texture buffer affects the currently selected face. Do not change the selected cube face while a buffer is locked.
<p>
Finally, you may wish to combine the vram 256 flag with the cubic mapping flag when drawing to cubemap textures for faster access.
<p>
See also: <a href=#CreateTexture>CreateTexture</a>, <a href=#LoadTexture>LoadTexture</a>, <a href=#SetCubeMode>SetCubeMode</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetCubeMode>
<tr><td class=doctop colspan=2>Function SetCubeMode( tex:TTexture,Mode:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the rendering mode of a cubemap texture.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
texture - a valid texture handle
<p>

<p>
mode - the rendering mode of the cubemap texture:
<p>
1: Specular (default)
<p>
2: Diffuse
<p>
3: Refraction
<p>
<b>Description</b>:
<p>
Set the rendering mode of a cubemap texture.
<p>
The available rendering modes are as follows:
<p>
1: Specular (default). Use this to give your cubemapped objects a shiny effect.
<p>
2: Diffuse. Use this to give your cubemapped objects a non-shiny, realistic lighting effect.
<p>
3: Refraction. Good for 'cloak'-style effects.
<p>
See also: <a href=#CreateTexture>CreateTexture</a>, <a href=#LoadTexture>LoadTexture</a>, <a href=#SetCubeFace>SetCubeFace</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetFloat>
<tr><td class=doctop colspan=2>Function SetFloat( material:TShader,name:String,v1:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set a shader variable name of a uniform float type to a float value.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetFloat2>
<tr><td class=doctop colspan=2>Function SetFloat2( material:TShader,name:String,v1:Float,v2:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set a shader variable name of a uniform vec2 type to 2 float values.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetFloat3>
<tr><td class=doctop colspan=2>Function SetFloat3( material:TShader,name:String,v1:Float,v2:Float,v3:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set a shader variable name of a uniform vec3 type to 3 float values.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetFloat4>
<tr><td class=doctop colspan=2>Function SetFloat4( material:TShader,name:String,v1:Float,v2:Float,v3:Float,v4:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set a shader variable name of a uniform vec4 type to 4 float values.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetInteger>
<tr><td class=doctop colspan=2>Function SetInteger( material:TShader,name:String,v1:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set a shader variable name of a uniform int type to an integer value.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetInteger2>
<tr><td class=doctop colspan=2>Function SetInteger2( material:TShader,name:String,v1:Int,v2:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set a shader variable name of a uniform ivec2 type to 2 integer values.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetInteger3>
<tr><td class=doctop colspan=2>Function SetInteger3( material:TShader,name:String,v1:Int,v2:Int,v3:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set a shader variable name of a uniform ivec3 type to 3 integer values.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetInteger4>
<tr><td class=doctop colspan=2>Function SetInteger4( material:TShader,name:String,v1:Int,v2:Int,v3:Int,v4:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set a shader variable name of a uniform ivec4 type to 4 integer values.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetShadowColor>
<tr><td class=doctop colspan=2>Function SetShadowColor( R:Int,G:Int,B:Int,A:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set color R/G/B in range 0..255 and A in range 0..1.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetString>
<tr><td class=doctop colspan=2>Function SetString:String( obj:Object,strPtr:Byte Ptr,strValue:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets a C string from a Blitz string.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ShadeEntity>
<tr><td class=doctop colspan=2>Function ShadeEntity( ent:TEntity,material:TShader )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Apply shader to an entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ShadeMesh>
<tr><td class=doctop colspan=2>Function ShadeMesh( mesh:TMesh,material:TShader )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Apply shader to a mesh.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ShaderFunction>
<tr><td class=doctop colspan=2>Function ShaderFunction( material:TShader,EnableFunction(),DisableFunction() )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>undocumented.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ShaderMaterial>
<tr><td class=doctop colspan=2>Function ShaderMaterial( material:TShader,tex:TMaterial,name:String,index:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set a 3d texture for sampling.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ShaderTexture>
<tr><td class=doctop colspan=2>Function ShaderTexture:TTexture( material:TShader,tex:TTexture,name:String,index:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Load a texture for 2D texture sampling.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ShadeSurface>
<tr><td class=doctop colspan=2>Function ShadeSurface( surf:TSurface,material:TShader )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Apply shader to a surface.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ShowEntity>
<tr><td class=doctop colspan=2>Function ShowEntity( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Shows an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Shows an entity. Very much the opposite of HideEntity.
<p>
Once an entity has been hidden using HideEntity,  use show entity to make it visible and involved in collisions again.  Note that ShowEntity has no effect if the enitities parent object is hidden.
<p>
Entities are shown by default after creating/loading them, so you should  only need to use ShowEntity after using HideEntity.
<p>
ShowEntity affects the specified entity only - child entities are not affected.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SkinMesh>
<tr><td class=doctop colspan=2>Function SkinMesh( mesh:TMesh,surf_no_get:Int,vid:Int,bone1:Int,weight1:Float=1.0,bone2:Int=0,weight2:Float=0,bone3:Int=0,weight3:Float=0,bone4:Int=0,weight4:Float=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set animated surface for each of the bone no and weights arrays.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>bone no references the bones list in a mesh, weights is a normalizing value.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SpriteRenderMode>
<tr><td class=doctop colspan=2>Function SpriteRenderMode( sprite:TSprite,Mode:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>If mode is 1 rendering is normal, 2 is for batch sprites like particles.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Batch particle render mode (3) is not working.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SpriteViewMode>
<tr><td class=doctop colspan=2>Function SpriteViewMode( sprite:TSprite,Mode:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the view mode of a sprite.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
sprite - sprite handle
<p>

view_mode - view_mode of sprite
<p>
1: fixed (sprite always faces camera - default)
<p>
2: free (sprite is independent of camera)
<p>
3: upright1 (sprite always faces camera, but rolls with camera as well, unlike  mode no.1)
<p>
4: upright2 (sprite always remains upright. Gives a 'billboard' effect. Good  for trees, spectators etc.)
<p>
<b>Description</b>:
<p>
Sets the view mode of a sprite.
<p>
The view mode determines how a sprite  alters its orientation in respect to the camera. This allows the sprite to in  some instances give the impression that it is more than two dimensional.
<p>
In technical terms, the four sprite modes perform the following changes:
<p>
1: Sprite changes its pitch and yaw values to face camera, but doesn't roll.
2: Sprite does not change either its pitch, yaw or roll values.
3: Sprite changes its yaw and pitch to face camera, and changes its roll value  to match cameras.
4: Sprite changes its yaw value to face camera, but not its pitch value, and  changes its roll value to match cameras.
<p>
Note that if you use sprite view mode 2, then because it is independent from  the camera, you will only be able to see it from one side unless you use EntityFx  flag 16 with it to disable backface culling.
<p>
See also: <a href=#CreateSprite>CreateSprite</a>, <a href=# LoadSprite> LoadSprite</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=StencilAlpha>
<tr><td class=doctop colspan=2>Function StencilAlpha( stencil:TStencil,a:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set stencil alpha value.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=StencilClsColor>
<tr><td class=doctop colspan=2>Function StencilClsColor( stencil:TStencil,r:Float,g:Float,b:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set stencil clear screen color in range 0..255.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=StencilClsMode>
<tr><td class=doctop colspan=2>Function StencilClsMode( stencil:TStencil,cls_color:Int,cls_zbuffer:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set stencil clear screen modes.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Cls_color is true to use the color buffer, cls_zbuffer is true to use the depth buffer.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=StencilMesh>
<tr><td class=doctop colspan=2>Function StencilMesh( stencil:TStencil,mesh:TMesh,Mode:Int=1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set mesh to be used as stencil.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Mode is stencil action for glStencilOp in range -2..2 where 1 is INCR (default),
2 is INCR for stencil shadow meshes and negative values are DECR.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=StencilMode>
<tr><td class=doctop colspan=2>Function StencilMode( stencil:TStencil,m:Int,o:Int=1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set stencil render modes.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>M is stencil action mode for glStencilOp in range -2..2 where 1 is INCR (default),
2 is INCR for stencil shadow meshes and negative values are DECR. O is comparison operator for
glStencilFunc in range 0..3 which stands for one of NOTEQUAL, EQUAL, LEQUAL or GEQUAL.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=StringPtr>
<tr><td class=doctop colspan=2>Function StringPtr:String( inst:Byte Ptr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns string cast of byte pointer.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SurfsRendered>
<tr><td class=doctop colspan=2>Function SurfsRendered:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Number of surfaces currently being rendered.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TerrainCountTriangles>
<tr><td class=doctop colspan=2>Function TerrainCountTriangles( terr:TTerrain )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns terrain triangles count.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TerrainCountVertices>
<tr><td class=doctop colspan=2>Function TerrainCountVertices( terr:TTerrain )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns terrain vertices count.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TerrainDetail>
<tr><td class=doctop colspan=2>Function TerrainDetail( terr:TTerrain,detail_level:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set terrain level of detail, default is 100 and maximum is 2000.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TerrainHeight>
<tr><td class=doctop colspan=2>Function TerrainHeight:Float( terr:TTerrain,x:Int,z:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the height of the terrain at terrain grid coordinates x.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
terrain - terrain handle
<p>
grid_x - grid x coordinate of terrain
<p>
grid_z - grid z coordinate of terrain
<p>
<b>Description</b>:
<p>
Returns the height of the terrain at terrain grid coordinates x,z. The value  returned is in the range 0 to 1.
<p>
See also: <a href=#TerrainY>TerrainY</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TerrainScaleTexCoords>
<tr><td class=doctop colspan=2>Function TerrainScaleTexCoords( terr:TTerrain,u_scale:Float,v_scale:Float,coords_set:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set terrain texture coordinates scale, range is 1 to terrain size.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TerrainX>
<tr><td class=doctop colspan=2>Function TerrainX:Float( terr:TTerrain,x:Float,y:Float,z:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the interpolated x coordinate on a terrain.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
terrain - terrain handle
<p>
x# - world x coordinate
<p>
y# - world y coordinate
<p>
z# - world z coordinate
<p>
<b>Description</b>:
<p>
Returns the interpolated x coordinate on a terrain.
<p>
See also: <a href=#TerrainY>TerrainY</a>, <a href=#TerrainZ>TerrainZ</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TerrainY>
<tr><td class=doctop colspan=2>Function TerrainY:Float( terr:TTerrain,x:Float,y:Float,z:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the interpolated y coordinate on a terrain.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
terrain - terrain handle
<p>
x# - world x coordinate
<p>
y# - world y coordinate
<p>
z# - world z coordinate
<p>
<b>Description</b>:
<p>
Returns the interpolated y coordinate on a terrain.
<p>
Gets the ground's  height, basically.
<p>
See also: <a href=#TerrainX>TerrainX</a>, <a href=#TerrainZ>TerrainZ</a>, <a href=#TerrainHeight>TerrainHeight</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TerrainZ>
<tr><td class=doctop colspan=2>Function TerrainZ:Float( terr:TTerrain,x:Float,y:Float,z:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the interpolated z coordinate on a terrain.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
terrain - terrain handle
<p>
x# - world x coordinate
<p>
y# - world y coordinate
<p>
z# - world z coordinate
<p>
<b>Description</b>:
<p>
Returns the interpolated z coordinate on a terrain.
<p>
See also: <a href=#TerrainX>TerrainX</a>, <a href=#TerrainY>TerrainY</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TexToBuffer>
<tr><td class=doctop colspan=2>Function TexToBuffer( tex:TTexture,buffer:Byte Ptr,frame:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy texture to a pixmap buffer, buffer must be a byte ptr.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TextureAnIsotropic>
<tr><td class=doctop colspan=2>Function TextureAnIsotropic( tex:TTexture,f:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set texture anisotropic factor, usually from 2-16.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TextureBlend>
<tr><td class=doctop colspan=2>Function TextureBlend( tex:TTexture,blend:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the blending mode for a texture.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
Texture - Texture handle.
<p>
Blend - Blend mode of texture.
<p>

<p>
0: Do not blend
<p>
1: No blend, or Alpha (alpha when texture loaded with alpha flag - not recommended  for multitexturing - see below)
<p>
2: Multiply (default)
<p>
3: Add
<p>
4: Dot3
<p>
5: Multiply 2
<p>
<b>Description</b>:
<p>
Sets the blending mode for a texture.
<p>
The texture blend mode determines how the texture will blend with the texture or polygon which is 'below' it. Texture 0 will blend with the polygons of the entity it is applied to. Texture 1 will blend with texture 0. Texture 2 will blend with texture 1. And so on.
<p>
Texture blending in Blitz effectively takes the highest order texture (the one with the highest index) and it blends with the texture below it, then that result to the texture directly below again, and so on until texture 0 which is blended with the polygons of the entity it is applied to and thus the world, depending on the <a href=#EntityBlend>EntityBlend</a> of the object.
<p>
Each of the blend modes are identical to their <a href=#EntityBlend>EntityBlend</a> counterparts.
<p>
In the case of multitexturing (more than one texture applied to an entity), it is not recommended you blend textures that have been loaded with the alpha flag, as this can cause unpredictable results on a variety of different graphics cards.
<p>
Use <a href=#EntityTexture>EntityTexture</a> to set the index number of a texture.
<p>
See also: <a href=#EntityBlend>EntityBlend</a>, <a href=#EntityTexture>EntityTexture</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TextureCoords>
<tr><td class=doctop colspan=2>Function TextureCoords( tex:TTexture,coords:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the texture coordinate mode for a texture.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
texture - name of texture
<p>
coords -
<p>
0: UV coordinates are from first UV set in vertices (default)
<p>
1: UV coordinates are from second UV set in vertices
<p>
<b>Description</b>:
<p>
Sets the texture coordinate mode for a texture.
<p>
This determines where  the UV values used to look up a texture come from.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TextureFilter>
<tr><td class=doctop colspan=2>Function TextureFilter( match_text:String,flags:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Adds a texture filter.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
match_text$ - text that, if found in texture filename, will activate certain  filters
<p>

flags - filter texture flags:
<p>
1: Color
<p>
2: Alpha
<p>
4: Masked
<p>
8: Mipmapped
<p>
16: Clamp U
<p>
32: Clamp V
<p>
64: Spherical reflection map
<p>
128:
<p>
256: Store texture in vram
<p>
512: Force the use of high color textures
<p>
<b>Description</b>:
<p>
Adds a texture filter. Any textures loaded that contain the text specified  by match_text$ will have the provided flags added.
<p>
This is mostly of use when loading a mesh.
<p>
By default, the following texture filter is used:
<p>
TextureFilter "",1+8
<p>
This means that all loaded textures will have color and be mipmapped by default.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TextureFlags>
<tr><td class=doctop colspan=2>Function TextureFlags( tex:TTexture,flags:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set texture flags, see LoadTexture for values.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TextureGLTexEnvf>
<tr><td class=doctop colspan=2>Function TextureGLTexEnvf( tex:TTexture,target:Int,pname:Int,param:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>GL equivalent, param is a float, limited to 12 calls per texture, experimental.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TextureGLTexEnvi>
<tr><td class=doctop colspan=2>Function TextureGLTexEnvi( tex:TTexture,target:Int,pname:Int,param:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>GL equivalent, param is a const, limited to 12 calls per texture, experimental.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TextureHeight>
<tr><td class=doctop colspan=2>Function TextureHeight:Int( tex:TTexture )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the height of a texture.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
texture - texture handle
<p>
<b>Description</b>:
<p>
Returns the height of a texture.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TextureMultitex>
<tr><td class=doctop colspan=2>Function TextureMultitex( tex:TTexture,f:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set texture multitex factor, used in interpolate and custom TexBlend options.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TextureName>
<tr><td class=doctop colspan=2>Function TextureName:String( tex:TTexture )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a texture's absolute filename.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
texture - a valid texture handle
<p>
<b>Description</b>:
<p>
Returns a texture's absolute filename.
<p>
To find out just the name of the texture, you will need to parse the string returned by TextureName. One such function to do this is:
<p>
; start of code
Function StripPath$(file$)
<p>
If Len(file$)>0
<p>
For i=Len(file$) To 1 Step -1
<p>
mi$=Mid$(file$,i,1)
If mi$="\" Or mi$="/" Then Return name$ Else name$=mi$+name$
<p>
Next
<p>
EndIf
<p>
Return name$
<p>
End Function
; end of code
<p>
See also: <a href=#GetBrushTexture>GetBrushTexture</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TextureWidth>
<tr><td class=doctop colspan=2>Function TextureWidth:Int( tex:TTexture )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the width of a texture.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
texture - texture handle
<p>
<b>Description</b>:
<p>
Returns the width of a texture.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TFormedX>
<tr><td class=doctop colspan=2>Function TFormedX:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the X component of the last TFormPoint.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the X component of the last TFormPoint, TFormVector or TFormNormal  operation.
<p>
See those commands for examples.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TFormedY>
<tr><td class=doctop colspan=2>Function TFormedY:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the Y component of the last TFormPoint.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the Y component of the last TFormPoint, TFormVector or TFormNormal  operation.
<p>
See those commands for examples.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TFormedZ>
<tr><td class=doctop colspan=2>Function TFormedZ:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the Z component of the last TFormPoint.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the Z component of the last TFormPoint,  TFormVector or TFormNormal operation.
<p>
See those commands for examples.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TFormNormal>
<tr><td class=doctop colspan=2>Function TFormNormal( x:Float,y:Float,z:Float,src_ent:TEntity,dest_ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Transforms between coordinate systems.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
x#, y#, z# = components of a vector in 3d space
<p>

source_entity = handle of source entity, or 0 for 3d world
<p>
dest_entity = handle of destination entity, or 0 for 3d world
<p>
<b>Description</b>:
<p>
Transforms between coordinate systems. After using TFormNormal the new
components can be read with TFormedX(), TFormedY() and TFormedZ().
<p>
This is exactly the same as TFormVector but with one added feature.
After the transformation the new vector is 'normalized', meaning it
is scaled to have length 1.
<p>
For example, suppose the result of TFormVector is (1,2,2).
This vector has length Sqr( 1*1 + 2*2 + 2*2 ) = Sqr( 9 ) = 3.
<p>
This means TFormNormal would produce ( 1/3, 2/3, 2/3 ).</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TFormPoint>
<tr><td class=doctop colspan=2>Function TFormPoint( x:Float,y:Float,z:Float,src_ent:TEntity,dest_ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Transforms between coordinate systems.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
x#, y#, z# = coordinates of a point in 3d space
<p>

source_entity = handle of source entity, or 0 for 3d world
<p>
dest_entity = handle of destination entity, or 0 for 3d world
<p>
<b>Description</b>:
<p>
Transforms between coordinate systems. After using TFormPoint the new
coordinates can be read with TFormedX(), TFormedY() and TFormedZ().
<p>

See EntityX() for details about local coordinates.
<p>
Consider a sphere built with CreateSphere(). The 'north pole' is at (0,1,0).
At first, local and global coordinates are the same. As the sphere is moved,
turned and scaled the global coordinates of the point change.
<p>
But it is always at (0,1,0) in the sphere's local space.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TFormVector>
<tr><td class=doctop colspan=2>Function TFormVector( x:Float,y:Float,z:Float,src_ent:TEntity,dest_ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Transforms between coordinate systems.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
x#, y#, z# = components of a vector in 3d space
<p>

source_entity = handle of source entity, or 0 for 3d world
<p>
dest_entity = handle of destination entity, or 0 for 3d world
<p>
<b>Description</b>:
<p>
Transforms between coordinate systems. After using TFormVector the new
components can be read with TFormedX(), TFormedY() and TFormedZ().
<p>

See EntityX() for details about local coordinates.
<p>

Similar to TFormPoint, but operates on a vector. A vector can be thought of
as 'displacement relative to current location'.
<p>
For example, vector (1,2,3) means one step to the right, two steps up
and three steps forward.
<p>
This is analogous to PositionEntity and MoveEntity:
<p>
PositionEntity entity, x,y,z   ; put entity at point (x,y,z)
<p>
MoveEntity entity, x,y,z       ; add vector (x,y,z) to current position.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TranslateEntity>
<tr><td class=doctop colspan=2>Function TranslateEntity( ent:TEntity,x:Float,y:Float,z:Float,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Translates an entity relative to its current position and not its  orientation.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - name of entity to be translated
<p>
x# - x amount that entity will be translated by
<p>
y# - y amount that entity will be translated by
<p>
z# - z amount that entity will be translated by
<p>
global (optional) -
<p>
<b>Description</b>:
<p>
Translates an entity relative to its current position and not its  orientation.
<p>
What this means is that an entity will move in a certain direction despite where it may be facing. Imagine that you have a game character that you want to make jump in the air at the same time as doing a triple somersault. Translating the character by a positive y amount will mean the character will always travel directly up in their air, regardless of where it may be facing due to the somersault action.
<p>
See also: <a href=#MoveEntity>MoveEntity</a>, <a href=#PositionEntity>PositionEntity</a>, <a href=#PositionMesh>PositionMesh</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TriangleVertex>
<tr><td class=doctop colspan=2>Function TriangleVertex:Int( surf:TSurface,tri_no:Int,corner:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the vertex of a triangle corner.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
triangle_index - triangle index
<p>
corner - corner of triangle. Should be 0, 1 or 2.
<p>
<b>Description</b>:
<p>
Returns the vertex of a triangle corner.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TrisRendered>
<tr><td class=doctop colspan=2>Function TrisRendered:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Number of triangles currently being rendered.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TurnEntity>
<tr><td class=doctop colspan=2>Function TurnEntity( ent:TEntity,x:Float,y:Float,z:Float,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Turns an entity relative to its current orientation.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - name of entity to be rotated
<p>
pitch# - angle in degrees that entity will be pitched
<p>
yaw# - angle in degrees that entity will be yawed
<p>
roll# - angle in degrees that entity will be rolled
<p>
global (optional) -
<p>
<b>Description</b>:
<p>
Turns an entity relative to its current orientation.
<p>
Pitch is the same as the x angle of an entity, and is equivalent to tilting forward/backwards.
<p>
Yaw is the same as the y angle of an entity, and is equivalent to turning left/right.
<p>
Roll is the same as the z angle of an entity, and is equivalent to tilting left/right.
<p>
See also: <a href=#RotateEntity>RotateEntity</a>, <a href=#RotateMesh>RotateMesh</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UpdateNormals>
<tr><td class=doctop colspan=2>Function UpdateNormals( mesh:TMesh )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Recalculates all normals in a mesh.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
<b>Description</b>:
<p>
Recalculates all normals in a mesh. This is necessary for correct lighting  if you have not set surface normals using 'VertexNormals' commands.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UpdateTexCoords>
<tr><td class=doctop colspan=2>Function UpdateTexCoords( surf:TSurface )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Recalculates the surface's uvw coord set 1 based on vertices.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UpdateWorld>
<tr><td class=doctop colspan=2>Function UpdateWorld( anim_speed:Float=1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Animates all entities in the world.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
anim_speed# (optional) - a master control for animation speed. Defaults  to 1.
<p>
<b>Description</b>:
<p>
Animates all entities in the world, and performs collision checking.
<p>
The  optional anim_speed# parameter allows you affect the animation speed of all  entities at once. A value of 1 will animate entities at their usual animation  speed, a value of 2 will animate entities at double their animation speed, and  so on.
<p>
For best results use this command once per main loop, just before calling RenderWorld.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseAssimpStreamMeshes>
<tr><td class=doctop colspan=2>Function UseAssimpStreamMeshes( flag:Int=True,meshflags:Int=-1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Loader flags for Assimp meshes.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Set flag to False to use Assimp direct loaders, default is True for Assimp streamed loaders.
Set meshflags to -1 for smooth normals, -2 for flat shaded normals and -4 to load as single mesh.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseCubemapFlip>
<tr><td class=doctop colspan=2>Function UseCubemapFlip( flag:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Flip cubemap texture flag.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Set flag to True to flip cubemap textures, default is False to not flip (invert).</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseEntity>
<tr><td class=doctop colspan=2>Function UseEntity( material:TShader,name:String,ent:TEntity,mode:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>undocumented.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseFloat>
<tr><td class=doctop colspan=2>Function UseFloat( material:TShader,name:String,v1:Float Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Bind a float variable to a shader variable name of a uniform float type.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseFloat2>
<tr><td class=doctop colspan=2>Function UseFloat2( material:TShader,name:String,v1:Float Var,v2:Float Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Bind 2 float variables to a shader variable name of a uniform vec2 Type.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseFloat3>
<tr><td class=doctop colspan=2>Function UseFloat3( material:TShader,name:String,v1:Float Var,v2:Float Var,v3:Float Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Bind 3 float variables to a shader variable name of a uniform vec3 type.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseFloat4>
<tr><td class=doctop colspan=2>Function UseFloat4( material:TShader,name:String,v1:Float Var,v2:Float Var,v3:Float Var,v4:Float Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Bind 4 float variables to a shader variable name of a uniform vec4 type.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseInteger>
<tr><td class=doctop colspan=2>Function UseInteger( material:TShader,name:String,v1:Int Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Bind an integer variable to a shader variable name of a uniform int type.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseInteger2>
<tr><td class=doctop colspan=2>Function UseInteger2( material:TShader,name:String,v1:Int Var,v2:Int Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Bind 2 integer variables to a shader variable name of a uniform ivec2 type.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseInteger3>
<tr><td class=doctop colspan=2>Function UseInteger3( material:TShader,name:String,v1:Int Var,v2:Int Var,v3:Int Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Bind 3 integer variables to a shader variable name of a uniform ivec3 type.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseInteger4>
<tr><td class=doctop colspan=2>Function UseInteger4( material:TShader,name:String,v1:Int Var,v2:Int Var,v3:Int Var,v4:Int Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Bind 4 integer variables to a shader variable name of a uniform ivec4 type.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseLibraryMeshes>
<tr><td class=doctop colspan=2>Function UseLibraryMeshes( flag:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Loader flag for meshes.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Set flag to False for Blitzmax streamed loaders, default is True for Openb3d library direct loaders.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseLibraryTextures>
<tr><td class=doctop colspan=2>Function UseLibraryTextures( flag:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Loader flag for textures.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Set flag to False for Blitzmax streamed loaders, default is True for Openb3d library direct loaders.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseMatrix>
<tr><td class=doctop colspan=2>Function UseMatrix( material:TShader,name:String,Mode:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sends matrix data to a shader variable name of a uniform mat4 type.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseMatrix3DS>
<tr><td class=doctop colspan=2>Function UseMatrix3DS( xx#,xy#,xz#,yx#,yy#,yz#,zx#,zy#,zz# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set 3DS model loader coordinates system (matrix), values should be 0,1,-1.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseMatrixMD2>
<tr><td class=doctop colspan=2>Function UseMatrixMD2( xx#,xy#,xz#,yx#,yy#,yz#,zx#,zy#,zz# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set MD2 model loader coordinates system (matrix), values should be 0,1,-1.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseMeshDebugLog>
<tr><td class=doctop colspan=2>Function UseMeshDebugLog( flag:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Debug all mesh loaders.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Set flag to False to not debug Blitzmax mesh loaders, default is True to enable debug log.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseMeshTextureFlags>
<tr><td class=doctop colspan=2>Function UseMeshTextureFlags( texflags:Int=-1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set mesh texture flags.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Override mesh texture flags manually, default is -1 (only for 3DS and OBJ).</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseMeshTransform>
<tr><td class=doctop colspan=2>Function UseMeshTransform( flag:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Transform mesh loaders.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Set flag to False to not transform meshes, default is True to enable transforms (Blitzmax 3DS only).</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseStencil>
<tr><td class=doctop colspan=2>Function UseStencil( stencil:TStencil )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Stencil to use, set to Null to disable stencil.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseSurface>
<tr><td class=doctop colspan=2>Function UseSurface( material:TShader,name:String,surf:TSurface,vbo:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sends surface data to a shader variable name.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Vbo is in range 1..6 which selects what vertex buffer data to access, where 1 is vertex positions,
2/3 is tex coords 0/1, 4 is vertex normals, 5 is vertex color, 6 is triangles.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseTextureFaces>
<tr><td class=doctop colspan=2>Function UseTextureFaces( lf0:Int=0,fr1:Int=0,rt2:Int=0,bk3:Int=0,dn4:Int=0,up5:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Order for cubemap faces.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Define the order to load cubemap faces, default is 0,1,2,3,4,5 (B3D layout).</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseTextureFrames>
<tr><td class=doctop colspan=2>Function UseTextureFrames( lf0:Int=0,fr1:Int=0,rt2:Int=0,bk3:Int=0,dn4:Int=0,up5:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Order for anim texture frames.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Define the order to load anim texture frames, default is 0,1,2,3,4,5.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VectorPitch>
<tr><td class=doctop colspan=2>Function VectorPitch:Float( vx:Float,vy:Float,vz:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the pitch value of a vector.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
x# - x vector length
<p>
y# - y vector length
<p>
z# - z vector length
<p>
<b>Description</b>:
<p>
Returns the pitch value of a vector.
<p>
Using this command will return the same result as using <a href=#EntityPitch>EntityPitch</a> to get the pitch value of an entity that is pointing in the vector's direction.
<p>
See also: <a href=#VectorYaw>VectorYaw</a>, <a href=#EntityPitch>EntityPitch</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VectorYaw>
<tr><td class=doctop colspan=2>Function VectorYaw:Float( vx:Float,vy:Float,vz:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the yaw value of a vector.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
x# - x vector length
<p>
y# - y vector length
<p>
z# - z vector length
<p>
<b>Description</b>:
<p>
Returns the yaw value of a vector.
<p>
Using this command will return the same result as using <a href=#EntityYaw>EntityYaw</a> to get the yaw value of an entity that is pointing in the vector's direction.
<p>
See also: <a href=#VectorPitch>VectorPitch</a>, <a href=#EntityYaw>EntityYaw</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexAlpha>
<tr><td class=doctop colspan=2>Function VertexAlpha:Float( surf:TSurface,vid:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the alpha component of a vertices color.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
<b>Description</b>:
<p>
Returns the alpha component of a vertices color, set using <a href=#VertexColor>VertexColor</a>
<p>
See also: <a href=#VertexRed>VertexRed</a>, <a href=#VertexGreen>VertexGreen</a>, <a href=#VertexBlue>VertexBlue</a>, <a href=#VertexColor>VertexColor</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexBlue>
<tr><td class=doctop colspan=2>Function VertexBlue:Float( surf:TSurface,vid:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the blue component of a vertices color.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
<b>Description</b>:
<p>
Returns the blue component of a vertices color.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexColor>
<tr><td class=doctop colspan=2>Function VertexColor( surf:TSurface,vid:Int,r:Float,g:Float,b:Float,a:Float=1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the color of an existing vertex.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
red# - red value of vertex
<p>
green# - green value of vertex
<p>
blue# - blue value of vertex
<p>
alpha# - optional alpha transparency of vertex (0.0 to 1.0 - default: 1.0)
<p>
<b>Description</b>:
<p>
Sets the color of an existing vertex.
<p>
NB. If you want to set the alpha individually for vertices using the alpha# parameter then you need to use EntityFX 32 (to force alpha-blending) on the entity.
<p>
See also: <a href=#EntityFX>EntityFX</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexCoords>
<tr><td class=doctop colspan=2>Function VertexCoords( surf:TSurface,vid:Int,x:Float,y:Float,z:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the geometric coordinates of an existing vertex.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
x# - x position of vertex
<p>
y# - y position of vertex
<p>
z# - z position of vertex
<p>
<b>Description</b>:
<p>
Sets the geometric coordinates of an existing vertex.
<p>
This is the command  used to perform what is commonly referred to as 'dynamic mesh deformation'.  It will reposition a vertex so that all the triangle edges connected to it,  will move also. This will give the effect of parts of the mesh suddenly deforming.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexGreen>
<tr><td class=doctop colspan=2>Function VertexGreen:Float( surf:TSurface,vid:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the green component of a vertices color.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
<b>Description</b>:
<p>
Returns the green component of a vertices color.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexNormal>
<tr><td class=doctop colspan=2>Function VertexNormal( surf:TSurface,vid:Int,nx:Float,ny:Float,nz:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the normal of an existing vertex.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
nx# - normal x of vertex
<p>
ny# - normal y of vertex
<p>
nz# - normal z of vertex
<p>
<b>Description</b>:
<p>
Sets the normal of an existing vertex.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexNX>
<tr><td class=doctop colspan=2>Function VertexNX:Float( surf:TSurface,vid:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the x component of a vertices normal.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
<b>Description</b>:
<p>
Returns the x component of a vertices normal.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexNY>
<tr><td class=doctop colspan=2>Function VertexNY:Float( surf:TSurface,vid:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the y component of a vertices normal.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
<b>Description</b>:
<p>
Returns the y component of a vertices normal.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexNZ>
<tr><td class=doctop colspan=2>Function VertexNZ:Float( surf:TSurface,vid:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the z component of a vertices normal.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
<b>Description</b>:
<p>
Returns the z component of a vertices normal.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexRed>
<tr><td class=doctop colspan=2>Function VertexRed:Float( surf:TSurface,vid:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the red component of a vertices color.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
<b>Description</b>:
<p>
Returns the red component of a vertices color.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexTexCoords>
<tr><td class=doctop colspan=2>Function VertexTexCoords( surf:TSurface,vid:Int,u:Float,v:Float,w:Float=0,coord_set:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the texture coordinates of an existing vertex.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
u# - u# coordinate of vertex
<p>
v# - v# coordinate of vertex
<p>
w# (optional) - w# coordinate of vertex
<p>
coord_set (optional) - co_oord set. Should be set to 0 or 1.
<p>
<b>Description</b>:
<p>
Sets the texture coordinates of an existing vertex.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexU>
<tr><td class=doctop colspan=2>Function VertexU:Float( surf:TSurface,vid:Int,coord_set:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the texture u coordinate of a vertex.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
coord_set (optional) - UV mapping coordinate set. Should be set to 0 or 1.
<p>
<b>Description</b>:
<p>
Returns the texture u coordinate of a vertex.
<p>
See also: <a href=#VertexV>VertexV</a>,</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexV>
<tr><td class=doctop colspan=2>Function VertexV:Float( surf:TSurface,vid:Int,coord_set:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the texture v coordinate of a vertex.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
coord_set (optional) - UV mapping coordinate set. Should be set to 0 or 1.
<p>
<b>Description</b>:
<p>
Returns the texture v coordinate of a vertex.
<p>
See also: <a href=#VertexU>VertexU</a>,</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexW>
<tr><td class=doctop colspan=2>Function VertexW:Float( surf:TSurface,vid:Int,coord_set:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the texture w coordinate of a vertex.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
<b>Description</b>:
<p>
Returns the texture w coordinate of a vertex.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexX>
<tr><td class=doctop colspan=2>Function VertexX:Float( surf:TSurface,vid:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the x coordinate of a vertex.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
<b>Description</b>:
<p>
Returns the x coordinate of a vertex.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexY>
<tr><td class=doctop colspan=2>Function VertexY:Float( surf:TSurface,vid:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the y coordinate of a vertex.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
<b>Description</b>:
<p>
Returns the y coordinate of a vertex.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexZ>
<tr><td class=doctop colspan=2>Function VertexZ:Float( surf:TSurface,vid:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the z coordinate of a vertex.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
<b>Description</b>:
<p>
Returns the z coordinate of a vertex.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertsRendered>
<tr><td class=doctop colspan=2>Function VertsRendered:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Number of vertices currently being rendered.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VoxelSpriteMaterial>
<tr><td class=doctop colspan=2>Function VoxelSpriteMaterial( voxelspr:TVoxelSprite,mat:TMaterial )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set material for voxel sprite.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=Wireframe>
<tr><td class=doctop colspan=2>Function Wireframe( enable:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enables or disables wireframe rendering.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
enable - True to enable wireframe rendering, False to disable.
<p>

The default  Wireframe mode is False.
<p>
<b>Description</b>:
<p>
Enables or disables wireframe rendering.
<p>
This will show the outline of  each polygon on the screen, with no shaded-in areas.
<p>
Wireframe mode should only be used for debugging purposes, as driver support  is patchy. For the same reason, no support is offered for the wireframe rendering  of individual polygon entities.</td></tr>
</table>
<br>
<h2
 id=typesdet>Types
</h2>
<table class=doc width=100% cellspacing=3 id=TAction>
<tr><td class=doctop colspan=2>Type TAction</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Action.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TAnimationKeys>
<tr><td class=doctop colspan=2>Type TAnimationKeys</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>AnimationKeys data.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TBlitz2D>
<tr><td class=doctop colspan=2>Type TBlitz2D</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Blitz2D.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TBlob>
<tr><td class=doctop colspan=2>Type TBlob Extends TEntity</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Blob entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TBone>
<tr><td class=doctop colspan=2>Type TBone Extends TEntity</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Bone entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TBrush>
<tr><td class=doctop colspan=2>Type TBrush</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Brush.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TCamera>
<tr><td class=doctop colspan=2>Type TCamera Extends TEntity</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Camera entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TConstraint>
<tr><td class=doctop colspan=2>Type TConstraint</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Constraint.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TEntity>
<tr><td class=doctop colspan=2>Type TEntity</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TFluid>
<tr><td class=doctop colspan=2>Type TFluid Extends TMesh</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Fluid mesh entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TGeosphere>
<tr><td class=doctop colspan=2>Type TGeosphere Extends TTerrain</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Geosphere terrain entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TGlobal3D>
<tr><td class=doctop colspan=2>Type TGlobal3D</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Global.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Renamed to fix conflict with BRL.Reflection.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=THardwareInfo>
<tr><td class=doctop colspan=2>Type THardwareInfo ' by klepto2</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Hardware info.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Contains <b>Function GetInfo()</b> And <b>DisplayInfo(LogFile:Int=False)</b>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TLight>
<tr><td class=doctop colspan=2>Type TLight Extends TEntity</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Light entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TMaterial>
<tr><td class=doctop colspan=2>Type TMaterial Extends TTexture</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Material texture.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TMatPtr>
<tr><td class=doctop colspan=2>Type TMatPtr</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>MatPtr functions (Openb3d)</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TMatPtr_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#Copy>Copy</a></td><td class=docright>
Copy self, returns a new matrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#FromQuaternion>FromQuaternion</a></td><td class=docright>
Convert self to a rotation matrix from a quaternion.
</td></tr>
<tr><td class=docleft width=1%><a href=#FromToRotation>FromToRotation</a></td><td class=docright>
Transformation self to a rotation matrix from two given vectors.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetInverse>GetInverse</a></td><td class=docright>
Get inverse of the given TMatPtr and overwrite it, returns nothing.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetInverse2>GetInverse2</a></td><td class=docright>
Get inverse of the given TMatPtr and overwrite it, returns nothing (used in collision2.cpp)
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMatrix>GetMatrix</a></td><td class=docright>
Overwrite self with the given TMatrix, returns nothing (like CopyMatrix)
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMatrixScale>GetMatrixScale</a></td><td class=docright>
Get scale (magnitude) of self, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetPitch>GetPitch</a></td><td class=docright>
Returns pitch of self.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetRoll>GetRoll</a></td><td class=docright>
Returns roll of self.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetYaw>GetYaw</a></td><td class=docright>
Returns yaw of self.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadIdentity>LoadIdentity</a></td><td class=docright>
Set self as identity matrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#Multiply>Multiply</a></td><td class=docright>
Multiply self by the given matrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#Multiply2>Multiply2</a></td><td class=docright>
Multiply self by the given matrix (same as Multiply)
</td></tr>
<tr><td class=docleft width=1%><a href=#Overwrite>Overwrite</a></td><td class=docright>
Overwrite self with the given TMatPtr.
</td></tr>
<tr><td class=docleft width=1%><a href=#Rotate>Rotate</a></td><td class=docright>
Rotate self by pitch, yaw, roll (Euler degrees)
</td></tr>
<tr><td class=docleft width=1%><a href=#RotatePitch>RotatePitch</a></td><td class=docright>
Rotate self about the x axis (Euler degrees)
</td></tr>
<tr><td class=docleft width=1%><a href=#RotateRoll>RotateRoll</a></td><td class=docright>
Rotate self about the z axis (Euler degrees)
</td></tr>
<tr><td class=docleft width=1%><a href=#RotateYaw>RotateYaw</a></td><td class=docright>
Rotate self about the y axis (Euler degrees)
</td></tr>
<tr><td class=docleft width=1%><a href=#Scale>Scale</a></td><td class=docright>
Scale self (set the diagonal elements to x, y, z)
</td></tr>
<tr><td class=docleft width=1%><a href=#SetIdentity>SetIdentity</a></td><td class=docright>
Set matrix identity.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetTranslate>SetTranslate</a></td><td class=docright>
Set translate vector for self.
</td></tr>
<tr><td class=docleft width=1%><a href=#ToQuat>ToQuat</a></td><td class=docright>
Convert self to the given quaternion.
</td></tr>
<tr><td class=docleft width=1%><a href=#TransformVec>TransformVec</a></td><td class=docright>
Transform the given vector by self.
</td></tr>
<tr><td class=docleft width=1%><a href=#Translate>Translate</a></td><td class=docright>
Translate (move) self by the given vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Transpose>Transpose</a></td><td class=docright>
Transpose self.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TMatPtr_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#CopyMatrix>CopyMatrix</a></td><td class=docright>
Copy the given TMatrix, returns a new Float Ptr matrix (like GetMatrix)
</td></tr>
<tr><td class=docleft width=1%><a href=#Create>Create</a></td><td class=docright>
Creates a new TMatPtr object, returns a Float Ptr matrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#InterpolateMatrix>InterpolateMatrix</a></td><td class=docright>
Interpolate two TMatPtrs by a relative value (used in AlignToVector)
</td></tr>
<tr><td class=docleft width=1%><a href=#Magnitude>Magnitude</a></td><td class=docright>
Return magnitude (length) of the given vector, returns a float.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewMatPtr>NewMatPtr</a></td><td class=docright>
Returns a new TMatPtr object.
</td></tr>
<tr><td class=docleft width=1%><a href=#Quaternion_FromAngleAxis>Quaternion_FromAngleAxis</a></td><td class=docright>
Create a quaternion from an angle and an axis, sets the given quaternion.
</td></tr>
<tr><td class=docleft width=1%><a href=#Quaternion_MultiplyQuat>Quaternion_MultiplyQuat</a></td><td class=docright>
Multiply two quaternions, sets the given quaternion.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Copy>
<tr><td class=doctop colspan=2>Method Copy:TMatPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy self, returns a new matrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=FromQuaternion>
<tr><td class=doctop colspan=2>Method FromQuaternion( x:Float,y:Float,z:Float,w:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Convert self to a rotation matrix from a quaternion.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=FromToRotation>
<tr><td class=doctop colspan=2>Method FromToRotation( ix:Float,iy:Float,iz:Float,jx:Float,jy:Float,jz:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Transformation self to a rotation matrix from two given vectors.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetInverse>
<tr><td class=doctop colspan=2>Method GetInverse( mat:TMatPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get inverse of the given TMatPtr and overwrite it, returns nothing.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetInverse2>
<tr><td class=doctop colspan=2>Method GetInverse2( mat:TMatPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get inverse of the given TMatPtr and overwrite it, returns nothing (used in collision2.cpp)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMatrix>
<tr><td class=doctop colspan=2>Method GetMatrix:TMatPtr( mat:TMatrix )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Overwrite self with the given TMatrix, returns nothing (like CopyMatrix)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMatrixScale>
<tr><td class=doctop colspan=2>Method GetMatrixScale:TVecPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get scale (magnitude) of self, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetPitch>
<tr><td class=doctop colspan=2>Method GetPitch:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns pitch of self.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetRoll>
<tr><td class=doctop colspan=2>Method GetRoll:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns roll of self.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetYaw>
<tr><td class=doctop colspan=2>Method GetYaw:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns yaw of self.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=LoadIdentity>
<tr><td class=doctop colspan=2>Method LoadIdentity()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set self as identity matrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Multiply>
<tr><td class=doctop colspan=2>Method Multiply( mat:TMatPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Multiply self by the given matrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Multiply2>
<tr><td class=doctop colspan=2>Method Multiply2( mat:TMatPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Multiply self by the given matrix (same as Multiply)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Overwrite>
<tr><td class=doctop colspan=2>Method Overwrite( mat:TMatPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Overwrite self with the given TMatPtr.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Rotate>
<tr><td class=doctop colspan=2>Method Rotate( rx:Float,ry:Float,rz:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotate self by pitch, yaw, roll (Euler degrees)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=RotatePitch>
<tr><td class=doctop colspan=2>Method RotatePitch( ang:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotate self about the x axis (Euler degrees)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=RotateRoll>
<tr><td class=doctop colspan=2>Method RotateRoll( ang:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotate self about the z axis (Euler degrees)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=RotateYaw>
<tr><td class=doctop colspan=2>Method RotateYaw( ang:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotate self about the y axis (Euler degrees)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Scale>
<tr><td class=doctop colspan=2>Method Scale( x:Float,y:Float,z:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Scale self (set the diagonal elements to x, y, z)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetIdentity>
<tr><td class=doctop colspan=2>Method SetIdentity( xx#,xy#,xz#,yx#,yy#,yz#,zx#,zy#,zz# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set matrix identity.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetTranslate>
<tr><td class=doctop colspan=2>Method SetTranslate( x:Float,y:Float,z:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set translate vector for self.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=ToQuat>
<tr><td class=doctop colspan=2>Method ToQuat( qx:Float Var,qy:Float Var,qz:Float Var,qw:Float Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Convert self to the given quaternion.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=TransformVec>
<tr><td class=doctop colspan=2>Method TransformVec( rx:Float Var,ry:Float Var,rz:Float Var,addTranslation:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Transform the given vector by self.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Translate>
<tr><td class=doctop colspan=2>Method Translate( x:Float,y:Float,z:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Translate (move) self by the given vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Transpose>
<tr><td class=doctop colspan=2>Method Transpose()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Transpose self.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CopyMatrix>
<tr><td class=doctop colspan=2>Function CopyMatrix:TMatPtr( mat:TMatrix )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy the given TMatrix, returns a new Float Ptr matrix (like GetMatrix)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Create>
<tr><td class=doctop colspan=2>Function Create:TMatPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a new TMatPtr object, returns a Float Ptr matrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=InterpolateMatrix>
<tr><td class=doctop colspan=2>Function InterpolateMatrix( m:TMatPtr,a:TMatPtr,alpha:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Interpolate two TMatPtrs by a relative value (used in AlignToVector)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Magnitude>
<tr><td class=doctop colspan=2>Function Magnitude:Float( x:Float,y:Float,z:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Return magnitude (length) of the given vector, returns a float.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=NewMatPtr>
<tr><td class=doctop colspan=2>Function NewMatPtr:TMatPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a new TMatPtr object.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Quaternion_FromAngleAxis>
<tr><td class=doctop colspan=2>Function Quaternion_FromAngleAxis( angle:Float,ax:Float,ay:Float,az:Float,rx:Float Var,ry:Float Var,rz:Float Var,rw:Float Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a quaternion from an angle and an axis, sets the given quaternion.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Quaternion_MultiplyQuat>
<tr><td class=doctop colspan=2>Function Quaternion_MultiplyQuat( x1:Float,y1:Float,z1:Float,w1:Float,x2:Float,y2:Float,z2:Float,w2:Float,rx:Float Var,ry:Float Var,rz:Float Var,rw:Float Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Multiply two quaternions, sets the given quaternion.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TMatrix>
<tr><td class=doctop colspan=2>Type TMatrix</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Matrix functions (Minib3d)</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TMatrix_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#Copy>Copy</a></td><td class=docright>
Copy self, returns a new matrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMatPtr>GetMatPtr</a></td><td class=docright>
Overwrite self with the given TMatPtr, returns nothing (like CopyMatPtr)
</td></tr>
<tr><td class=docleft width=1%><a href=#Inverse>Inverse</a></td><td class=docright>
Get inverse of self, returns a new matrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadIdentity>LoadIdentity</a></td><td class=docright>
Set self as identity matrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#Multiply>Multiply</a></td><td class=docright>
Multiply self by the given matrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#New>New</a></td><td class=docright>
Returns a new TMatrix object.
</td></tr>
<tr><td class=docleft width=1%><a href=#Overwrite>Overwrite</a></td><td class=docright>
Overwrite self with the given TMatrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#Rotate>Rotate</a></td><td class=docright>
Rotate self by yaw, pitch and roll (Euler degrees)
</td></tr>
<tr><td class=docleft width=1%><a href=#RotatePitch>RotatePitch</a></td><td class=docright>
Rotate self about the x axis (Euler degrees)
</td></tr>
<tr><td class=docleft width=1%><a href=#RotateRoll>RotateRoll</a></td><td class=docright>
Rotate self about the z axis (Euler degrees)
</td></tr>
<tr><td class=docleft width=1%><a href=#RotateYaw>RotateYaw</a></td><td class=docright>
Rotate self about the y axis (Euler degrees)
</td></tr>
<tr><td class=docleft width=1%><a href=#Scale>Scale</a></td><td class=docright>
Scale self (set the diagonal elements to x, y, z)
</td></tr>
<tr><td class=docleft width=1%><a href=#SetIdentity>SetIdentity</a></td><td class=docright>
Set matrix identity.
</td></tr>
<tr><td class=docleft width=1%><a href=#Translate>Translate</a></td><td class=docright>
Translate (move) self.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TMatrix_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#CopyMatPtr>CopyMatPtr</a></td><td class=docright>
Copy the given TMatPtr, returns a new Float matrix (like GetMatPtr)
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Copy>
<tr><td class=doctop colspan=2>Method Copy:TMatrix()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy self, returns a new matrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMatPtr>
<tr><td class=doctop colspan=2>Method GetMatPtr:TMatrix( mat:TMatPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Overwrite self with the given TMatPtr, returns nothing (like CopyMatPtr)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Inverse>
<tr><td class=doctop colspan=2>Method Inverse:TMatrix()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get inverse of self, returns a new matrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=LoadIdentity>
<tr><td class=doctop colspan=2>Method LoadIdentity()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set self as identity matrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Multiply>
<tr><td class=doctop colspan=2>Method Multiply( mat:TMatrix )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Multiply self by the given matrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=New>
<tr><td class=doctop colspan=2>Method New()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a new TMatrix object.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Overwrite>
<tr><td class=doctop colspan=2>Method Overwrite( mat:TMatrix )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Overwrite self with the given TMatrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Rotate>
<tr><td class=doctop colspan=2>Method Rotate( rx#,ry#,rz# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotate self by yaw, pitch and roll (Euler degrees)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=RotatePitch>
<tr><td class=doctop colspan=2>Method RotatePitch( ang# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotate self about the x axis (Euler degrees)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=RotateRoll>
<tr><td class=doctop colspan=2>Method RotateRoll( ang# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotate self about the z axis (Euler degrees)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=RotateYaw>
<tr><td class=doctop colspan=2>Method RotateYaw( ang# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotate self about the y axis (Euler degrees)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Scale>
<tr><td class=doctop colspan=2>Method Scale( x#,y#,z# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Scale self (set the diagonal elements to x, y, z)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetIdentity>
<tr><td class=doctop colspan=2>Method SetIdentity( xx#,xy#,xz#,yx#,yy#,yz#,zx#,zy#,zz# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set matrix identity.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Translate>
<tr><td class=doctop colspan=2>Method Translate( x#,y#,z# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Translate (move) self.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CopyMatPtr>
<tr><td class=doctop colspan=2>Function CopyMatPtr:TMatrix( mat:TMatPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy the given TMatPtr, returns a new Float matrix (like GetMatPtr)</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TMesh>
<tr><td class=doctop colspan=2>Type TMesh Extends TEntity</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Mesh entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TMeshLoader>
<tr><td class=doctop colspan=2>Type TMeshLoader</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Mesh loader.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TMeshLoader_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#LoadAnimMesh>LoadAnimMesh</a></td><td class=docright>
Call animated mesh loader implementation.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadMesh>LoadMesh</a></td><td class=docright>
Call mesh loader implementation.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=LoadAnimMesh>
<tr><td class=doctop colspan=2>Method LoadAnimMesh:TMesh(file:TStream, url:Object, parent:TEntity = Null, flags:Int = -1) Abstract</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Call animated mesh loader implementation.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=LoadMesh>
<tr><td class=doctop colspan=2>Method LoadMesh:TMesh(file:TStream, url:Object, parent:TEntity = Null, flags:Int = -1) Abstract</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Call mesh loader implementation.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TOcTree>
<tr><td class=doctop colspan=2>Type TOcTree Extends TTerrain</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Octree terrain entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TParticleBatch>
<tr><td class=doctop colspan=2>Type TParticleBatch Extends TMesh</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Particle Batch mesh entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TParticleEmitter>
<tr><td class=doctop colspan=2>Type TParticleEmitter Extends TEntity</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Particle Emitter entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TPick>
<tr><td class=doctop colspan=2>Type TPick</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Pick.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TPivot>
<tr><td class=doctop colspan=2>Type TPivot Extends TEntity</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Pivot entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TPostFX>
<tr><td class=doctop colspan=2>Type TPostFX</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Post effects object.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TQuaternion>
<tr><td class=doctop colspan=2>Type TQuaternion</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Quaternion functions (Minib3d)</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TQuaternion_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetQuatPtr>GetQuatPtr</a></td><td class=docright>
Overwrite self with the given TQuatPtr, returns nothing (like CopyQuatPtr)
</td></tr>
<tr><td class=docleft width=1%><a href=#New>New</a></td><td class=docright>
Returns a new TQuaternion object.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TQuaternion_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#CopyQuatPtr>CopyQuatPtr</a></td><td class=docright>
Copy the given TQuatPtr, returns a new Float quaternion (like GetQuatPtr)
</td></tr>
<tr><td class=docleft width=1%><a href=#Create>Create</a></td><td class=docright>
Create a new TQuaternion from four float values, returns a Float quaternion.
</td></tr>
<tr><td class=docleft width=1%><a href=#QuatToEuler>QuatToEuler</a></td><td class=docright>
Convert a quaternion to the given pitch, yaw, roll (Euler degrees)
</td></tr>
<tr><td class=docleft width=1%><a href=#QuatToMat>QuatToMat</a></td><td class=docright>
Convert a quaternion to the given TMatrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#Slerp>Slerp</a></td><td class=docright>
Slerp two quaternions to the given quaternion.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetQuatPtr>
<tr><td class=doctop colspan=2>Method GetQuatPtr:TQuaternion( quat:TQuatPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Overwrite self with the given TQuatPtr, returns nothing (like CopyQuatPtr)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=New>
<tr><td class=doctop colspan=2>Method New()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a new TQuaternion object.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CopyQuatPtr>
<tr><td class=doctop colspan=2>Function CopyQuatPtr:TQuaternion( quat:TQuatPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy the given TQuatPtr, returns a new Float quaternion (like GetQuatPtr)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Create>
<tr><td class=doctop colspan=2>Function Create:TQuaternion( w:Float=0,x:Float=0,y:Float=0,z:Float=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TQuaternion from four float values, returns a Float quaternion.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=QuatToEuler>
<tr><td class=doctop colspan=2>Function QuatToEuler( w#,x#,y#,z#,pitch# Var,yaw# Var,roll# Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Convert a quaternion to the given pitch, yaw, roll (Euler degrees)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=QuatToMat>
<tr><td class=doctop colspan=2>Function QuatToMat( w#,x#,y#,z#,mat:TMatrix Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Convert a quaternion to the given TMatrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Slerp>
<tr><td class=doctop colspan=2>Function Slerp:Int( Ax#,Ay#,Az#,Aw#,Bx#,By#,Bz#,Bw#,Cx# Var,Cy# Var,Cz# Var,Cw# Var,t# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Slerp two quaternions to the given quaternion.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TQuatPtr>
<tr><td class=doctop colspan=2>Type TQuatPtr</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>QuatPtr functions (Openb3d)</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TQuatPtr_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetQuaternion>GetQuaternion</a></td><td class=docright>
Overwrite self with the given TQuaternion, returns nothing (like CopyQuaternion)
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TQuatPtr_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#CopyQuaternion>CopyQuaternion</a></td><td class=docright>
Copy the given TQuaternion, returns a new Float Ptr quaternion (like GetQuaternion)
</td></tr>
<tr><td class=docleft width=1%><a href=#Create>Create</a></td><td class=docright>
Create a new TQuatPtr from four float values, returns a Float Ptr quaternion.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewQuatPtr>NewQuatPtr</a></td><td class=docright>
Returns a new TQuatPtr object.
</td></tr>
<tr><td class=docleft width=1%><a href=#QuatToEuler>QuatToEuler</a></td><td class=docright>
Convert a quaternion to the given pitch, yaw, roll (Euler degrees)
</td></tr>
<tr><td class=docleft width=1%><a href=#QuatToMat>QuatToMat</a></td><td class=docright>
Convert a quaternion to the given TMatPtr.
</td></tr>
<tr><td class=docleft width=1%><a href=#Slerp>Slerp</a></td><td class=docright>
Slerp two quaternions to the given quaternion.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetQuaternion>
<tr><td class=doctop colspan=2>Method GetQuaternion:TQuatPtr( quat:TQuaternion )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Overwrite self with the given TQuaternion, returns nothing (like CopyQuaternion)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CopyQuaternion>
<tr><td class=doctop colspan=2>Function CopyQuaternion:TQuatPtr( quat:TQuaternion )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy the given TQuaternion, returns a new Float Ptr quaternion (like GetQuaternion)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Create>
<tr><td class=doctop colspan=2>Function Create:TQuatPtr( w:Float=0,x:Float=0,y:Float=0,z:Float=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TQuatPtr from four float values, returns a Float Ptr quaternion.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=NewQuatPtr>
<tr><td class=doctop colspan=2>Function NewQuatPtr:TQuatPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a new TQuatPtr object.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=QuatToEuler>
<tr><td class=doctop colspan=2>Function QuatToEuler( w:Float,x:Float,y:Float,z:Float,pitch:Float Var,yaw:Float Var,roll:Float Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Convert a quaternion to the given pitch, yaw, roll (Euler degrees)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=QuatToMat>
<tr><td class=doctop colspan=2>Function QuatToMat( w:Float,x:Float,y:Float,z:Float,mat:TMatPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Convert a quaternion to the given TMatPtr.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Slerp>
<tr><td class=doctop colspan=2>Function Slerp:Int( Ax#,Ay#,Az#,Aw#,Bx#,By#,Bz#,Bw#,Cx:Float Var,Cy:Float Var,Cz:Float Var,Cw:Float Var,t# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Slerp two quaternions to the given quaternion.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TRigidBody>
<tr><td class=doctop colspan=2>Type TRigidBody</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rigid Body.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TShader>
<tr><td class=doctop colspan=2>Type TShader</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Shader.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TShaderObject>
<tr><td class=doctop colspan=2>Type TShaderObject</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Shader object.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TShadowObject>
<tr><td class=doctop colspan=2>Type TShadowObject</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Shadow object.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TSprite>
<tr><td class=doctop colspan=2>Type TSprite Extends TMesh</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sprite mesh entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TStencil>
<tr><td class=doctop colspan=2>Type TStencil</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Stencil.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TSurface>
<tr><td class=doctop colspan=2>Type TSurface</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Surface.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TTerrain>
<tr><td class=doctop colspan=2>Type TTerrain Extends TEntity</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Terrain entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TTexture>
<tr><td class=doctop colspan=2>Type TTexture</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Texture.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TUse>
<tr><td class=doctop colspan=2>Type TUse</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Loader flags for meshes and textures.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TVecPtr>
<tr><td class=doctop colspan=2>Type TVecPtr</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>TVecPtr functions (Openb3d)</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TVecPtr_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#Add>Add</a></td><td class=docright>
Add self to the given TVecPtr, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Clear>Clear</a></td><td class=docright>
Clear (zero) vector values, returns nothing.
</td></tr>
<tr><td class=docleft width=1%><a href=#Copy>Copy</a></td><td class=docright>
Copy self, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Cross>Cross</a></td><td class=docright>
Cross product of self with the given TVecPtr, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Distance>Distance</a></td><td class=docright>
Distance between self and the given TVecPtr, returns a float.
</td></tr>
<tr><td class=docleft width=1%><a href=#Divide>Divide</a></td><td class=docright>
Divide self by a float, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Divide2>Divide2</a></td><td class=docright>
Divide self by the given TVecPtr, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Dot>Dot</a></td><td class=docright>
Dot product (or squared length) of self with the given TVecPtr, returns a float.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetVector>GetVector</a></td><td class=docright>
Overwrite self with the given TVector, returns nothing (like CopyVector)
</td></tr>
<tr><td class=docleft width=1%><a href=#Length>Length</a></td><td class=docright>
Length (or magnitude) of self, returns a float.
</td></tr>
<tr><td class=docleft width=1%><a href=#Multiply>Multiply</a></td><td class=docright>
Multiply self by a float, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Multiply2>Multiply2</a></td><td class=docright>
Multiply self by the given TVecPtr, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Negate>Negate</a></td><td class=docright>
Negate self, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Normalize>Normalize</a></td><td class=docright>
Normalize self, returns nothing.
</td></tr>
<tr><td class=docleft width=1%><a href=#Normalized>Normalized</a></td><td class=docright>
Normalize self, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Pitch>Pitch</a></td><td class=docright>
Pitch (or x angle) in degrees of self, returns a float.
</td></tr>
<tr><td class=docleft width=1%><a href=#Subtract>Subtract</a></td><td class=docright>
Subtract the given TVecPtr from self, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Yaw>Yaw</a></td><td class=docright>
Yaw (or y angle) in degrees of self, returns a float.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TVecPtr_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#CopyVector>CopyVector</a></td><td class=docright>
Copy the given TVector, returns a new Float Ptr vector (like GetVector)
</td></tr>
<tr><td class=docleft width=1%><a href=#Create>Create</a></td><td class=docright>
Create a new TVecPtr from three float values, returns a Float Ptr vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Magnitude>Magnitude</a></td><td class=docright>
Magnitude (or length) of a vector from three float values, returns a float.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewVecPtr>NewVecPtr</a></td><td class=docright>
Returns a new TVecPtr object.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Add>
<tr><td class=doctop colspan=2>Method Add:TVecPtr( vec:TVecPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Add self to the given TVecPtr, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Clear>
<tr><td class=doctop colspan=2>Method Clear()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Clear (zero) vector values, returns nothing.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Copy>
<tr><td class=doctop colspan=2>Method Copy:TVecPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy self, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Cross>
<tr><td class=doctop colspan=2>Method Cross:TVecPtr( vec:TVecPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Cross product of self with the given TVecPtr, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Distance>
<tr><td class=doctop colspan=2>Method Distance:Float( vec:TVecPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Distance between self and the given TVecPtr, returns a float.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Divide>
<tr><td class=doctop colspan=2>Method Divide:TVecPtr( scale:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Divide self by a float, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Divide2>
<tr><td class=doctop colspan=2>Method Divide2:TVecPtr( vec:TVecPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Divide self by the given TVecPtr, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Dot>
<tr><td class=doctop colspan=2>Method Dot:Float( vec:TVecPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Dot product (or squared length) of self with the given TVecPtr, returns a float.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetVector>
<tr><td class=doctop colspan=2>Method GetVector:TVecPtr( vec:TVector )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Overwrite self with the given TVector, returns nothing (like CopyVector)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Length>
<tr><td class=doctop colspan=2>Method Length:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Length (or magnitude) of self, returns a float.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Multiply>
<tr><td class=doctop colspan=2>Method Multiply:TVecPtr( scale:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Multiply self by a float, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Multiply2>
<tr><td class=doctop colspan=2>Method Multiply2:TVecPtr( vec:TVecPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Multiply self by the given TVecPtr, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Negate>
<tr><td class=doctop colspan=2>Method Negate:TVecPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Negate self, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Normalize>
<tr><td class=doctop colspan=2>Method Normalize()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Normalize self, returns nothing.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Normalized>
<tr><td class=doctop colspan=2>Method Normalized:TVecPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Normalize self, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Pitch>
<tr><td class=doctop colspan=2>Method Pitch:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Pitch (or x angle) in degrees of self, returns a float.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Subtract>
<tr><td class=doctop colspan=2>Method Subtract:TVecPtr( vec:TVecPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Subtract the given TVecPtr from self, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Yaw>
<tr><td class=doctop colspan=2>Method Yaw:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Yaw (or y angle) in degrees of self, returns a float.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CopyVector>
<tr><td class=doctop colspan=2>Function CopyVector:TVecPtr( vec:TVector )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy the given TVector, returns a new Float Ptr vector (like GetVector)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Create>
<tr><td class=doctop colspan=2>Function Create:TVecPtr( x:Float=0,y:Float=0,z:Float=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TVecPtr from three float values, returns a Float Ptr vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Magnitude>
<tr><td class=doctop colspan=2>Function Magnitude:Float( v0:Float,v1:Float,v2:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Magnitude (or length) of a vector from three float values, returns a float.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=NewVecPtr>
<tr><td class=doctop colspan=2>Function NewVecPtr:TVecPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a new TVecPtr object.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TVector>
<tr><td class=doctop colspan=2>Type TVector</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>TVector functions (Minib3d)</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TVector_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#Add>Add</a></td><td class=docright>
Add self to the given TVector, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Compare>Compare</a></td><td class=docright>
Compare the given TVector with self, returns 1 or -1.
</td></tr>
<tr><td class=docleft width=1%><a href=#Copy>Copy</a></td><td class=docright>
Copy self, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Cross>Cross</a></td><td class=docright>
Cross product of self with the given TVector, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Distance>Distance</a></td><td class=docright>
Distance between self and the given TVector, returns a float.
</td></tr>
<tr><td class=docleft width=1%><a href=#Divide>Divide</a></td><td class=docright>
Divide self by a float, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Divide2>Divide2</a></td><td class=docright>
Divide self by the given TVecPtr, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Dot>Dot</a></td><td class=docright>
Dot product (or squared length) of self with the given TVector.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetVecPtr>GetVecPtr</a></td><td class=docright>
Overwrite self with the given TVecPtr, returns nothing (like CopyVecPtr)
</td></tr>
<tr><td class=docleft width=1%><a href=#Length>Length</a></td><td class=docright>
Length (or magnitude) of self, returns a float.
</td></tr>
<tr><td class=docleft width=1%><a href=#Multiply>Multiply</a></td><td class=docright>
Multiply self by a float, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Multiply2>Multiply2</a></td><td class=docright>
Multiply self by the given TVecPtr, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#New>New</a></td><td class=docright>
Returns a new TVector object.
</td></tr>
<tr><td class=docleft width=1%><a href=#Normalize>Normalize</a></td><td class=docright>
Normalize self, returns nothing.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLength>SetLength</a></td><td class=docright>
Set normalized length of self, returns a float.
</td></tr>
<tr><td class=docleft width=1%><a href=#SquaredLength>SquaredLength</a></td><td class=docright>
Squared length of self, returns a float.
</td></tr>
<tr><td class=docleft width=1%><a href=#Subtract>Subtract</a></td><td class=docright>
Subtract the given TVector from self, returns a new vector.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TVector_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#CopyVecPtr>CopyVecPtr</a></td><td class=docright>
Copy the given TVecPtr, returns a new Float vector (like GetVecPtr)
</td></tr>
<tr><td class=docleft width=1%><a href=#Create>Create</a></td><td class=docright>
Create a new TVector from three float values, returns a Float vector.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Add>
<tr><td class=doctop colspan=2>Method Add:TVector( vec:TVector )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Add self to the given TVector, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Compare>
<tr><td class=doctop colspan=2>Method Compare:Int( with:Object )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Compare the given TVector with self, returns 1 or -1.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Copy>
<tr><td class=doctop colspan=2>Method Copy:TVector()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy self, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Cross>
<tr><td class=doctop colspan=2>Method Cross:TVector( vec:TVector )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Cross product of self with the given TVector, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Distance>
<tr><td class=doctop colspan=2>Method Distance:Float( vec:TVector )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Distance between self and the given TVector, returns a float.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Divide>
<tr><td class=doctop colspan=2>Method Divide:TVector( val# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Divide self by a float, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Divide2>
<tr><td class=doctop colspan=2>Method Divide2:TVector( vec:TVector )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Divide self by the given TVecPtr, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Dot>
<tr><td class=doctop colspan=2>Method Dot:Float( vec:TVector )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Dot product (or squared length) of self with the given TVector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetVecPtr>
<tr><td class=doctop colspan=2>Method GetVecPtr:TVector( vec:TVecPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Overwrite self with the given TVecPtr, returns nothing (like CopyVecPtr)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Length>
<tr><td class=doctop colspan=2>Method Length#()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Length (or magnitude) of self, returns a float.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Multiply>
<tr><td class=doctop colspan=2>Method Multiply:TVector( val# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Multiply self by a float, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Multiply2>
<tr><td class=doctop colspan=2>Method Multiply2:TVector( vec:TVector )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Multiply self by the given TVecPtr, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=New>
<tr><td class=doctop colspan=2>Method New()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a new TVector object.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Normalize>
<tr><td class=doctop colspan=2>Method Normalize()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Normalize self, returns nothing.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLength>
<tr><td class=doctop colspan=2>Method SetLength#( val# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set normalized length of self, returns a float.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SquaredLength>
<tr><td class=doctop colspan=2>Method SquaredLength#()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Squared length of self, returns a float.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Subtract>
<tr><td class=doctop colspan=2>Method Subtract:TVector( vec:TVector )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Subtract the given TVector from self, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CopyVecPtr>
<tr><td class=doctop colspan=2>Function CopyVecPtr:TVector( vec:TVecPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy the given TVecPtr, returns a new Float vector (like GetVecPtr)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Create>
<tr><td class=doctop colspan=2>Function Create:TVector( x#,y#,z# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TVector from three float values, returns a Float vector.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TVoxelSprite>
<tr><td class=doctop colspan=2>Type TVoxelSprite Extends TMesh</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Voxelsprite mesh entity.</td></tr>
</table>
<br>
<h2 id=modinfo>Module Information</h2>
<table width=100%>
<tr><th width=1%>Version</th><td>1.26</td></tr>
<tr><th width=1%>License</th><td>zlib</td></tr>
<tr><th width=1%>Copyright</th><td>Wrapper - 2014-2021 Mark Mcvittie, Bruce A Henderson</td></tr>
<tr><th width=1%>Copyright</th><td>Library - 2010-2021 Angelo Rosina</td></tr>
</body></html>
