<html><head><title>OpenB3D extended functions, not in B3D reference</title>
<link rel=stylesheet Type=text/css href='../../../../doc/bmxstyle.css'>
</head><body>
<table width=100% cellspacing=0><tr align=center><td class=small>&nbsp;</td>
<td class=small width=1%><b>Openb3d.Openb3d:</b></td>
<td class=small width=1%><a href=#functions class=small>Functions</a></td>
<td class=small width=1%><a href=#types class=small>Types</a></td>
<td class=small width=1%><a href=#modinfo class=small>Modinfo</a></td>
<td class=small width=1%><a href='../../../../mod/openb3d.mod/openb3d.mod/openb3d.bmx' class=small>Source</a></td>
<td class=small>&nbsp;</td></tr></table>
<h1>OpenB3D extended functions, not in B3D</h1>
The wrapper with declarations for library functions.
<h2><a name=functions></a>Functions Summary</h2><table class=doc width=100%>
<tr><td class=docleft width=1%><a href=#ActFadeTo>ActFadeTo</a></td><td class=docright>
Fades entity to the given alpha value (0..1) at the speed of rate.
</td></tr>
<tr><td class=docleft width=1%><a href=#ActMoveBy>ActMoveBy</a></td><td class=docright>
Moves entity by an x y z position increment at the speed of rate.
</td></tr>
<tr><td class=docleft width=1%><a href=#ActMoveTo>ActMoveTo</a></td><td class=docright>
Moves entity to the given x y z position at the speed of rate.
</td></tr>
<tr><td class=docleft width=1%><a href=#ActNewtonian>ActNewtonian</a></td><td class=docright>
Translates entity in the direction it is moving, rate should be below 1.
</td></tr>
<tr><td class=docleft width=1%><a href=#ActScaleTo>ActScaleTo</a></td><td class=docright>
Scales entity to the given x y z dimensions at the speed of rate.
</td></tr>
<tr><td class=docleft width=1%><a href=#ActTintTo>ActTintTo</a></td><td class=docright>
Tints entity to the given r g b value (0..255) at the speed of rate.
</td></tr>
<tr><td class=docleft width=1%><a href=#ActTrackByDistance>ActTrackByDistance</a></td><td class=docright>
Tracks target entity up to a given distance at the speed of rate.
</td></tr>
<tr><td class=docleft width=1%><a href=#ActTrackByPoint>ActTrackByPoint</a></td><td class=docright>
Tracks target entity at a given point from the entity at the speed of rate.
</td></tr>
<tr><td class=docleft width=1%><a href=#ActTurnBy>ActTurnBy</a></td><td class=docright>
Turns entity by an x y z rotation increment at the speed of rate.
</td></tr>
<tr><td class=docleft width=1%><a href=#ActTurnTo>ActTurnTo</a></td><td class=docright>
Turns entity to the given x y z rotation at the speed of rate.
</td></tr>
<tr><td class=docleft width=1%><a href=#ActVector>ActVector</a></td><td class=docright>
Positions entity according the given x y z vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#AddRenderTarget>AddRenderTarget</a></td><td class=docright>
undocumented.
</td></tr>
<tr><td class=docleft width=1%><a href=#AddSurface>AddSurface</a></td><td class=docright>
Add an existing surface to a mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#AlphaDiscard>AlphaDiscard</a></td><td class=docright>
Set discard value (as 0..1) above which to ignore pixel's alpha value, default is 1 (only if flag 2)
</td></tr>
<tr><td class=docleft width=1%><a href=#AmbientShader>AmbientShader</a></td><td class=docright>
Set default shader for surfaces.
</td></tr>
<tr><td class=docleft width=1%><a href=#AntiAlias>AntiAlias</a></td><td class=docright>
<a href="http://www.blitzbasic.com/b3ddocs/command.php?name=AntiAlias">Online doc</a>
</td></tr>
<tr><td class=docleft width=1%><a href=#AppendAction>AppendAction</a></td><td class=docright>
Adds action to the end of another one, where act1 happens before act2.
</td></tr>
<tr><td class=docleft width=1%><a href=#AttachFragShader>AttachFragShader</a></td><td class=docright>
Attaches a fragment shader object to a program object, attach vertex first or older compilers will crash.
</td></tr>
<tr><td class=docleft width=1%><a href=#AttachVertShader>AttachVertShader</a></td><td class=docright>
Attaches a vertex shader object to a program object.
</td></tr>
<tr><td class=docleft width=1%><a href=#BackBufferToTex>BackBufferToTex</a></td><td class=docright>
Copy the contents of the backbuffer to a texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#BeginMax2D>BeginMax2D</a></td><td class=docright>
Old begin function as in Minib3d is 0, new begin function is 1 (default)
</td></tr>
<tr><td class=docleft width=1%><a href=#BrushGLBlendFunc>BrushGLBlendFunc</a></td><td class=docright>
GL equivalent, experimental.
</td></tr>
<tr><td class=docleft width=1%><a href=#BrushGLColor>BrushGLColor</a></td><td class=docright>
GL equivalent, experimental.
</td></tr>
<tr><td class=docleft width=1%><a href=#BufferToTex>BufferToTex</a></td><td class=docright>
Copy pixmap buffer to texture, buffer must be a byte ptr.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraProjMatrix>CameraProjMatrix</a></td><td class=docright>
undocumented.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraToTex>CameraToTex</a></td><td class=docright>
Copy rendered camera view to texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#CheckFramebufferStatus>CheckFramebufferStatus</a></td><td class=docright>
Check for framebuffer errors.
</td></tr>
<tr><td class=docleft width=1%><a href=#CopyBrush>CopyBrush</a></td><td class=docright>
Returns a copy of the new brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#CopyList>CopyList</a></td><td class=docright>
Copy a list or vector. To copy a field list use as a method.
</td></tr>
<tr><td class=docleft width=1%><a href=#CopyRect>CopyRect</a></td><td class=docright>
Copy rectangle of source pixmap pixels to destination, not exactly like B3D.
</td></tr>
<tr><td class=docleft width=1%><a href=#CopySurface>CopySurface</a></td><td class=docright>
Returns a copy of the new surface.
</td></tr>
<tr><td class=docleft width=1%><a href=#CopyTexture>CopyTexture</a></td><td class=docright>
Returns a copy of the new texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#CountMipmaps>CountMipmaps</a></td><td class=docright>
Returns the number of mipmaps a texture has.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateBlob>CreateBlob</a></td><td class=docright>
Create blob from a fluid mesh where radius is the size of the blob.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateBone>CreateBone</a></td><td class=docright>
Create bone.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateConstraint>CreateConstraint</a></td><td class=docright>
Create constraint force between two entities of given length, doesn't affect rotation.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateFluid>CreateFluid</a></td><td class=docright>
Create fluid mesh for blobs to use.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateFragShader>CreateFragShader</a></td><td class=docright>
Returns a new frag shader object from file.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateFragShaderString>CreateFragShaderString</a></td><td class=docright>
Returns a new frag shader object from string.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateGeosphere>CreateGeosphere</a></td><td class=docright>
Create geodesic sphere and set terrain size.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateOcTree>CreateOcTree</a></td><td class=docright>
Create octree and set its width, height and depth.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateParticleEmitter>CreateParticleEmitter</a></td><td class=docright>
Create particle emitter and set sprite for it to use.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreatePostFX>CreatePostFX</a></td><td class=docright>
undocumented.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateQuad>CreateQuad</a></td><td class=docright>
Create flat quad.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateRigidBody>CreateRigidBody</a></td><td class=docright>
Create rigid physics body attached to four entities.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateShader>CreateShader</a></td><td class=docright>
Load shader from two strings, vertex and fragment.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateShaderMaterial>CreateShaderMaterial</a></td><td class=docright>
Returns a new shader material without creating any shader objects.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateShaderVGF>CreateShaderVGF</a></td><td class=docright>
Load shader from three strings, vertex, geometry and fragment.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateShadow>CreateShadow</a></td><td class=docright>
Create stencil shadow, static is for static or dynamic shadows.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateStencil>CreateStencil</a></td><td class=docright>
Create stencil object.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateVertShader>CreateVertShader</a></td><td class=docright>
Returns a new vert shader object from file.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateVertShaderString>CreateVertShaderString</a></td><td class=docright>
Returns a new vert shader object from string.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateVoxelSprite>CreateVoxelSprite</a></td><td class=docright>
Create voxel sprite where slices is the number of sprites.
</td></tr>
<tr><td class=docleft width=1%><a href=#DeleteFragShader>DeleteFragShader</a></td><td class=docright>
Deletes a frag shader object from a program object.
</td></tr>
<tr><td class=docleft width=1%><a href=#DeleteVertShader>DeleteVertShader</a></td><td class=docright>
Deletes a vert shader object from a program object.
</td></tr>
<tr><td class=docleft width=1%><a href=#DepthBufferToTex>DepthBufferToTex</a></td><td class=docright>
Copy the contents of the depth buffer to a texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#EmitterParticleAlpha>EmitterParticleAlpha</a></td><td class=docright>
Set particles alpha at start and end, range is 0..1.
</td></tr>
<tr><td class=docleft width=1%><a href=#EmitterParticleColor>EmitterParticleColor</a></td><td class=docright>
Set particles RGB color at start and end, default is 255,255,255.
</td></tr>
<tr><td class=docleft width=1%><a href=#EmitterParticleFunction>EmitterParticleFunction</a></td><td class=docright>
Points to callback function for emitter.
</td></tr>
<tr><td class=docleft width=1%><a href=#EmitterParticleLife>EmitterParticleLife</a></td><td class=docright>
Set particles start, end and random lifespan.
</td></tr>
<tr><td class=docleft width=1%><a href=#EmitterParticleRotate>EmitterParticleRotate</a></td><td class=docright>
Set particles rotation angle at start and end.
</td></tr>
<tr><td class=docleft width=1%><a href=#EmitterParticleScale>EmitterParticleScale</a></td><td class=docright>
Set particles scale at start and end, default is 1.
</td></tr>
<tr><td class=docleft width=1%><a href=#EmitterParticleSpeed>EmitterParticleSpeed</a></td><td class=docright>
Set particles start and end speed.
</td></tr>
<tr><td class=docleft width=1%><a href=#EmitterRate>EmitterRate</a></td><td class=docright>
Rate between each emission, range is 0.01..1.01.
</td></tr>
<tr><td class=docleft width=1%><a href=#EmitterVariance>EmitterVariance</a></td><td class=docright>
Set random variance of particles, range is 0.001..0.1.
</td></tr>
<tr><td class=docleft width=1%><a href=#EmitterVector>EmitterVector</a></td><td class=docright>
Set emitters start and end 3d vectors.
</td></tr>
<tr><td class=docleft width=1%><a href=#EndAction>EndAction</a></td><td class=docright>
Ends action so it can be freed, 1 = automatically ended, 2 = manually ended.
</td></tr>
<tr><td class=docleft width=1%><a href=#EndMax2D>EndMax2D</a></td><td class=docright>
Old end function as in Minib3d is 0, new end function is 1 (default)
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityMatrix>EntityMatrix</a></td><td class=docright>
undocumented.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityScaleX>EntityScaleX</a></td><td class=docright>
Returns the scale for the x axis of an entity set with ScaleEntity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityScaleY>EntityScaleY</a></td><td class=docright>
Returns the scale for the y axis of an entity set with ScaleEntity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityScaleZ>EntityScaleZ</a></td><td class=docright>
Returns the scale for the z axis of an entity set with ScaleEntity.
</td></tr>
<tr><td class=docleft width=1%><a href=#FluidArray>FluidArray</a></td><td class=docright>
Create custom rendering array data for fluid mesh and set width, height and depth.
</td></tr>
<tr><td class=docleft width=1%><a href=#FluidFunction>FluidFunction</a></td><td class=docright>
Set custom rendering callback function for fluid mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#FluidThreshold>FluidThreshold</a></td><td class=docright>
Set threshold value used in fluid rendering algorithm, 0.5 is default.
</td></tr>
<tr><td class=docleft width=1%><a href=#FreeAction>FreeAction</a></td><td class=docright>
Frees action from memory when it has ended.
</td></tr>
<tr><td class=docleft width=1%><a href=#FreeBrushTextures>FreeBrushTextures</a></td><td class=docright>
Frees all brush textures, FreeBrush does not free textures.
</td></tr>
<tr><td class=docleft width=1%><a href=#FreeShader>FreeShader</a></td><td class=docright>
Frees a shader material.
</td></tr>
<tr><td class=docleft width=1%><a href=#FreeShadow>FreeShadow</a></td><td class=docright>
Free stencil shadow.
</td></tr>
<tr><td class=docleft width=1%><a href=#FreeStencil>FreeStencil</a></td><td class=docright>
Frees a stencil object.
</td></tr>
<tr><td class=docleft width=1%><a href=#FreeSurface>FreeSurface</a></td><td class=docright>
Frees VBO data and brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#GeosphereHeight>GeosphereHeight</a></td><td class=docright>
Set terrain height normalizing value, 0.05 is default.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMeshLoader>GetMeshLoader</a></td><td class=docright>
Returns a mesh loader capable of loading <b>extension</b>.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetShaderProgram>GetShaderProgram</a></td><td class=docright>
Get a shader program object reference.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetString>GetString</a></td><td class=docright>
Gets a Blitz string from a C string.
</td></tr>
<tr><td class=docleft width=1%><a href=#GlobalAnIsotropic>GlobalAnIsotropic</a></td><td class=docright>
Set global texture anisotropic (default for all), TextureAnIsotropic overrides it.
</td></tr>
<tr><td class=docleft width=1%><a href=#GlobalHeight>GlobalHeight</a></td><td class=docright>
Returns global height of screen resolution.
</td></tr>
<tr><td class=docleft width=1%><a href=#GlobalResolution>GlobalResolution</a></td><td class=docright>
Sets global width and height of screen resolution.
</td></tr>
<tr><td class=docleft width=1%><a href=#GlobalWidth>GlobalWidth</a></td><td class=docright>
Returns global width of screen resolution.
</td></tr>
<tr><td class=docleft width=1%><a href=#LightMesh>LightMesh</a></td><td class=docright>
Performs a 'fake' lighting operation on a mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#LinkShader>LinkShader</a></td><td class=docright>
Link shader to a program object, as created by CreateShaderMaterial.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadAnimMesh>LoadAnimMesh</a></td><td class=docright>
Loads an anim mesh, see MeshLoader.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadGeosphere>LoadGeosphere</a></td><td class=docright>
Load geodesic sphere terrain from heightmap image.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadMaterial>LoadMaterial</a></td><td class=docright>
Load a texture from image for 3D texture sampling, use with voxelsprites.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadMD2>LoadMD2</a></td><td class=docright>
Loads an md2 entity and returns its handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadMesh>LoadMesh</a></td><td class=docright>
Loads a single mesh, see MeshLoader.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadShader>LoadShader</a></td><td class=docright>
Load shader from two files, vertex and fragment.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadShaderVGF>LoadShaderVGF</a></td><td class=docright>
Load shader from three files, vertex, geometry and fragment.
</td></tr>
<tr><td class=docleft width=1%><a href=#MeshCSG>MeshCSG</a></td><td class=docright>
Method 0 subtracts mesh2 from mesh1, 1 adds meshes, 2 intersects meshes. Returns a new mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#MeshCullRadius>MeshCullRadius</a></td><td class=docright>
Equivalent of Blitz3D's MeshCullBox command. It sets the radius of a mesh's 'cull sphere'
</td></tr>
<tr><td class=docleft width=1%><a href=#ModifyGeosphere>ModifyGeosphere</a></td><td class=docright>
Set height of a given point, like ModifyTerrain.
</td></tr>
<tr><td class=docleft width=1%><a href=#MSAntiAlias>MSAntiAlias</a></td><td class=docright>
Enables or disables hardware multisample antialiasing if supported.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewAnimationKeys>NewAnimationKeys</a></td><td class=docright>
Create a new TAnimationKeys object.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewBone>NewBone</a></td><td class=docright>
Create a new TBone object.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewMatPtr>NewMatPtr</a></td><td class=docright>
Create a new TMatPtr object, returns a Float Ptr matrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewMesh>NewMesh</a></td><td class=docright>
Create a new TMesh object.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewQuatPtr>NewQuatPtr</a></td><td class=docright>
Create a new TQuatPtr object, returns a Float Ptr quaternion.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewSprite>NewSprite</a></td><td class=docright>
Create a new TSprite object.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewSurface>NewSurface</a></td><td class=docright>
Create a new TSurface object.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewTexture>NewTexture</a></td><td class=docright>
Create a new TTexture object.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewVecPtr>NewVecPtr</a></td><td class=docright>
Create a new TVecPtr object, returns a Float Ptr vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#OctreeBlock>OctreeBlock</a></td><td class=docright>
Place mesh into a node of an octree, the mesh can be duplicated using no more memory.
</td></tr>
<tr><td class=docleft width=1%><a href=#OctreeMesh>OctreeMesh</a></td><td class=docright>
Place mesh into a node of an octree, the mesh can't be duplicated so to do that use CopyEntity.
</td></tr>
<tr><td class=docleft width=1%><a href=#ParticleColor>ParticleColor</a></td><td class=docright>
Sets color of batch particle trails.
</td></tr>
<tr><td class=docleft width=1%><a href=#ParticleTrail>ParticleTrail</a></td><td class=docright>
Sets number of batch particles in trail.
</td></tr>
<tr><td class=docleft width=1%><a href=#ParticleVector>ParticleVector</a></td><td class=docright>
Sets 3d vector of batch particle trails.
</td></tr>
<tr><td class=docleft width=1%><a href=#PositionAnimMesh>PositionAnimMesh</a></td><td class=docright>
Moves all vertices of mesh and every child mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#PostFXBuffer>PostFXBuffer</a></td><td class=docright>
undocumented.
</td></tr>
<tr><td class=docleft width=1%><a href=#PostFXFunction>PostFXFunction</a></td><td class=docright>
undocumented.
</td></tr>
<tr><td class=docleft width=1%><a href=#PostFXShader>PostFXShader</a></td><td class=docright>
undocumented.
</td></tr>
<tr><td class=docleft width=1%><a href=#PostFXShaderPass>PostFXShaderPass</a></td><td class=docright>
undocumented.
</td></tr>
<tr><td class=docleft width=1%><a href=#PostFXTexture>PostFXTexture</a></td><td class=docright>
undocumented.
</td></tr>
<tr><td class=docleft width=1%><a href=#RepeatMesh>RepeatMesh</a></td><td class=docright>
Like CopyMesh but for instancing effects.
</td></tr>
<tr><td class=docleft width=1%><a href=#ResetShadow>ResetShadow</a></td><td class=docright>
Reset created flag to update static shadow.
</td></tr>
<tr><td class=docleft width=1%><a href=#RotateAnimMesh>RotateAnimMesh</a></td><td class=docright>
Rotates all vertices of mesh and every child mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#ScaleAnimMesh>ScaleAnimMesh</a></td><td class=docright>
Scales all vertices of mesh and every child mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetFloat>SetFloat</a></td><td class=docright>
Set a shader variable name of a uniform float type to a float value.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetFloat2>SetFloat2</a></td><td class=docright>
Set a shader variable name of a uniform vec2 type to 2 float values.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetFloat3>SetFloat3</a></td><td class=docright>
Set a shader variable name of a uniform vec3 type to 3 float values.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetFloat4>SetFloat4</a></td><td class=docright>
Set a shader variable name of a uniform vec4 type to 4 float values.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetInteger>SetInteger</a></td><td class=docright>
Set a shader variable name of a uniform int type to an integer value.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetInteger2>SetInteger2</a></td><td class=docright>
Set a shader variable name of a uniform ivec2 type to 2 integer values.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetInteger3>SetInteger3</a></td><td class=docright>
Set a shader variable name of a uniform ivec3 type to 3 integer values.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetInteger4>SetInteger4</a></td><td class=docright>
Set a shader variable name of a uniform ivec4 type to 4 integer values.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetShadowColor>SetShadowColor</a></td><td class=docright>
Set color R/G/B in range 0..255 and A in range 0..1.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetString>SetString</a></td><td class=docright>
Sets a C string from a Blitz string.
</td></tr>
<tr><td class=docleft width=1%><a href=#ShadeEntity>ShadeEntity</a></td><td class=docright>
Apply shader to an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#ShadeMesh>ShadeMesh</a></td><td class=docright>
Apply shader to a mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#ShaderFunction>ShaderFunction</a></td><td class=docright>
undocumented.
</td></tr>
<tr><td class=docleft width=1%><a href=#ShaderMaterial>ShaderMaterial</a></td><td class=docright>
Set a 3d texture for sampling.
</td></tr>
<tr><td class=docleft width=1%><a href=#ShaderTexture>ShaderTexture</a></td><td class=docright>
Load a texture for 2D texture sampling.
</td></tr>
<tr><td class=docleft width=1%><a href=#ShadeSurface>ShadeSurface</a></td><td class=docright>
Apply shader to a surface.
</td></tr>
<tr><td class=docleft width=1%><a href=#SkinMesh>SkinMesh</a></td><td class=docright>
Set animated surface for each of the bone no and weights arrays.
</td></tr>
<tr><td class=docleft width=1%><a href=#SpriteRenderMode>SpriteRenderMode</a></td><td class=docright>
If mode is 1 rendering is normal, 2 is for batch sprites like particles.
</td></tr>
<tr><td class=docleft width=1%><a href=#StencilAlpha>StencilAlpha</a></td><td class=docright>
Set stencil alpha value.
</td></tr>
<tr><td class=docleft width=1%><a href=#StencilClsColor>StencilClsColor</a></td><td class=docright>
Set stencil clear screen color in range 0..255.
</td></tr>
<tr><td class=docleft width=1%><a href=#StencilClsMode>StencilClsMode</a></td><td class=docright>
Set stencil clear screen modes.
</td></tr>
<tr><td class=docleft width=1%><a href=#StencilMesh>StencilMesh</a></td><td class=docright>
Set mesh to be used as stencil.
</td></tr>
<tr><td class=docleft width=1%><a href=#StencilMode>StencilMode</a></td><td class=docright>
Set stencil render modes.
</td></tr>
<tr><td class=docleft width=1%><a href=#StringPtr>StringPtr</a></td><td class=docright>
Returns string cast of byte pointer.
</td></tr>
<tr><td class=docleft width=1%><a href=#SurfsRendered>SurfsRendered</a></td><td class=docright>
Number of surfaces currently being rendered.
</td></tr>
<tr><td class=docleft width=1%><a href=#TerrainDetail>TerrainDetail</a></td><td class=docright>
Set terrain level of detail, default is 100 and maximum is 2000.
</td></tr>
<tr><td class=docleft width=1%><a href=#TerrainRange>TerrainRange</a></td><td class=docright>
Set terrain camera range to alter pop/switch distance, a value from 0 to 100.
</td></tr>
<tr><td class=docleft width=1%><a href=#TexToBuffer>TexToBuffer</a></td><td class=docright>
Copy texture to a pixmap buffer, buffer must be a byte ptr.
</td></tr>
<tr><td class=docleft width=1%><a href=#TextureAnIsotropic>TextureAnIsotropic</a></td><td class=docright>
Set texture anisotropic factor, usually from 2-16.
</td></tr>
<tr><td class=docleft width=1%><a href=#TextureFlags>TextureFlags</a></td><td class=docright>
Set texture flags, see LoadTexture for values.
</td></tr>
<tr><td class=docleft width=1%><a href=#TextureGLTexEnvf>TextureGLTexEnvf</a></td><td class=docright>
GL equivalent, param is a float, limited to 12 calls per texture, experimental.
</td></tr>
<tr><td class=docleft width=1%><a href=#TextureGLTexEnvi>TextureGLTexEnvi</a></td><td class=docright>
GL equivalent, param is a const, limited to 12 calls per texture, experimental.
</td></tr>
<tr><td class=docleft width=1%><a href=#TextureMultitex>TextureMultitex</a></td><td class=docright>
Set texture multitex factor, used in interpolate and custom TexBlend options.
</td></tr>
<tr><td class=docleft width=1%><a href=#TrisRendered>TrisRendered</a></td><td class=docright>
Number of triangles currently being rendered.
</td></tr>
<tr><td class=docleft width=1%><a href=#UpdateTexCoords>UpdateTexCoords</a></td><td class=docright>
Recalculates the surface's uvw coord set 1 based on vertices.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseAssimpStreamMeshes>UseAssimpStreamMeshes</a></td><td class=docright>
Loader flags for Assimp meshes.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseCubemapFlip>UseCubemapFlip</a></td><td class=docright>
Flip cubemap texture flag.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseEntity>UseEntity</a></td><td class=docright>
undocumented.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseFloat>UseFloat</a></td><td class=docright>
Bind a float variable to a shader variable name of a uniform float type.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseFloat2>UseFloat2</a></td><td class=docright>
Bind 2 float variables to a shader variable name of a uniform vec2 Type.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseFloat3>UseFloat3</a></td><td class=docright>
Bind 3 float variables to a shader variable name of a uniform vec3 type.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseFloat4>UseFloat4</a></td><td class=docright>
Bind 4 float variables to a shader variable name of a uniform vec4 type.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseInteger>UseInteger</a></td><td class=docright>
Bind an integer variable to a shader variable name of a uniform int type.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseInteger2>UseInteger2</a></td><td class=docright>
Bind 2 integer variables to a shader variable name of a uniform ivec2 type.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseInteger3>UseInteger3</a></td><td class=docright>
Bind 3 integer variables to a shader variable name of a uniform ivec3 type.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseInteger4>UseInteger4</a></td><td class=docright>
Bind 4 integer variables to a shader variable name of a uniform ivec4 type.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseLibraryMeshes>UseLibraryMeshes</a></td><td class=docright>
Loader flag for meshes.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseLibraryTextures>UseLibraryTextures</a></td><td class=docright>
Loader flag for textures.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseMatrix>UseMatrix</a></td><td class=docright>
Sends matrix data to a shader variable name of a uniform mat4 type.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseMatrix3DS>UseMatrix3DS</a></td><td class=docright>
Set 3DS model loader coordinates system (matrix), values should be 0,1,-1.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseMatrixMD2>UseMatrixMD2</a></td><td class=docright>
Set MD2 model loader coordinates system (matrix), values should be 0,1,-1.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseMeshDebugLog>UseMeshDebugLog</a></td><td class=docright>
Debug all mesh loaders.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseMeshTextureFlags>UseMeshTextureFlags</a></td><td class=docright>
Set mesh texture flags.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseMeshTransform>UseMeshTransform</a></td><td class=docright>
Transform mesh loaders.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseStencil>UseStencil</a></td><td class=docright>
Stencil to use, set to Null to disable stencil.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseSurface>UseSurface</a></td><td class=docright>
Sends surface data to a shader variable name.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseTextureFaces>UseTextureFaces</a></td><td class=docright>
Order for cubemap faces.
</td></tr>
<tr><td class=docleft width=1%><a href=#UseTextureFrames>UseTextureFrames</a></td><td class=docright>
Order for anim texture frames.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertsRendered>VertsRendered</a></td><td class=docright>
Number of vertices currently being rendered.
</td></tr>
<tr><td class=docleft width=1%><a href=#VoxelSpriteMaterial>VoxelSpriteMaterial</a></td><td class=docright>
Set material for voxel sprite.
</td></tr>
</table>
<h2><a name=types></a>Types Summary</h2><table class=doc width=100%>
<tr><td class=docleft width=1%><a href=#TAction>TAction</a></td><td class=docright>
Action.
</td></tr>
<tr><td class=docleft width=1%><a href=#TAnimationKeys>TAnimationKeys</a></td><td class=docright>
AnimationKeys data.
</td></tr>
<tr><td class=docleft width=1%><a href=#TBlitz2D>TBlitz2D</a></td><td class=docright>
Blitz2D.
</td></tr>
<tr><td class=docleft width=1%><a href=#TBlob>TBlob</a></td><td class=docright>
Blob entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TBone>TBone</a></td><td class=docright>
Bone entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TBrush>TBrush</a></td><td class=docright>
Brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#TCamera>TCamera</a></td><td class=docright>
Camera entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TConstraint>TConstraint</a></td><td class=docright>
Constraint.
</td></tr>
<tr><td class=docleft width=1%><a href=#TEntity>TEntity</a></td><td class=docright>
Entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TFluid>TFluid</a></td><td class=docright>
Fluid mesh entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TGeosphere>TGeosphere</a></td><td class=docright>
Geosphere terrain entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TGlobal3D>TGlobal3D</a></td><td class=docright>
Global.
</td></tr>
<tr><td class=docleft width=1%><a href=#THardwareInfo>THardwareInfo</a></td><td class=docright>
Hardware info.
</td></tr>
<tr><td class=docleft width=1%><a href=#TLight>TLight</a></td><td class=docright>
Light entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TMaterial>TMaterial</a></td><td class=docright>
Material texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#TMatPtr>TMatPtr</a></td><td class=docright>
MatPtr functions (Openb3d)
</td></tr>
<tr><td class=docleft width=1%><a href=#TMatrix>TMatrix</a></td><td class=docright>
Matrix functions (Minib3d)
</td></tr>
<tr><td class=docleft width=1%><a href=#TMesh>TMesh</a></td><td class=docright>
Mesh entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TMeshLoader>TMeshLoader</a></td><td class=docright>
Mesh loader.
</td></tr>
<tr><td class=docleft width=1%><a href=#TOcTree>TOcTree</a></td><td class=docright>
Octree terrain entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TParticleBatch>TParticleBatch</a></td><td class=docright>
Particle Batch mesh entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TParticleEmitter>TParticleEmitter</a></td><td class=docright>
Particle Emitter entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TPick>TPick</a></td><td class=docright>
Pick.
</td></tr>
<tr><td class=docleft width=1%><a href=#TPivot>TPivot</a></td><td class=docright>
Pivot entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TPostFX>TPostFX</a></td><td class=docright>
Post effects object.
</td></tr>
<tr><td class=docleft width=1%><a href=#TQuaternion>TQuaternion</a></td><td class=docright>
Quaternion functions (Minib3d)
</td></tr>
<tr><td class=docleft width=1%><a href=#TQuatPtr>TQuatPtr</a></td><td class=docright>
QuatPtr functions (Openb3d)
</td></tr>
<tr><td class=docleft width=1%><a href=#TRigidBody>TRigidBody</a></td><td class=docright>
Rigid Body.
</td></tr>
<tr><td class=docleft width=1%><a href=#TShader>TShader</a></td><td class=docright>
Shader.
</td></tr>
<tr><td class=docleft width=1%><a href=#TShaderObject>TShaderObject</a></td><td class=docright>
Shader object.
</td></tr>
<tr><td class=docleft width=1%><a href=#TShadowObject>TShadowObject</a></td><td class=docright>
Shadow object.
</td></tr>
<tr><td class=docleft width=1%><a href=#TSprite>TSprite</a></td><td class=docright>
Sprite mesh entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TStencil>TStencil</a></td><td class=docright>
Stencil.
</td></tr>
<tr><td class=docleft width=1%><a href=#TSurface>TSurface</a></td><td class=docright>
Surface.
</td></tr>
<tr><td class=docleft width=1%><a href=#TTerrain>TTerrain</a></td><td class=docright>
Terrain entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TTexture>TTexture</a></td><td class=docright>
Texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#TUse>TUse</a></td><td class=docright>
Loader flags for meshes and textures.
</td></tr>
<tr><td class=docleft width=1%><a href=#TVecPtr>TVecPtr</a></td><td class=docright>
TVecPtr functions (Openb3d)
</td></tr>
<tr><td class=docleft width=1%><a href=#TVector>TVector</a></td><td class=docright>
TVector functions (Minib3d)
</td></tr>
<tr><td class=docleft width=1%><a href=#TVoxelSprite>TVoxelSprite</a></td><td class=docright>
Voxelsprite mesh entity.
</td></tr>
</table>
<h2
 id=functionsdet>Functions
</h2>
<table class=doc width=100% cellspacing=3 id=ActFadeTo>
<tr><td class=doctop colspan=2>Function ActFadeTo:TAction( ent:TEntity,a:Float,rate:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Fades entity to the given alpha value (0..1) at the speed of rate.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ActMoveBy>
<tr><td class=doctop colspan=2>Function ActMoveBy:TAction( ent:TEntity,a:Float,b:Float,c:Float,rate:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Moves entity by an x y z position increment at the speed of rate.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ActMoveTo>
<tr><td class=doctop colspan=2>Function ActMoveTo:TAction( ent:TEntity,a:Float,b:Float,c:Float,rate:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Moves entity to the given x y z position at the speed of rate.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ActNewtonian>
<tr><td class=doctop colspan=2>Function ActNewtonian:TAction( ent:TEntity,rate:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Translates entity in the direction it is moving, rate should be below 1.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ActScaleTo>
<tr><td class=doctop colspan=2>Function ActScaleTo:TAction( ent:TEntity,a:Float,b:Float,c:Float,rate:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Scales entity to the given x y z dimensions at the speed of rate.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ActTintTo>
<tr><td class=doctop colspan=2>Function ActTintTo:TAction( ent:TEntity,a:Float,b:Float,c:Float,rate:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Tints entity to the given r g b value (0..255) at the speed of rate.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ActTrackByDistance>
<tr><td class=doctop colspan=2>Function ActTrackByDistance:TAction( ent:TEntity,target:TEntity,a:Float,rate:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Tracks target entity up to a given distance at the speed of rate.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ActTrackByPoint>
<tr><td class=doctop colspan=2>Function ActTrackByPoint:TAction( ent:TEntity,target:TEntity,a:Float,b:Float,c:Float,rate:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Tracks target entity at a given point from the entity at the speed of rate.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ActTurnBy>
<tr><td class=doctop colspan=2>Function ActTurnBy:TAction( ent:TEntity,a:Float,b:Float,c:Float,rate:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Turns entity by an x y z rotation increment at the speed of rate.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ActTurnTo>
<tr><td class=doctop colspan=2>Function ActTurnTo:TAction( ent:TEntity,a:Float,b:Float,c:Float,rate:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Turns entity to the given x y z rotation at the speed of rate.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ActVector>
<tr><td class=doctop colspan=2>Function ActVector:TAction( ent:TEntity,a:Float,b:Float,c:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Positions entity according the given x y z vector.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AddRenderTarget>
<tr><td class=doctop colspan=2>Function AddRenderTarget( fx:TPostFX,pass_no:Int,numColBufs:Int,depth:Int,format:Int=8,scale:Float=1.0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>undocumented.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AddSurface>
<tr><td class=doctop colspan=2>Function AddSurface( mesh:TMesh,surf:TSurface,anim_surf%=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Add an existing surface to a mesh.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AlphaDiscard>
<tr><td class=doctop colspan=2>Function AlphaDiscard( tex:TTexture,alpha:Float=0.01 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set discard value (as 0..1) above which to ignore pixel's alpha value, default is 1 (only if flag 2)</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AmbientShader>
<tr><td class=doctop colspan=2>Function AmbientShader( material:TShader )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set default shader for surfaces.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AntiAlias>
<tr><td class=doctop colspan=2>Function AntiAlias( samples:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright><a href="http://www.blitzbasic.com/b3ddocs/command.php?name=AntiAlias">Online doc</a></td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AppendAction>
<tr><td class=doctop colspan=2>Function AppendAction( act1:TAction,act2:TAction )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Adds action to the end of another one, where act1 happens before act2.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AttachFragShader>
<tr><td class=doctop colspan=2>Function AttachFragShader:Int( shader:TShader,myShader:TShaderObject )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Attaches a fragment shader object to a program object, attach vertex first or older compilers will crash.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AttachVertShader>
<tr><td class=doctop colspan=2>Function AttachVertShader:Int( shader:TShader,myShader:TShaderObject )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Attaches a vertex shader object to a program object.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=BackBufferToTex>
<tr><td class=doctop colspan=2>Function BackBufferToTex( tex:TTexture,mipmap_no:Int=0,frame:Int=0,fastinvert:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy the contents of the backbuffer to a texture.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>OpenB3D does not have the same buffer commands as Blitz3D.
The region copied from the backbuffer will start at 0,0 and end at the texture's width and height.
So if you want to copy a 3D scene to a texture, first resize the camera viewport to the texture size,
use RenderWorld to render the camera, then use this command.
Back buffer is upside-down so set fastinvert to True to invert texture uvs, False to flip texture data (slower).</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=BeginMax2D>
<tr><td class=doctop colspan=2>Function BeginMax2D( version:Int=1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Old begin function as in Minib3d is 0, new begin function is 1 (default)</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=BrushGLBlendFunc>
<tr><td class=doctop colspan=2>Function BrushGLBlendFunc( brush:TBrush,sfactor:Int,dfactor:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>GL equivalent, experimental.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=BrushGLColor>
<tr><td class=doctop colspan=2>Function BrushGLColor( brush:TBrush,r:Float,g:Float,b:Float,a:Float=1.0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>GL equivalent, experimental.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=BufferToTex>
<tr><td class=doctop colspan=2>Function BufferToTex( tex:TTexture,buffer:Byte Ptr,frame:Int=0 ) ' frame currently does nothing</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy pixmap buffer to texture, buffer must be a byte ptr.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraProjMatrix>
<tr><td class=doctop colspan=2>Function CameraProjMatrix:Float Ptr( cam:TCamera )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>undocumented.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraToTex>
<tr><td class=doctop colspan=2>Function CameraToTex( tex:TTexture,cam:TCamera,frame:Int=0 ) ' frame currently does nothing</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy rendered camera view to texture.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CheckFramebufferStatus>
<tr><td class=doctop colspan=2>Function CheckFramebufferStatus( target% )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Check for framebuffer errors.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CopyBrush>
<tr><td class=doctop colspan=2>Function CopyBrush:TBrush( brush:TBrush )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a copy of the new brush.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CopyList>
<tr><td class=doctop colspan=2>Function CopyList( list:TList )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy a list or vector. To copy a field list use as a method.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Use either mesh with surf_list/anim_surf_list/bones or ent with child_list.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CopyRect>
<tr><td class=doctop colspan=2>Function CopyRect( srcX:Int,srcY:Int,srcW:Int,srcH:Int,dstW:Int,dstH:Int,src:Byte Ptr,dst:Byte Ptr,bPP:Int=4,invert:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy rectangle of source pixmap pixels to destination, not exactly like B3D.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>srcW/H is src size, srcX/srcY top-left position, dstW/H is dst size, bytes per pixel defaults to 4.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CopySurface>
<tr><td class=doctop colspan=2>Function CopySurface:TSurface( surf:TSurface )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a copy of the new surface.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CopyTexture>
<tr><td class=doctop colspan=2>Function CopyTexture:TTexture( tex:TTexture,flags:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a copy of the new texture.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CountMipmaps>
<tr><td class=doctop colspan=2>Function CountMipmaps:Int( tex:TTexture )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the number of mipmaps a texture has.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateBlob>
<tr><td class=doctop colspan=2>Function CreateBlob:TBlob( fluid:TFluid,radius:Float,parent_ent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create blob from a fluid mesh where radius is the size of the blob.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateBone>
<tr><td class=doctop colspan=2>Function CreateBone:TBone( mesh:TMesh,parent_ent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create bone.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateConstraint>
<tr><td class=doctop colspan=2>Function CreateConstraint:TConstraint( p1:TEntity,p2:TEntity,l:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create constraint force between two entities of given length, doesn't affect rotation.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateFluid>
<tr><td class=doctop colspan=2>Function CreateFluid:TFluid()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create fluid mesh for blobs to use.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateFragShader>
<tr><td class=doctop colspan=2>Function CreateFragShader:TShaderObject( shader:TShader,shaderFileName:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a new frag shader object from file.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateFragShaderString>
<tr><td class=doctop colspan=2>Function CreateFragShaderString:TShaderObject( shader:TShader,shadercode:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a new frag shader object from string.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateGeosphere>
<tr><td class=doctop colspan=2>Function CreateGeosphere:TGeosphere( size:Int,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create geodesic sphere and set terrain size.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateOcTree>
<tr><td class=doctop colspan=2>Function CreateOcTree:TOcTree( w:Float,h:Float,d:Float,parent_ent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create octree and set its width, height and depth.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateParticleEmitter>
<tr><td class=doctop colspan=2>Function CreateParticleEmitter:TParticleEmitter( particle:TEntity,parent_ent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create particle emitter and set sprite for it to use.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreatePostFX>
<tr><td class=doctop colspan=2>Function CreatePostFX:TPostFX( cam:TCamera,passes:Int=1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>undocumented.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateQuad>
<tr><td class=doctop colspan=2>Function CreateQuad:TMesh( parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create flat quad.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateRigidBody>
<tr><td class=doctop colspan=2>Function CreateRigidBody:TRigidBody( body:TEntity,p1:TEntity,p2:TEntity,p3:TEntity,p4:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create rigid physics body attached to four entities.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateShader>
<tr><td class=doctop colspan=2>Function CreateShader:TShader( ShaderName:String,VshaderString:String,FshaderString:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Load shader from two strings, vertex and fragment.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateShaderMaterial>
<tr><td class=doctop colspan=2>Function CreateShaderMaterial:TShader( ShaderName:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a new shader material without creating any shader objects.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateShaderVGF>
<tr><td class=doctop colspan=2>Function CreateShaderVGF:TShader( ShaderName:String,VshaderString:String,GshaderString:String,FshaderString:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Load shader from three strings, vertex, geometry and fragment.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateShadow>
<tr><td class=doctop colspan=2>Function CreateShadow:TShadowObject( parent:TMesh,Static:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create stencil shadow, static is for static or dynamic shadows.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateStencil>
<tr><td class=doctop colspan=2>Function CreateStencil:TStencil()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create stencil object.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateVertShader>
<tr><td class=doctop colspan=2>Function CreateVertShader:TShaderObject( shader:TShader,shaderFileName:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a new vert shader object from file.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateVertShaderString>
<tr><td class=doctop colspan=2>Function CreateVertShaderString:TShaderObject( shader:TShader,shadercode:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a new vert shader object from string.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateVoxelSprite>
<tr><td class=doctop colspan=2>Function CreateVoxelSprite:TVoxelSprite( slices:Int=64,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create voxel sprite where slices is the number of sprites.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=DeleteFragShader>
<tr><td class=doctop colspan=2>Function DeleteFragShader( myShader:TShaderObject )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Deletes a frag shader object from a program object.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=DeleteVertShader>
<tr><td class=doctop colspan=2>Function DeleteVertShader( myShader:TShaderObject )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Deletes a vert shader object from a program object.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=DepthBufferToTex>
<tr><td class=doctop colspan=2>Function DepthBufferToTex( tex:TTexture,cam:TCamera=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy the contents of the depth buffer to a texture.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EmitterParticleAlpha>
<tr><td class=doctop colspan=2>Function EmitterParticleAlpha( emit:TParticleEmitter,starta:Float,enda:Float,mida:Float=0,midlife:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set particles alpha at start and end, range is 0..1.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EmitterParticleColor>
<tr><td class=doctop colspan=2>Function EmitterParticleColor( emit:TParticleEmitter,startr:Float,startg:Float,startb:Float,endr:Float,endg:Float,endb:Float,midr:Float=255,midg:Float=255,midb:Float=255,midlife:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set particles RGB color at start and end, default is 255,255,255.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EmitterParticleFunction>
<tr><td class=doctop colspan=2>Function EmitterParticleFunction( emit:TParticleEmitter,EmitterFunction( ent:Byte Ptr,life:Int ) )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Points to callback function for emitter.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This gives access to each particle and also current life left.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EmitterParticleLife>
<tr><td class=doctop colspan=2>Function EmitterParticleLife( emit:TParticleEmitter,startl:Int,endl:Int,randl:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set particles start, end and random lifespan.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>startl sets when a particle becomes visible, endl is full life and randl is the random range.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EmitterParticleRotate>
<tr><td class=doctop colspan=2>Function EmitterParticleRotate( emit:TParticleEmitter,startr:Float,endr:Float,midr:Float=0,midlife:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set particles rotation angle at start and end.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Minus values will rotate clockwise.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EmitterParticleScale>
<tr><td class=doctop colspan=2>Function EmitterParticleScale( emit:TParticleEmitter,startx:Float,starty:Float,endx:Float,endy:Float,midsx:Float=1,midsy:Float=1,midlife:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set particles scale at start and end, default is 1.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EmitterParticleSpeed>
<tr><td class=doctop colspan=2>Function EmitterParticleSpeed( emit:TParticleEmitter,starts:Float,ends:Float=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set particles start and end speed.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Minus end values can be used to slow particles down.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EmitterRate>
<tr><td class=doctop colspan=2>Function EmitterRate( emit:TParticleEmitter,r:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rate between each emission, range is 0.01..1.01.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This is a way to slow particle emissions down. A rate of 1.01 is full rate.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EmitterVariance>
<tr><td class=doctop colspan=2>Function EmitterVariance( emit:TParticleEmitter,v:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set random variance of particles, range is 0.001..0.1.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Variance will be increasing chaotic above 0.1.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EmitterVector>
<tr><td class=doctop colspan=2>Function EmitterVector( emit:TParticleEmitter,startx:Float,starty:Float,startz:Float,endx:Float,endy:Float,endz:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set emitters start and end 3d vectors.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Vectors are affected by speed. Minus end values can be used to slow particles.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EndAction>
<tr><td class=doctop colspan=2>Function EndAction( act:TAction )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Ends action so it can be freed, 1 = automatically ended, 2 = manually ended.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EndMax2D>
<tr><td class=doctop colspan=2>Function EndMax2D( version:Int=1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Old end function as in Minib3d is 0, new end function is 1 (default)</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityMatrix>
<tr><td class=doctop colspan=2>Function EntityMatrix:Float Ptr( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>undocumented.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityScaleX>
<tr><td class=doctop colspan=2>Function EntityScaleX:Float( ent:TEntity,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the scale for the x axis of an entity set with ScaleEntity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>If glob is true then it's relative to any parents.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityScaleY>
<tr><td class=doctop colspan=2>Function EntityScaleY:Float( ent:TEntity,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the scale for the y axis of an entity set with ScaleEntity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>If glob is true then it's relative to any parents.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityScaleZ>
<tr><td class=doctop colspan=2>Function EntityScaleZ:Float( ent:TEntity,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the scale for the z axis of an entity set with ScaleEntity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>If glob is true then it's relative to any parents.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FluidArray>
<tr><td class=doctop colspan=2>Function FluidArray( fluid:TFluid,Array:Float Var,w:Int,h:Int,d:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create custom rendering array data for fluid mesh and set width, height and depth.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FluidFunction>
<tr><td class=doctop colspan=2>Function FluidFunction( fluid:TFluid,FieldFunction:Float( x:Float,y:Float,z:Float ) )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set custom rendering callback function for fluid mesh.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FluidThreshold>
<tr><td class=doctop colspan=2>Function FluidThreshold( fluid:TFluid,threshold:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set threshold value used in fluid rendering algorithm, 0.5 is default.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FreeAction>
<tr><td class=doctop colspan=2>Function FreeAction( act:TAction )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Frees action from memory when it has ended.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FreeBrushTextures>
<tr><td class=doctop colspan=2>Function FreeBrushTextures( brush:TBrush )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Frees all brush textures, FreeBrush does not free textures.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FreeShader>
<tr><td class=doctop colspan=2>Function FreeShader( shader:TShader ) ' Spinduluz</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Frees a shader material.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FreeShadow>
<tr><td class=doctop colspan=2>Function FreeShadow( shad:TShadowObject )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Free stencil shadow.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FreeStencil>
<tr><td class=doctop colspan=2>Function FreeStencil( stencil:TStencil ) ' Spinduluz</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Frees a stencil object.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FreeSurface>
<tr><td class=doctop colspan=2>Function FreeSurface( surf:TSurface )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Frees VBO data and brush.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GeosphereHeight>
<tr><td class=doctop colspan=2>Function GeosphereHeight( geo:TGeosphere,h:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set terrain height normalizing value, 0.05 is default.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GetMeshLoader>
<tr><td class=doctop colspan=2>Function GetMeshLoader:TMeshLoader(extension:String)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a mesh loader capable of loading <b>extension</b>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GetShaderProgram>
<tr><td class=doctop colspan=2>Function GetShaderProgram:Int( material:TShader )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get a shader program object reference.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GetString>
<tr><td class=doctop colspan=2>Function GetString:String( obj:Object,strPtr:Byte Ptr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Gets a Blitz string from a C string.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GlobalAnIsotropic>
<tr><td class=doctop colspan=2>Function GlobalAnIsotropic( f:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set global texture anisotropic (default for all), TextureAnIsotropic overrides it.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GlobalHeight>
<tr><td class=doctop colspan=2>Function GlobalHeight:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns global height of screen resolution.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GlobalResolution>
<tr><td class=doctop colspan=2>Function GlobalResolution( width:Int,height:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets global width and height of screen resolution.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Only needed when changing screen resolution, these globals are used in
CreateCamera, CameraViewport, CameraPick, BackBufferToTex and DepthBufferToTex.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GlobalWidth>
<tr><td class=doctop colspan=2>Function GlobalWidth:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns global width of screen resolution.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LightMesh>
<tr><td class=doctop colspan=2>Function LightMesh( mesh:TMesh,red:Float,green:Float,blue:Float,range:Float=0,light_x:Float=0,light_y:Float=0,light_z:Float=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Performs a 'fake' lighting operation on a mesh.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>You need to use EntityFX ent,2 to enable vertex colors on the target mesh before you can see any results.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LinkShader>
<tr><td class=doctop colspan=2>Function LinkShader:Int( shader:TShader )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Link shader to a program object, as created by CreateShaderMaterial.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadAnimMesh>
<tr><td class=doctop colspan=2>Function LoadAnimMesh:TMesh( url:Object,parent:TEntity=Null,flags:Int = -1 )</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A mesh object with child meshes if any.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Loads an anim mesh, see MeshLoader.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadGeosphere>
<tr><td class=doctop colspan=2>Function LoadGeosphere:TGeosphere( file:String,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Load geodesic sphere terrain from heightmap image.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadMaterial>
<tr><td class=doctop colspan=2>Function LoadMaterial:TMaterial( filename:String,flags:Int,frame_width:Int,frame_height:Int,first_frame:Int,frame_count:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Load a texture from image for 3D texture sampling, use with voxelsprites.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Flags are texture flags, frame width/height is the size in pixels of each slice,
first frame is the index of the slice and frame count is how many slices.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadMD2>
<tr><td class=doctop colspan=2>Function LoadMD2:TMesh( url:Object,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Loads an md2 entity and returns its handle.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadMesh>
<tr><td class=doctop colspan=2>Function LoadMesh:TMesh( url:Object,parent:TEntity=Null,flags:Int = -1 )</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A mesh object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Loads a single mesh, see MeshLoader.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadShader>
<tr><td class=doctop colspan=2>Function LoadShader:TShader( ShaderName:String,VshaderFileName:String,FshaderFileName:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Load shader from two files, vertex and fragment.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadShaderVGF>
<tr><td class=doctop colspan=2>Function LoadShaderVGF:TShader( ShaderName:String,VshaderFileName:String,GshaderFileName:String,FshaderFileName:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Load shader from three files, vertex, geometry and fragment.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=MeshCSG>
<tr><td class=doctop colspan=2>Function MeshCSG:TMesh( m1:TMesh,m2:TMesh,method_no:Int=1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Method 0 subtracts mesh2 from mesh1, 1 adds meshes, 2 intersects meshes. Returns a new mesh.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=MeshCullRadius>
<tr><td class=doctop colspan=2>Function MeshCullRadius( ent:TEntity,radius:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Equivalent of Blitz3D's MeshCullBox command. It sets the radius of a mesh's 'cull sphere'</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>If the 'cull sphere' is not inside the viewing area, the mesh will not be rendered.
A mesh's cull radius is set automatically, therefore in most cases you will not have to use this command.
One time you may have to use it is for animated meshes where the default cull radius may not take into
account all animation positions, resulting in the mesh being wrongly culled at extreme positions.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ModifyGeosphere>
<tr><td class=doctop colspan=2>Function ModifyGeosphere( geo:TGeosphere,x:Int,z:Int,new_height:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set height of a given point, like ModifyTerrain.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=MSAntiAlias>
<tr><td class=doctop colspan=2>Function MSAntiAlias( multisample:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enables or disables hardware multisample antialiasing if supported.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=NewAnimationKeys>
<tr><td class=doctop colspan=2>Function NewAnimationKeys:TAnimationKeys( bone:TBone=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TAnimationKeys object.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>keys=NewAnimationKeys()</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=NewBone>
<tr><td class=doctop colspan=2>Function NewBone:TBone()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TBone object.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>bone=NewBone()</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=NewMatPtr>
<tr><td class=doctop colspan=2>Function NewMatPtr:TMatPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TMatPtr object, returns a Float Ptr matrix.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>mat=NewMatPtr()</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=NewMesh>
<tr><td class=doctop colspan=2>Function NewMesh:TMesh()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TMesh object.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>mesh=NewMesh()</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=NewQuatPtr>
<tr><td class=doctop colspan=2>Function NewQuatPtr:TQuatPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TQuatPtr object, returns a Float Ptr quaternion.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>quat=NewQuatPtr()</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=NewSprite>
<tr><td class=doctop colspan=2>Function NewSprite:TSprite()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TSprite object.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>spr=NewSprite()</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=NewSurface>
<tr><td class=doctop colspan=2>Function NewSurface:TSurface()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TSurface object.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>surf=NewSurface()</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=NewTexture>
<tr><td class=doctop colspan=2>Function NewTexture:TTexture()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TTexture object.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>tex=NewTexture()</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=NewVecPtr>
<tr><td class=doctop colspan=2>Function NewVecPtr:TVecPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TVecPtr object, returns a Float Ptr vector.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>vec=NewVecPtr()</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=OctreeBlock>
<tr><td class=doctop colspan=2>Function OctreeBlock( octree:TOcTree,mesh:TMesh,level:Int,X:Float,Y:Float,Z:Float,Near:Float=0,Far:Float=1000 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Place mesh into a node of an octree, the mesh can be duplicated using no more memory.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Since a block is not an entity it has no position, etc. it has the properties of the node it is in.
Level defaults to 0, the higher the level the smaller the cell. XYZ is the position in the octree.
Near defaults to 0, this is the minimum distance at which that node is visible, if 0 that node is
always visible, if higher the mesh/block won't be rendered when it's closer.
Far defaults to 1000, this is the maximum distance at which the node can be split in children,
if the node is set at a higher range than the camera, its children won't be rendered.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=OctreeMesh>
<tr><td class=doctop colspan=2>Function OctreeMesh( octree:TOcTree,mesh:TMesh,level:Int,X:Float,Y:Float,Z:Float,Near:Float=0,Far:Float=1000 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Place mesh into a node of an octree, the mesh can't be duplicated so to do that use CopyEntity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ParticleColor>
<tr><td class=doctop colspan=2>Function ParticleColor( sprite:TSprite,r:Float,g:Float,b:Float,a:Float=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets color of batch particle trails.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Batch particle render mode (3) is not working.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ParticleTrail>
<tr><td class=doctop colspan=2>Function ParticleTrail( sprite:TSprite,length:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets number of batch particles in trail.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Batch particle render mode (3) is not working.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ParticleVector>
<tr><td class=doctop colspan=2>Function ParticleVector( sprite:TSprite,x:Float,y:Float,z:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets 3d vector of batch particle trails.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Batch particle render mode (3) is not working.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PositionAnimMesh>
<tr><td class=doctop colspan=2>Function PositionAnimMesh( mesh:TMesh,px#,py#,pz# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Moves all vertices of mesh and every child mesh.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PostFXBuffer>
<tr><td class=doctop colspan=2>Function PostFXBuffer( fx:TPostFX,pass_no:Int,source_pass:Int,index:Int,slot:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>undocumented.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PostFXFunction>
<tr><td class=doctop colspan=2>Function PostFXFunction( fx:TPostFX,pass_no:Int,PassFunction() )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>undocumented.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PostFXShader>
<tr><td class=doctop colspan=2>Function PostFXShader( fx:TPostFX,pass_no:Int,shader:TShader )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>undocumented.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PostFXShaderPass>
<tr><td class=doctop colspan=2>Function PostFXShaderPass( fx:TPostFX,pass_no:Int,name:String,v:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>undocumented.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PostFXTexture>
<tr><td class=doctop colspan=2>Function PostFXTexture( fx:TPostFX,pass_no:Int,tex:TTexture,slot:Int,frame:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>undocumented.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=RepeatMesh>
<tr><td class=doctop colspan=2>Function RepeatMesh:TMesh( mesh:TMesh,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Like CopyMesh but for instancing effects.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ResetShadow>
<tr><td class=doctop colspan=2>Function ResetShadow( shad:TShadowObject )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Reset created flag to update static shadow.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=RotateAnimMesh>
<tr><td class=doctop colspan=2>Function RotateAnimMesh( mesh:TMesh,rx#,ry#,rz# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotates all vertices of mesh and every child mesh.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ScaleAnimMesh>
<tr><td class=doctop colspan=2>Function ScaleAnimMesh( mesh:TMesh,sx#,sy#,sz# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Scales all vertices of mesh and every child mesh.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetFloat>
<tr><td class=doctop colspan=2>Function SetFloat( material:TShader,name:String,v1:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set a shader variable name of a uniform float type to a float value.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetFloat2>
<tr><td class=doctop colspan=2>Function SetFloat2( material:TShader,name:String,v1:Float,v2:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set a shader variable name of a uniform vec2 type to 2 float values.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetFloat3>
<tr><td class=doctop colspan=2>Function SetFloat3( material:TShader,name:String,v1:Float,v2:Float,v3:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set a shader variable name of a uniform vec3 type to 3 float values.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetFloat4>
<tr><td class=doctop colspan=2>Function SetFloat4( material:TShader,name:String,v1:Float,v2:Float,v3:Float,v4:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set a shader variable name of a uniform vec4 type to 4 float values.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetInteger>
<tr><td class=doctop colspan=2>Function SetInteger( material:TShader,name:String,v1:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set a shader variable name of a uniform int type to an integer value.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetInteger2>
<tr><td class=doctop colspan=2>Function SetInteger2( material:TShader,name:String,v1:Int,v2:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set a shader variable name of a uniform ivec2 type to 2 integer values.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetInteger3>
<tr><td class=doctop colspan=2>Function SetInteger3( material:TShader,name:String,v1:Int,v2:Int,v3:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set a shader variable name of a uniform ivec3 type to 3 integer values.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetInteger4>
<tr><td class=doctop colspan=2>Function SetInteger4( material:TShader,name:String,v1:Int,v2:Int,v3:Int,v4:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set a shader variable name of a uniform ivec4 type to 4 integer values.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetShadowColor>
<tr><td class=doctop colspan=2>Function SetShadowColor( R:Int,G:Int,B:Int,A:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set color R/G/B in range 0..255 and A in range 0..1.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetString>
<tr><td class=doctop colspan=2>Function SetString:String( obj:Object,strPtr:Byte Ptr,strValue:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets a C string from a Blitz string.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ShadeEntity>
<tr><td class=doctop colspan=2>Function ShadeEntity( ent:TEntity,material:TShader )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Apply shader to an entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ShadeMesh>
<tr><td class=doctop colspan=2>Function ShadeMesh( mesh:TMesh,material:TShader )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Apply shader to a mesh.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ShaderFunction>
<tr><td class=doctop colspan=2>Function ShaderFunction( material:TShader,EnableFunction(),DisableFunction() )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>undocumented.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ShaderMaterial>
<tr><td class=doctop colspan=2>Function ShaderMaterial( material:TShader,tex:TMaterial,name:String,index:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set a 3d texture for sampling.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ShaderTexture>
<tr><td class=doctop colspan=2>Function ShaderTexture:TTexture( material:TShader,tex:TTexture,name:String,index:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Load a texture for 2D texture sampling.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ShadeSurface>
<tr><td class=doctop colspan=2>Function ShadeSurface( surf:TSurface,material:TShader )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Apply shader to a surface.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SkinMesh>
<tr><td class=doctop colspan=2>Function SkinMesh( mesh:TMesh,surf_no_get:Int,vid:Int,bone1:Int,weight1:Float=1.0,bone2:Int=0,weight2:Float=0,bone3:Int=0,weight3:Float=0,bone4:Int=0,weight4:Float=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set animated surface for each of the bone no and weights arrays.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>bone no references the bones list in a mesh, weights is a normalizing value.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SpriteRenderMode>
<tr><td class=doctop colspan=2>Function SpriteRenderMode( sprite:TSprite,Mode:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>If mode is 1 rendering is normal, 2 is for batch sprites like particles.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Batch particle render mode (3) is not working.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=StencilAlpha>
<tr><td class=doctop colspan=2>Function StencilAlpha( stencil:TStencil,a:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set stencil alpha value.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=StencilClsColor>
<tr><td class=doctop colspan=2>Function StencilClsColor( stencil:TStencil,r:Float,g:Float,b:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set stencil clear screen color in range 0..255.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=StencilClsMode>
<tr><td class=doctop colspan=2>Function StencilClsMode( stencil:TStencil,cls_color:Int,cls_zbuffer:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set stencil clear screen modes.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Cls_color is true to use the color buffer, cls_zbuffer is true to use the depth buffer.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=StencilMesh>
<tr><td class=doctop colspan=2>Function StencilMesh( stencil:TStencil,mesh:TMesh,Mode:Int=1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set mesh to be used as stencil.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Mode is stencil action for glStencilOp in range -2..2 where 1 is INCR (default),
2 is INCR for stencil shadow meshes and negative values are DECR.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=StencilMode>
<tr><td class=doctop colspan=2>Function StencilMode( stencil:TStencil,m:Int,o:Int=1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set stencil render modes.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>M is stencil action mode for glStencilOp in range -2..2 where 1 is INCR (default),
2 is INCR for stencil shadow meshes and negative values are DECR. O is comparison operator for
glStencilFunc in range 0..3 which stands for one of NOTEQUAL, EQUAL, LEQUAL or GEQUAL.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=StringPtr>
<tr><td class=doctop colspan=2>Function StringPtr:String( inst:Byte Ptr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns string cast of byte pointer.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SurfsRendered>
<tr><td class=doctop colspan=2>Function SurfsRendered:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Number of surfaces currently being rendered.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TerrainDetail>
<tr><td class=doctop colspan=2>Function TerrainDetail( terr:TTerrain,detail_level:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set terrain level of detail, default is 100 and maximum is 2000.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TerrainRange>
<tr><td class=doctop colspan=2>Function TerrainRange( terr:TTerrain,camera_range:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set terrain camera range to alter pop/switch distance, a value from 0 to 100.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TexToBuffer>
<tr><td class=doctop colspan=2>Function TexToBuffer( tex:TTexture,buffer:Byte Ptr,frame:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy texture to a pixmap buffer, buffer must be a byte ptr.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TextureAnIsotropic>
<tr><td class=doctop colspan=2>Function TextureAnIsotropic( tex:TTexture,f:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set texture anisotropic factor, usually from 2-16.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TextureFlags>
<tr><td class=doctop colspan=2>Function TextureFlags( tex:TTexture,flags:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set texture flags, see LoadTexture for values.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TextureGLTexEnvf>
<tr><td class=doctop colspan=2>Function TextureGLTexEnvf( tex:TTexture,target:Int,pname:Int,param:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>GL equivalent, param is a float, limited to 12 calls per texture, experimental.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TextureGLTexEnvi>
<tr><td class=doctop colspan=2>Function TextureGLTexEnvi( tex:TTexture,target:Int,pname:Int,param:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>GL equivalent, param is a const, limited to 12 calls per texture, experimental.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TextureMultitex>
<tr><td class=doctop colspan=2>Function TextureMultitex( tex:TTexture,f:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set texture multitex factor, used in interpolate and custom TexBlend options.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TrisRendered>
<tr><td class=doctop colspan=2>Function TrisRendered:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Number of triangles currently being rendered.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UpdateTexCoords>
<tr><td class=doctop colspan=2>Function UpdateTexCoords( surf:TSurface )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Recalculates the surface's uvw coord set 1 based on vertices.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseAssimpStreamMeshes>
<tr><td class=doctop colspan=2>Function UseAssimpStreamMeshes( flag:Int=True,meshflags:Int=-1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Loader flags for Assimp meshes.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Set flag to False to use Assimp direct loaders, default is True for Assimp streamed loaders.
Set meshflags to -1 for smooth normals, -2 for flat shaded normals and -4 to load as single mesh.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseCubemapFlip>
<tr><td class=doctop colspan=2>Function UseCubemapFlip( flag:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Flip cubemap texture flag.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Set flag to True to flip cubemap textures, default is False to not flip (invert).</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseEntity>
<tr><td class=doctop colspan=2>Function UseEntity( material:TShader,name:String,ent:TEntity,mode:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>undocumented.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseFloat>
<tr><td class=doctop colspan=2>Function UseFloat( material:TShader,name:String,v1:Float Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Bind a float variable to a shader variable name of a uniform float type.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseFloat2>
<tr><td class=doctop colspan=2>Function UseFloat2( material:TShader,name:String,v1:Float Var,v2:Float Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Bind 2 float variables to a shader variable name of a uniform vec2 Type.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseFloat3>
<tr><td class=doctop colspan=2>Function UseFloat3( material:TShader,name:String,v1:Float Var,v2:Float Var,v3:Float Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Bind 3 float variables to a shader variable name of a uniform vec3 type.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseFloat4>
<tr><td class=doctop colspan=2>Function UseFloat4( material:TShader,name:String,v1:Float Var,v2:Float Var,v3:Float Var,v4:Float Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Bind 4 float variables to a shader variable name of a uniform vec4 type.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseInteger>
<tr><td class=doctop colspan=2>Function UseInteger( material:TShader,name:String,v1:Int Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Bind an integer variable to a shader variable name of a uniform int type.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseInteger2>
<tr><td class=doctop colspan=2>Function UseInteger2( material:TShader,name:String,v1:Int Var,v2:Int Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Bind 2 integer variables to a shader variable name of a uniform ivec2 type.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseInteger3>
<tr><td class=doctop colspan=2>Function UseInteger3( material:TShader,name:String,v1:Int Var,v2:Int Var,v3:Int Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Bind 3 integer variables to a shader variable name of a uniform ivec3 type.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseInteger4>
<tr><td class=doctop colspan=2>Function UseInteger4( material:TShader,name:String,v1:Int Var,v2:Int Var,v3:Int Var,v4:Int Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Bind 4 integer variables to a shader variable name of a uniform ivec4 type.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseLibraryMeshes>
<tr><td class=doctop colspan=2>Function UseLibraryMeshes( flag:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Loader flag for meshes.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Set flag to False for Blitzmax streamed loaders, default is True for Openb3d library direct loaders.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseLibraryTextures>
<tr><td class=doctop colspan=2>Function UseLibraryTextures( flag:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Loader flag for textures.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Set flag to False for Blitzmax streamed loaders, default is True for Openb3d library direct loaders.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseMatrix>
<tr><td class=doctop colspan=2>Function UseMatrix( material:TShader,name:String,Mode:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sends matrix data to a shader variable name of a uniform mat4 type.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseMatrix3DS>
<tr><td class=doctop colspan=2>Function UseMatrix3DS( xx#,xy#,xz#,yx#,yy#,yz#,zx#,zy#,zz# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set 3DS model loader coordinates system (matrix), values should be 0,1,-1.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseMatrixMD2>
<tr><td class=doctop colspan=2>Function UseMatrixMD2( xx#,xy#,xz#,yx#,yy#,yz#,zx#,zy#,zz# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set MD2 model loader coordinates system (matrix), values should be 0,1,-1.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseMeshDebugLog>
<tr><td class=doctop colspan=2>Function UseMeshDebugLog( flag:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Debug all mesh loaders.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Set flag to False to not debug Blitzmax mesh loaders, default is True to enable debug log.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseMeshTextureFlags>
<tr><td class=doctop colspan=2>Function UseMeshTextureFlags( texflags:Int=-1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set mesh texture flags.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Override mesh texture flags manually, default is -1 (only for 3DS and OBJ).</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseMeshTransform>
<tr><td class=doctop colspan=2>Function UseMeshTransform( flag:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Transform mesh loaders.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Set flag to False to not transform meshes, default is True to enable transforms (Blitzmax 3DS only).</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseStencil>
<tr><td class=doctop colspan=2>Function UseStencil( stencil:TStencil )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Stencil to use, set to Null to disable stencil.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseSurface>
<tr><td class=doctop colspan=2>Function UseSurface( material:TShader,name:String,surf:TSurface,vbo:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sends surface data to a shader variable name.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Vbo is in range 1..6 which selects what vertex buffer data to access, where 1 is vertex positions,
2/3 is tex coords 0/1, 4 is vertex normals, 5 is vertex color, 6 is triangles.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseTextureFaces>
<tr><td class=doctop colspan=2>Function UseTextureFaces( lf0:Int=0,fr1:Int=0,rt2:Int=0,bk3:Int=0,dn4:Int=0,up5:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Order for cubemap faces.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Define the order to load cubemap faces, default is 0,1,2,3,4,5 (B3D layout).</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UseTextureFrames>
<tr><td class=doctop colspan=2>Function UseTextureFrames( lf0:Int=0,fr1:Int=0,rt2:Int=0,bk3:Int=0,dn4:Int=0,up5:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Order for anim texture frames.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Define the order to load anim texture frames, default is 0,1,2,3,4,5.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertsRendered>
<tr><td class=doctop colspan=2>Function VertsRendered:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Number of vertices currently being rendered.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VoxelSpriteMaterial>
<tr><td class=doctop colspan=2>Function VoxelSpriteMaterial( voxelspr:TVoxelSprite,mat:TMaterial )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set material for voxel sprite.</td></tr>
</table>
<br>
<h2
 id=typesdet>Types
</h2>
<table class=doc width=100% cellspacing=3 id=TAction>
<tr><td class=doctop colspan=2>Type TAction</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Action.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TAnimationKeys>
<tr><td class=doctop colspan=2>Type TAnimationKeys</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>AnimationKeys data.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TBlitz2D>
<tr><td class=doctop colspan=2>Type TBlitz2D</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Blitz2D.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TBlob>
<tr><td class=doctop colspan=2>Type TBlob Extends TEntity</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Blob entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TBone>
<tr><td class=doctop colspan=2>Type TBone Extends TEntity</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Bone entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TBrush>
<tr><td class=doctop colspan=2>Type TBrush</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Brush.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TCamera>
<tr><td class=doctop colspan=2>Type TCamera Extends TEntity</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Camera entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TConstraint>
<tr><td class=doctop colspan=2>Type TConstraint</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Constraint.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TEntity>
<tr><td class=doctop colspan=2>Type TEntity</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TFluid>
<tr><td class=doctop colspan=2>Type TFluid Extends TMesh</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Fluid mesh entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TGeosphere>
<tr><td class=doctop colspan=2>Type TGeosphere Extends TTerrain</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Geosphere terrain entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TGlobal3D>
<tr><td class=doctop colspan=2>Type TGlobal3D</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Global.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Renamed to fix conflict with BRL.Reflection.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=THardwareInfo>
<tr><td class=doctop colspan=2>Type THardwareInfo ' by klepto2</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Hardware info.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Contains <b>Function GetInfo()</b> And <b>DisplayInfo(LogFile:Int=False)</b>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TLight>
<tr><td class=doctop colspan=2>Type TLight Extends TEntity</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Light entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TMaterial>
<tr><td class=doctop colspan=2>Type TMaterial Extends TTexture</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Material texture.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TMatPtr>
<tr><td class=doctop colspan=2>Type TMatPtr</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>MatPtr functions (Openb3d)</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TMatPtr_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#Copy>Copy</a></td><td class=docright>
Copy self, returns a new matrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#FromQuaternion>FromQuaternion</a></td><td class=docright>
Convert self to a rotation matrix from a quaternion.
</td></tr>
<tr><td class=docleft width=1%><a href=#FromToRotation>FromToRotation</a></td><td class=docright>
Transformation self to a rotation matrix from two given vectors.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetInverse>GetInverse</a></td><td class=docright>
Get inverse of the given TMatPtr and overwrite it, returns nothing.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetInverse2>GetInverse2</a></td><td class=docright>
Get inverse of the given TMatPtr and overwrite it, returns nothing (used in collision2.cpp)
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMatrix>GetMatrix</a></td><td class=docright>
Overwrite self with the given TMatrix, returns nothing (like CopyMatrix)
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMatrixScale>GetMatrixScale</a></td><td class=docright>
Get scale (magnitude) of self, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetPitch>GetPitch</a></td><td class=docright>
Returns pitch of self.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetRoll>GetRoll</a></td><td class=docright>
Returns roll of self.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetYaw>GetYaw</a></td><td class=docright>
Returns yaw of self.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadIdentity>LoadIdentity</a></td><td class=docright>
Set self as identity matrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#Multiply>Multiply</a></td><td class=docright>
Multiply self by the given matrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#Multiply2>Multiply2</a></td><td class=docright>
Multiply self by the given matrix (same as Multiply)
</td></tr>
<tr><td class=docleft width=1%><a href=#Overwrite>Overwrite</a></td><td class=docright>
Overwrite self with the given TMatPtr.
</td></tr>
<tr><td class=docleft width=1%><a href=#Rotate>Rotate</a></td><td class=docright>
Rotate self by pitch, yaw, roll (Euler degrees)
</td></tr>
<tr><td class=docleft width=1%><a href=#RotatePitch>RotatePitch</a></td><td class=docright>
Rotate self about the x axis (Euler degrees)
</td></tr>
<tr><td class=docleft width=1%><a href=#RotateRoll>RotateRoll</a></td><td class=docright>
Rotate self about the z axis (Euler degrees)
</td></tr>
<tr><td class=docleft width=1%><a href=#RotateYaw>RotateYaw</a></td><td class=docright>
Rotate self about the y axis (Euler degrees)
</td></tr>
<tr><td class=docleft width=1%><a href=#Scale>Scale</a></td><td class=docright>
Scale self (set the diagonal elements to x, y, z)
</td></tr>
<tr><td class=docleft width=1%><a href=#SetIdentity>SetIdentity</a></td><td class=docright>
Set matrix identity.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetTranslate>SetTranslate</a></td><td class=docright>
Set translate vector for self.
</td></tr>
<tr><td class=docleft width=1%><a href=#ToQuat>ToQuat</a></td><td class=docright>
Convert self to the given quaternion.
</td></tr>
<tr><td class=docleft width=1%><a href=#TransformVec>TransformVec</a></td><td class=docright>
Transform the given vector by self.
</td></tr>
<tr><td class=docleft width=1%><a href=#Translate>Translate</a></td><td class=docright>
Translate (move) self by the given vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Transpose>Transpose</a></td><td class=docright>
Transpose self.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TMatPtr_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#CopyMatrix>CopyMatrix</a></td><td class=docright>
Copy the given TMatrix, returns a new Float Ptr matrix (like GetMatrix)
</td></tr>
<tr><td class=docleft width=1%><a href=#Create>Create</a></td><td class=docright>
Creates a new TMatPtr object, returns a Float Ptr matrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#InterpolateMatrix>InterpolateMatrix</a></td><td class=docright>
Interpolate two TMatPtrs by a relative value (used in AlignToVector)
</td></tr>
<tr><td class=docleft width=1%><a href=#Magnitude>Magnitude</a></td><td class=docright>
Return magnitude (length) of the given vector, returns a float.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewMatPtr>NewMatPtr</a></td><td class=docright>
Returns a new TMatPtr object.
</td></tr>
<tr><td class=docleft width=1%><a href=#Quaternion_FromAngleAxis>Quaternion_FromAngleAxis</a></td><td class=docright>
Create a quaternion from an angle and an axis, sets the given quaternion.
</td></tr>
<tr><td class=docleft width=1%><a href=#Quaternion_MultiplyQuat>Quaternion_MultiplyQuat</a></td><td class=docright>
Multiply two quaternions, sets the given quaternion.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Copy>
<tr><td class=doctop colspan=2>Method Copy:TMatPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy self, returns a new matrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=FromQuaternion>
<tr><td class=doctop colspan=2>Method FromQuaternion( x:Float,y:Float,z:Float,w:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Convert self to a rotation matrix from a quaternion.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=FromToRotation>
<tr><td class=doctop colspan=2>Method FromToRotation( ix:Float,iy:Float,iz:Float,jx:Float,jy:Float,jz:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Transformation self to a rotation matrix from two given vectors.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetInverse>
<tr><td class=doctop colspan=2>Method GetInverse( mat:TMatPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get inverse of the given TMatPtr and overwrite it, returns nothing.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetInverse2>
<tr><td class=doctop colspan=2>Method GetInverse2( mat:TMatPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get inverse of the given TMatPtr and overwrite it, returns nothing (used in collision2.cpp)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMatrix>
<tr><td class=doctop colspan=2>Method GetMatrix:TMatPtr( mat:TMatrix )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Overwrite self with the given TMatrix, returns nothing (like CopyMatrix)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMatrixScale>
<tr><td class=doctop colspan=2>Method GetMatrixScale:TVecPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get scale (magnitude) of self, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetPitch>
<tr><td class=doctop colspan=2>Method GetPitch:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns pitch of self.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetRoll>
<tr><td class=doctop colspan=2>Method GetRoll:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns roll of self.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetYaw>
<tr><td class=doctop colspan=2>Method GetYaw:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns yaw of self.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=LoadIdentity>
<tr><td class=doctop colspan=2>Method LoadIdentity()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set self as identity matrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Multiply>
<tr><td class=doctop colspan=2>Method Multiply( mat:TMatPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Multiply self by the given matrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Multiply2>
<tr><td class=doctop colspan=2>Method Multiply2( mat:TMatPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Multiply self by the given matrix (same as Multiply)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Overwrite>
<tr><td class=doctop colspan=2>Method Overwrite( mat:TMatPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Overwrite self with the given TMatPtr.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Rotate>
<tr><td class=doctop colspan=2>Method Rotate( rx:Float,ry:Float,rz:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotate self by pitch, yaw, roll (Euler degrees)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=RotatePitch>
<tr><td class=doctop colspan=2>Method RotatePitch( ang:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotate self about the x axis (Euler degrees)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=RotateRoll>
<tr><td class=doctop colspan=2>Method RotateRoll( ang:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotate self about the z axis (Euler degrees)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=RotateYaw>
<tr><td class=doctop colspan=2>Method RotateYaw( ang:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotate self about the y axis (Euler degrees)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Scale>
<tr><td class=doctop colspan=2>Method Scale( x:Float,y:Float,z:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Scale self (set the diagonal elements to x, y, z)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetIdentity>
<tr><td class=doctop colspan=2>Method SetIdentity( xx#,xy#,xz#,yx#,yy#,yz#,zx#,zy#,zz# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set matrix identity.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetTranslate>
<tr><td class=doctop colspan=2>Method SetTranslate( x:Float,y:Float,z:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set translate vector for self.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=ToQuat>
<tr><td class=doctop colspan=2>Method ToQuat( qx:Float Var,qy:Float Var,qz:Float Var,qw:Float Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Convert self to the given quaternion.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=TransformVec>
<tr><td class=doctop colspan=2>Method TransformVec( rx:Float Var,ry:Float Var,rz:Float Var,addTranslation:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Transform the given vector by self.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Translate>
<tr><td class=doctop colspan=2>Method Translate( x:Float,y:Float,z:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Translate (move) self by the given vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Transpose>
<tr><td class=doctop colspan=2>Method Transpose()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Transpose self.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CopyMatrix>
<tr><td class=doctop colspan=2>Function CopyMatrix:TMatPtr( mat:TMatrix )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy the given TMatrix, returns a new Float Ptr matrix (like GetMatrix)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Create>
<tr><td class=doctop colspan=2>Function Create:TMatPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a new TMatPtr object, returns a Float Ptr matrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=InterpolateMatrix>
<tr><td class=doctop colspan=2>Function InterpolateMatrix( m:TMatPtr,a:TMatPtr,alpha:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Interpolate two TMatPtrs by a relative value (used in AlignToVector)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Magnitude>
<tr><td class=doctop colspan=2>Function Magnitude:Float( x:Float,y:Float,z:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Return magnitude (length) of the given vector, returns a float.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=NewMatPtr>
<tr><td class=doctop colspan=2>Function NewMatPtr:TMatPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a new TMatPtr object.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Quaternion_FromAngleAxis>
<tr><td class=doctop colspan=2>Function Quaternion_FromAngleAxis( angle:Float,ax:Float,ay:Float,az:Float,rx:Float Var,ry:Float Var,rz:Float Var,rw:Float Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a quaternion from an angle and an axis, sets the given quaternion.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Quaternion_MultiplyQuat>
<tr><td class=doctop colspan=2>Function Quaternion_MultiplyQuat( x1:Float,y1:Float,z1:Float,w1:Float,x2:Float,y2:Float,z2:Float,w2:Float,rx:Float Var,ry:Float Var,rz:Float Var,rw:Float Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Multiply two quaternions, sets the given quaternion.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TMatrix>
<tr><td class=doctop colspan=2>Type TMatrix</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Matrix functions (Minib3d)</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TMatrix_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#Copy>Copy</a></td><td class=docright>
Copy self, returns a new matrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMatPtr>GetMatPtr</a></td><td class=docright>
Overwrite self with the given TMatPtr, returns nothing (like CopyMatPtr)
</td></tr>
<tr><td class=docleft width=1%><a href=#Inverse>Inverse</a></td><td class=docright>
Get inverse of self, returns a new matrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadIdentity>LoadIdentity</a></td><td class=docright>
Set self as identity matrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#Multiply>Multiply</a></td><td class=docright>
Multiply self by the given matrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#New>New</a></td><td class=docright>
Returns a new TMatrix object.
</td></tr>
<tr><td class=docleft width=1%><a href=#Overwrite>Overwrite</a></td><td class=docright>
Overwrite self with the given TMatrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#Rotate>Rotate</a></td><td class=docright>
Rotate self by yaw, pitch and roll (Euler degrees)
</td></tr>
<tr><td class=docleft width=1%><a href=#RotatePitch>RotatePitch</a></td><td class=docright>
Rotate self about the x axis (Euler degrees)
</td></tr>
<tr><td class=docleft width=1%><a href=#RotateRoll>RotateRoll</a></td><td class=docright>
Rotate self about the z axis (Euler degrees)
</td></tr>
<tr><td class=docleft width=1%><a href=#RotateYaw>RotateYaw</a></td><td class=docright>
Rotate self about the y axis (Euler degrees)
</td></tr>
<tr><td class=docleft width=1%><a href=#Scale>Scale</a></td><td class=docright>
Scale self (set the diagonal elements to x, y, z)
</td></tr>
<tr><td class=docleft width=1%><a href=#SetIdentity>SetIdentity</a></td><td class=docright>
Set matrix identity.
</td></tr>
<tr><td class=docleft width=1%><a href=#Translate>Translate</a></td><td class=docright>
Translate (move) self.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TMatrix_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#CopyMatPtr>CopyMatPtr</a></td><td class=docright>
Copy the given TMatPtr, returns a new Float matrix (like GetMatPtr)
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Copy>
<tr><td class=doctop colspan=2>Method Copy:TMatrix()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy self, returns a new matrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMatPtr>
<tr><td class=doctop colspan=2>Method GetMatPtr:TMatrix( mat:TMatPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Overwrite self with the given TMatPtr, returns nothing (like CopyMatPtr)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Inverse>
<tr><td class=doctop colspan=2>Method Inverse:TMatrix()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get inverse of self, returns a new matrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=LoadIdentity>
<tr><td class=doctop colspan=2>Method LoadIdentity()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set self as identity matrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Multiply>
<tr><td class=doctop colspan=2>Method Multiply( mat:TMatrix )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Multiply self by the given matrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=New>
<tr><td class=doctop colspan=2>Method New()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a new TMatrix object.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Overwrite>
<tr><td class=doctop colspan=2>Method Overwrite( mat:TMatrix )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Overwrite self with the given TMatrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Rotate>
<tr><td class=doctop colspan=2>Method Rotate( rx#,ry#,rz# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotate self by yaw, pitch and roll (Euler degrees)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=RotatePitch>
<tr><td class=doctop colspan=2>Method RotatePitch( ang# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotate self about the x axis (Euler degrees)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=RotateRoll>
<tr><td class=doctop colspan=2>Method RotateRoll( ang# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotate self about the z axis (Euler degrees)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=RotateYaw>
<tr><td class=doctop colspan=2>Method RotateYaw( ang# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotate self about the y axis (Euler degrees)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Scale>
<tr><td class=doctop colspan=2>Method Scale( x#,y#,z# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Scale self (set the diagonal elements to x, y, z)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetIdentity>
<tr><td class=doctop colspan=2>Method SetIdentity( xx#,xy#,xz#,yx#,yy#,yz#,zx#,zy#,zz# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set matrix identity.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Translate>
<tr><td class=doctop colspan=2>Method Translate( x#,y#,z# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Translate (move) self.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CopyMatPtr>
<tr><td class=doctop colspan=2>Function CopyMatPtr:TMatrix( mat:TMatPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy the given TMatPtr, returns a new Float matrix (like GetMatPtr)</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TMesh>
<tr><td class=doctop colspan=2>Type TMesh Extends TEntity</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Mesh entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TMeshLoader>
<tr><td class=doctop colspan=2>Type TMeshLoader</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Mesh loader.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TMeshLoader_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#LoadAnimMesh>LoadAnimMesh</a></td><td class=docright>
Call animated mesh loader implementation.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadMesh>LoadMesh</a></td><td class=docright>
Call mesh loader implementation.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=LoadAnimMesh>
<tr><td class=doctop colspan=2>Method LoadAnimMesh:TMesh(file:TStream, url:Object, parent:TEntity = Null, flags:Int = -1) Abstract</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Call animated mesh loader implementation.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=LoadMesh>
<tr><td class=doctop colspan=2>Method LoadMesh:TMesh(file:TStream, url:Object, parent:TEntity = Null, flags:Int = -1) Abstract</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Call mesh loader implementation.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TOcTree>
<tr><td class=doctop colspan=2>Type TOcTree Extends TTerrain</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Octree terrain entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TParticleBatch>
<tr><td class=doctop colspan=2>Type TParticleBatch Extends TMesh</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Particle Batch mesh entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TParticleEmitter>
<tr><td class=doctop colspan=2>Type TParticleEmitter Extends TEntity</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Particle Emitter entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TPick>
<tr><td class=doctop colspan=2>Type TPick</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Pick.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TPivot>
<tr><td class=doctop colspan=2>Type TPivot Extends TEntity</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Pivot entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TPostFX>
<tr><td class=doctop colspan=2>Type TPostFX</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Post effects object.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TQuaternion>
<tr><td class=doctop colspan=2>Type TQuaternion</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Quaternion functions (Minib3d)</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TQuaternion_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetQuatPtr>GetQuatPtr</a></td><td class=docright>
Overwrite self with the given TQuatPtr, returns nothing (like CopyQuatPtr)
</td></tr>
<tr><td class=docleft width=1%><a href=#New>New</a></td><td class=docright>
Returns a new TQuaternion object.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TQuaternion_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#CopyQuatPtr>CopyQuatPtr</a></td><td class=docright>
Copy the given TQuatPtr, returns a new Float quaternion (like GetQuatPtr)
</td></tr>
<tr><td class=docleft width=1%><a href=#Create>Create</a></td><td class=docright>
Create a new TQuaternion from four float values, returns a Float quaternion.
</td></tr>
<tr><td class=docleft width=1%><a href=#QuatToEuler>QuatToEuler</a></td><td class=docright>
Convert a quaternion to the given pitch, yaw, roll (Euler degrees)
</td></tr>
<tr><td class=docleft width=1%><a href=#QuatToMat>QuatToMat</a></td><td class=docright>
Convert a quaternion to the given TMatrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#Slerp>Slerp</a></td><td class=docright>
Slerp two quaternions to the given quaternion.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetQuatPtr>
<tr><td class=doctop colspan=2>Method GetQuatPtr:TQuaternion( quat:TQuatPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Overwrite self with the given TQuatPtr, returns nothing (like CopyQuatPtr)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=New>
<tr><td class=doctop colspan=2>Method New()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a new TQuaternion object.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CopyQuatPtr>
<tr><td class=doctop colspan=2>Function CopyQuatPtr:TQuaternion( quat:TQuatPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy the given TQuatPtr, returns a new Float quaternion (like GetQuatPtr)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Create>
<tr><td class=doctop colspan=2>Function Create:TQuaternion( x:Float=0,y:Float=0,z:Float=0,w:Float=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TQuaternion from four float values, returns a Float quaternion.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=QuatToEuler>
<tr><td class=doctop colspan=2>Function QuatToEuler( x#,y#,z#,w#,pitch# Var,yaw# Var,roll# Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Convert a quaternion to the given pitch, yaw, roll (Euler degrees)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=QuatToMat>
<tr><td class=doctop colspan=2>Function QuatToMat( x#,y#,z#,w#,mat:TMatrix Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Convert a quaternion to the given TMatrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Slerp>
<tr><td class=doctop colspan=2>Function Slerp:Int( Ax#,Ay#,Az#,Aw#,Bx#,By#,Bz#,Bw#,Cx# Var,Cy# Var,Cz# Var,Cw# Var,t# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Slerp two quaternions to the given quaternion.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TQuatPtr>
<tr><td class=doctop colspan=2>Type TQuatPtr</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>QuatPtr functions (Openb3d)</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TQuatPtr_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetQuaternion>GetQuaternion</a></td><td class=docright>
Overwrite self with the given TQuaternion, returns nothing (like CopyQuaternion)
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TQuatPtr_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#CopyQuaternion>CopyQuaternion</a></td><td class=docright>
Copy the given TQuaternion, returns a new Float Ptr quaternion (like GetQuaternion)
</td></tr>
<tr><td class=docleft width=1%><a href=#Create>Create</a></td><td class=docright>
Create a new TQuatPtr from four float values, returns a Float Ptr quaternion.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewQuatPtr>NewQuatPtr</a></td><td class=docright>
Returns a new TQuatPtr object.
</td></tr>
<tr><td class=docleft width=1%><a href=#QuatToEuler>QuatToEuler</a></td><td class=docright>
Convert a quaternion to the given pitch, yaw, roll (Euler degrees)
</td></tr>
<tr><td class=docleft width=1%><a href=#QuatToMat>QuatToMat</a></td><td class=docright>
Convert a quaternion to the given TMatPtr.
</td></tr>
<tr><td class=docleft width=1%><a href=#Slerp>Slerp</a></td><td class=docright>
Slerp two quaternions to the given quaternion.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetQuaternion>
<tr><td class=doctop colspan=2>Method GetQuaternion:TQuatPtr( quat:TQuaternion )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Overwrite self with the given TQuaternion, returns nothing (like CopyQuaternion)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CopyQuaternion>
<tr><td class=doctop colspan=2>Function CopyQuaternion:TQuatPtr( quat:TQuaternion )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy the given TQuaternion, returns a new Float Ptr quaternion (like GetQuaternion)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Create>
<tr><td class=doctop colspan=2>Function Create:TQuatPtr( x:Float=0,y:Float=0,z:Float=0,w:Float=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TQuatPtr from four float values, returns a Float Ptr quaternion.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=NewQuatPtr>
<tr><td class=doctop colspan=2>Function NewQuatPtr:TQuatPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a new TQuatPtr object.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=QuatToEuler>
<tr><td class=doctop colspan=2>Function QuatToEuler( x:Float,y:Float,z:Float,w:Float,pitch:Float Var,yaw:Float Var,roll:Float Var )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Convert a quaternion to the given pitch, yaw, roll (Euler degrees)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=QuatToMat>
<tr><td class=doctop colspan=2>Function QuatToMat( x:Float,y:Float,z:Float,w:Float,mat:TMatPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Convert a quaternion to the given TMatPtr.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Slerp>
<tr><td class=doctop colspan=2>Function Slerp:Int( Ax#,Ay#,Az#,Aw#,Bx#,By#,Bz#,Bw#,Cx:Float Var,Cy:Float Var,Cz:Float Var,Cw:Float Var,t# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Slerp two quaternions to the given quaternion.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TRigidBody>
<tr><td class=doctop colspan=2>Type TRigidBody</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rigid Body.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TShader>
<tr><td class=doctop colspan=2>Type TShader</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Shader.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TShaderObject>
<tr><td class=doctop colspan=2>Type TShaderObject</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Shader object.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TShadowObject>
<tr><td class=doctop colspan=2>Type TShadowObject</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Shadow object.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TSprite>
<tr><td class=doctop colspan=2>Type TSprite Extends TMesh</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sprite mesh entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TStencil>
<tr><td class=doctop colspan=2>Type TStencil</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Stencil.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TSurface>
<tr><td class=doctop colspan=2>Type TSurface</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Surface.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TTerrain>
<tr><td class=doctop colspan=2>Type TTerrain Extends TEntity</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Terrain entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TTexture>
<tr><td class=doctop colspan=2>Type TTexture</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Texture.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TUse>
<tr><td class=doctop colspan=2>Type TUse</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Loader flags for meshes and textures.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TVecPtr>
<tr><td class=doctop colspan=2>Type TVecPtr</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>TVecPtr functions (Openb3d)</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TVecPtr_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#Add>Add</a></td><td class=docright>
Add self to the given TVecPtr, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Clear>Clear</a></td><td class=docright>
Clear (zero) vector values, returns nothing.
</td></tr>
<tr><td class=docleft width=1%><a href=#Copy>Copy</a></td><td class=docright>
Copy self, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Cross>Cross</a></td><td class=docright>
Cross product of self with the given TVecPtr, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Distance>Distance</a></td><td class=docright>
Distance between self and the given TVecPtr, returns a float.
</td></tr>
<tr><td class=docleft width=1%><a href=#Divide>Divide</a></td><td class=docright>
Divide self by a float, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Divide2>Divide2</a></td><td class=docright>
Divide self by the given TVecPtr, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Dot>Dot</a></td><td class=docright>
Dot product (or squared length) of self with the given TVecPtr, returns a float.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetVector>GetVector</a></td><td class=docright>
Overwrite self with the given TVector, returns nothing (like CopyVector)
</td></tr>
<tr><td class=docleft width=1%><a href=#Length>Length</a></td><td class=docright>
Length (or magnitude) of self, returns a float.
</td></tr>
<tr><td class=docleft width=1%><a href=#Multiply>Multiply</a></td><td class=docright>
Multiply self by a float, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Multiply2>Multiply2</a></td><td class=docright>
Multiply self by the given TVecPtr, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Negate>Negate</a></td><td class=docright>
Negate self, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Normalize>Normalize</a></td><td class=docright>
Normalize self, returns nothing.
</td></tr>
<tr><td class=docleft width=1%><a href=#Normalized>Normalized</a></td><td class=docright>
Normalize self, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Pitch>Pitch</a></td><td class=docright>
Pitch (or x angle) in degrees of self, returns a float.
</td></tr>
<tr><td class=docleft width=1%><a href=#Subtract>Subtract</a></td><td class=docright>
Subtract the given TVecPtr from self, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Yaw>Yaw</a></td><td class=docright>
Yaw (or y angle) in degrees of self, returns a float.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TVecPtr_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#CopyVector>CopyVector</a></td><td class=docright>
Copy the given TVector, returns a new Float Ptr vector (like GetVector)
</td></tr>
<tr><td class=docleft width=1%><a href=#Create>Create</a></td><td class=docright>
Create a new TVecPtr from three float values, returns a Float Ptr vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Magnitude>Magnitude</a></td><td class=docright>
Magnitude (or length) of a vector from three float values, returns a float.
</td></tr>
<tr><td class=docleft width=1%><a href=#NewVecPtr>NewVecPtr</a></td><td class=docright>
Returns a new TVecPtr object.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Add>
<tr><td class=doctop colspan=2>Method Add:TVecPtr( vec:TVecPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Add self to the given TVecPtr, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Clear>
<tr><td class=doctop colspan=2>Method Clear()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Clear (zero) vector values, returns nothing.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Copy>
<tr><td class=doctop colspan=2>Method Copy:TVecPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy self, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Cross>
<tr><td class=doctop colspan=2>Method Cross:TVecPtr( vec:TVecPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Cross product of self with the given TVecPtr, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Distance>
<tr><td class=doctop colspan=2>Method Distance:Float( vec:TVecPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Distance between self and the given TVecPtr, returns a float.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Divide>
<tr><td class=doctop colspan=2>Method Divide:TVecPtr( scale:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Divide self by a float, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Divide2>
<tr><td class=doctop colspan=2>Method Divide2:TVecPtr( vec:TVecPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Divide self by the given TVecPtr, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Dot>
<tr><td class=doctop colspan=2>Method Dot:Float( vec:TVecPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Dot product (or squared length) of self with the given TVecPtr, returns a float.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetVector>
<tr><td class=doctop colspan=2>Method GetVector:TVecPtr( vec:TVector )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Overwrite self with the given TVector, returns nothing (like CopyVector)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Length>
<tr><td class=doctop colspan=2>Method Length:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Length (or magnitude) of self, returns a float.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Multiply>
<tr><td class=doctop colspan=2>Method Multiply:TVecPtr( scale:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Multiply self by a float, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Multiply2>
<tr><td class=doctop colspan=2>Method Multiply2:TVecPtr( vec:TVecPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Multiply self by the given TVecPtr, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Negate>
<tr><td class=doctop colspan=2>Method Negate:TVecPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Negate self, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Normalize>
<tr><td class=doctop colspan=2>Method Normalize()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Normalize self, returns nothing.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Normalized>
<tr><td class=doctop colspan=2>Method Normalized:TVecPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Normalize self, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Pitch>
<tr><td class=doctop colspan=2>Method Pitch:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Pitch (or x angle) in degrees of self, returns a float.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Subtract>
<tr><td class=doctop colspan=2>Method Subtract:TVecPtr( vec:TVecPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Subtract the given TVecPtr from self, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Yaw>
<tr><td class=doctop colspan=2>Method Yaw:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Yaw (or y angle) in degrees of self, returns a float.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CopyVector>
<tr><td class=doctop colspan=2>Function CopyVector:TVecPtr( vec:TVector )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy the given TVector, returns a new Float Ptr vector (like GetVector)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Create>
<tr><td class=doctop colspan=2>Function Create:TVecPtr( x:Float=0,y:Float=0,z:Float=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TVecPtr from three float values, returns a Float Ptr vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Magnitude>
<tr><td class=doctop colspan=2>Function Magnitude:Float( v0:Float,v1:Float,v2:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Magnitude (or length) of a vector from three float values, returns a float.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=NewVecPtr>
<tr><td class=doctop colspan=2>Function NewVecPtr:TVecPtr()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a new TVecPtr object.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TVector>
<tr><td class=doctop colspan=2>Type TVector</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>TVector functions (Minib3d)</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TVector_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#Add>Add</a></td><td class=docright>
Add self to the given TVector, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Compare>Compare</a></td><td class=docright>
Compare the given TVector with self, returns 1 or -1.
</td></tr>
<tr><td class=docleft width=1%><a href=#Copy>Copy</a></td><td class=docright>
Copy self, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Cross>Cross</a></td><td class=docright>
Cross product of self with the given TVector, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Distance>Distance</a></td><td class=docright>
Distance between self and the given TVector, returns a float.
</td></tr>
<tr><td class=docleft width=1%><a href=#Divide>Divide</a></td><td class=docright>
Divide self by a float, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Divide2>Divide2</a></td><td class=docright>
Divide self by the given TVecPtr, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Dot>Dot</a></td><td class=docright>
Dot product (or squared length) of self with the given TVector.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetVecPtr>GetVecPtr</a></td><td class=docright>
Overwrite self with the given TVecPtr, returns nothing (like CopyVecPtr)
</td></tr>
<tr><td class=docleft width=1%><a href=#Length>Length</a></td><td class=docright>
Length (or magnitude) of self, returns a float.
</td></tr>
<tr><td class=docleft width=1%><a href=#Multiply>Multiply</a></td><td class=docright>
Multiply self by a float, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Multiply2>Multiply2</a></td><td class=docright>
Multiply self by the given TVecPtr, returns a new vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#New>New</a></td><td class=docright>
Returns a new TVector object.
</td></tr>
<tr><td class=docleft width=1%><a href=#Normalize>Normalize</a></td><td class=docright>
Normalize self, returns nothing.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLength>SetLength</a></td><td class=docright>
Set normalized length of self, returns a float.
</td></tr>
<tr><td class=docleft width=1%><a href=#SquaredLength>SquaredLength</a></td><td class=docright>
Squared length of self, returns a float.
</td></tr>
<tr><td class=docleft width=1%><a href=#Subtract>Subtract</a></td><td class=docright>
Subtract the given TVector from self, returns a new vector.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TVector_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#CopyVecPtr>CopyVecPtr</a></td><td class=docright>
Copy the given TVecPtr, returns a new Float vector (like GetVecPtr)
</td></tr>
<tr><td class=docleft width=1%><a href=#Create>Create</a></td><td class=docright>
Create a new TVector from three float values, returns a Float vector.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Add>
<tr><td class=doctop colspan=2>Method Add:TVector( vec:TVector )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Add self to the given TVector, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Compare>
<tr><td class=doctop colspan=2>Method Compare:Int( with:Object )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Compare the given TVector with self, returns 1 or -1.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Copy>
<tr><td class=doctop colspan=2>Method Copy:TVector()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy self, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Cross>
<tr><td class=doctop colspan=2>Method Cross:TVector( vec:TVector )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Cross product of self with the given TVector, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Distance>
<tr><td class=doctop colspan=2>Method Distance:Float( vec:TVector )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Distance between self and the given TVector, returns a float.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Divide>
<tr><td class=doctop colspan=2>Method Divide:TVector( val# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Divide self by a float, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Divide2>
<tr><td class=doctop colspan=2>Method Divide2:TVector( vec:TVector )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Divide self by the given TVecPtr, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Dot>
<tr><td class=doctop colspan=2>Method Dot:Float( vec:TVector )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Dot product (or squared length) of self with the given TVector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetVecPtr>
<tr><td class=doctop colspan=2>Method GetVecPtr:TVector( vec:TVecPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Overwrite self with the given TVecPtr, returns nothing (like CopyVecPtr)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Length>
<tr><td class=doctop colspan=2>Method Length#()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Length (or magnitude) of self, returns a float.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Multiply>
<tr><td class=doctop colspan=2>Method Multiply:TVector( val# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Multiply self by a float, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Multiply2>
<tr><td class=doctop colspan=2>Method Multiply2:TVector( vec:TVector )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Multiply self by the given TVecPtr, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=New>
<tr><td class=doctop colspan=2>Method New()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a new TVector object.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Normalize>
<tr><td class=doctop colspan=2>Method Normalize()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Normalize self, returns nothing.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLength>
<tr><td class=doctop colspan=2>Method SetLength#( val# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set normalized length of self, returns a float.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SquaredLength>
<tr><td class=doctop colspan=2>Method SquaredLength#()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Squared length of self, returns a float.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Subtract>
<tr><td class=doctop colspan=2>Method Subtract:TVector( vec:TVector )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Subtract the given TVector from self, returns a new vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CopyVecPtr>
<tr><td class=doctop colspan=2>Function CopyVecPtr:TVector( vec:TVecPtr )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copy the given TVecPtr, returns a new Float vector (like GetVecPtr)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Create>
<tr><td class=doctop colspan=2>Function Create:TVector( x#,y#,z# )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TVector from three float values, returns a Float vector.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TVoxelSprite>
<tr><td class=doctop colspan=2>Type TVoxelSprite Extends TMesh</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Voxelsprite mesh entity.</td></tr>
</table>
<br>
<h2 id=modinfo>Module Information</h2>
<table width=100%>
<tr><th width=1%>Version</th><td>1.26</td></tr>
<tr><th width=1%>License</th><td>zlib</td></tr>
<tr><th width=1%>Copyright</th><td>Wrapper - 2014-2021 Mark Mcvittie, Bruce A Henderson</td></tr>
<tr><th width=1%>Copyright</th><td>Library - 2010-2021 Angelo Rosina</td></tr>
</body></html>
