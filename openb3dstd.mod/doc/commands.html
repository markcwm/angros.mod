<html><head><title>OpenB3D standard functions, as in Blitz3D reference</title>
<link rel=stylesheet Type=text/css href='../../../../doc/bmxstyle.css'>
</head><body>
<table width=100% cellspacing=0><tr align=center><td class=small>&nbsp;</td>
<td class=small width=1%><b>Openb3d.Openb3dstd:</b></td>
<td class=small width=1%><a href=#functions class=small>Functions</a></td>
<td class=small width=1%><a href=#modinfo class=small>Modinfo</a></td>
<td class=small width=1%><a href='../../../../mod/openb3d.mod/openb3dstd.mod/openb3dstd.bmx' class=small>Source</a></td>
<td class=small>&nbsp;</td></tr></table>
<h1>OpenB3D standard functions, as in Blitz3D</h1>
Jump to: <a href=#AddAnimSeq>A</a> &nbsp;<a href=#BrushAlpha>B</a> &nbsp;<a href=#CameraClsColor>C</a> &nbsp;<a href=#DeltaPitch>D</a> &nbsp;<a href=#EntityAlpha>E</a> &nbsp;<a href=#FindChild>F</a> &nbsp;<a href=#GetBrushTexture>G</a> &nbsp;<a href=#HandleSprite>H</a> &nbsp;<a href=#LightColor>L</a> &nbsp;<a href=#MeshDepth>M</a> &nbsp;<a href=#NameEntity>N</a> &nbsp;<a href=#PaintEntity>P</a> &nbsp;<a href=#RenderWorld>R</a> &nbsp;<a href=#ScaleEntity>S</a> &nbsp;<a href=#TerrainHeight>T</a> &nbsp;<a href=#UpdateNormals>U</a> &nbsp;<a href=#VectorPitch>V</a> &nbsp;<a href=#Wireframe>W</a> &nbsp;
<h2><a name=functions></a>Functions Summary</h2><table class=doc width=100%>
<tr><td class=docleft width=1%><a href=#AddAnimSeq>AddAnimSeq</a></td><td class=docright>
Creates an animation sequence for an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#AddMesh>AddMesh</a></td><td class=docright>
Adds the source mesh to the destination mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#AddTriangle>AddTriangle</a></td><td class=docright>
Adds a triangle to a surface and returns the triangle's index number.
</td></tr>
<tr><td class=docleft width=1%><a href=#AddVertex>AddVertex</a></td><td class=docright>
Adds a vertex to the specified surface and returns the vertices' index number.
</td></tr>
<tr><td class=docleft width=1%><a href=#AlignToVector>AlignToVector</a></td><td class=docright>
Aligns an entity axis to a vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#AmbientLight>AmbientLight</a></td><td class=docright>
Sets the ambient lighting colour.
</td></tr>
<tr><td class=docleft width=1%><a href=#Animate>Animate</a></td><td class=docright>
Animates an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#Animating>Animating</a></td><td class=docright>
Returns true if the specified entity is currently animating.
</td></tr>
<tr><td class=docleft width=1%><a href=#AnimLength>AnimLength</a></td><td class=docright>
Returns the length of the specified entity's current animation sequence.
</td></tr>
<tr><td class=docleft width=1%><a href=#AnimSeq>AnimSeq</a></td><td class=docright>
Returns the specified entity's current animation sequence.
</td></tr>
<tr><td class=docleft width=1%><a href=#AnimTime>AnimTime</a></td><td class=docright>
Returns the current animation time of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#AntiAlias>AntiAlias</a></td><td class=docright>
Enables or disables fullscreen antialiasing.
</td></tr>
<tr><td class=docleft width=1%><a href=#BrushAlpha>BrushAlpha</a></td><td class=docright>
Sets the alpha level of a brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#BrushBlend>BrushBlend</a></td><td class=docright>
Sets the blending mode for a brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#BrushColor>BrushColor</a></td><td class=docright>
Sets the colour of a brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#BrushFX>BrushFX</a></td><td class=docright>
Sets miscellaneous effects for a brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#BrushShininess>BrushShininess</a></td><td class=docright>
Sets the specular shininess of a brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#BrushTexture>BrushTexture</a></td><td class=docright>
Assigns a texture to a brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraClsColor>CameraClsColor</a></td><td class=docright>
Sets camera background color.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraClsMode>CameraClsMode</a></td><td class=docright>
Sets camera clear mode.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraFogColor>CameraFogColor</a></td><td class=docright>
Sets camera fog color.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraFogMode>CameraFogMode</a></td><td class=docright>
Sets the camera fog mode.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraFogRange>CameraFogRange</a></td><td class=docright>
Sets camera fog range.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraPick>CameraPick</a></td><td class=docright>
Picks the entity positioned at the specified viewport coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraProject>CameraProject</a></td><td class=docright>
Projects the world coordinates x.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraProjMode>CameraProjMode</a></td><td class=docright>
Sets the camera projection mode.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraRange>CameraRange</a></td><td class=docright>
Sets camera range.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraViewport>CameraViewport</a></td><td class=docright>
Sets the camera viewport position and size.
</td></tr>
<tr><td class=docleft width=1%><a href=#CameraZoom>CameraZoom</a></td><td class=docright>
Sets zoom factor for a camera.
</td></tr>
<tr><td class=docleft width=1%><a href=#ClearCollisions>ClearCollisions</a></td><td class=docright>
Clears the collision information list.
</td></tr>
<tr><td class=docleft width=1%><a href=#ClearSurface>ClearSurface</a></td><td class=docright>
Removes all vertices and/or triangles from a surface.
</td></tr>
<tr><td class=docleft width=1%><a href=#ClearTextureFilters>ClearTextureFilters</a></td><td class=docright>
Clears the current texture filter list.
</td></tr>
<tr><td class=docleft width=1%><a href=#ClearWorld>ClearWorld</a></td><td class=docright>
Clears all entities.
</td></tr>
<tr><td class=docleft width=1%><a href=#CollisionEntity>CollisionEntity</a></td><td class=docright>
Returns the other entity involved in a particular collision.
</td></tr>
<tr><td class=docleft width=1%><a href=#CollisionNX>CollisionNX</a></td><td class=docright>
Returns the x component of the normal of a particular collision.
</td></tr>
<tr><td class=docleft width=1%><a href=#CollisionNY>CollisionNY</a></td><td class=docright>
Returns the y component of the normal of a particular collision.
</td></tr>
<tr><td class=docleft width=1%><a href=#CollisionNZ>CollisionNZ</a></td><td class=docright>
Returns the z component of the normal of a particular collision.
</td></tr>
<tr><td class=docleft width=1%><a href=#Collisions>Collisions</a></td><td class=docright>
Enables collisions between two different entity types.
</td></tr>
<tr><td class=docleft width=1%><a href=#CollisionSurface>CollisionSurface</a></td><td class=docright>
Returns the handle of the surface belonging to the specified entity that was closest to the point of a particular collision.
</td></tr>
<tr><td class=docleft width=1%><a href=#CollisionTime>CollisionTime</a></td><td class=docright>
Returns the time taken to calculate a particular collision.
</td></tr>
<tr><td class=docleft width=1%><a href=#CollisionTriangle>CollisionTriangle</a></td><td class=docright>
Returns the index number of the triangle belonging to the specified entity  that was closest to the point of a particular collision.
</td></tr>
<tr><td class=docleft width=1%><a href=#CollisionX>CollisionX</a></td><td class=docright>
Returns the world x coordinate of a particular collision.
</td></tr>
<tr><td class=docleft width=1%><a href=#CollisionY>CollisionY</a></td><td class=docright>
Returns the world y coordinate of a particular collision.
</td></tr>
<tr><td class=docleft width=1%><a href=#CollisionZ>CollisionZ</a></td><td class=docright>
Returns the world z coordinate of a particular collision.
</td></tr>
<tr><td class=docleft width=1%><a href=#CopyEntity>CopyEntity</a></td><td class=docright>
Creates a copy of an entity and returns the handle of the newly created copy.
</td></tr>
<tr><td class=docleft width=1%><a href=#CopyMesh>CopyMesh</a></td><td class=docright>
Creates a copy of a mesh and returns the newly-created mesh's handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CountChildren>CountChildren</a></td><td class=docright>
Returns the number of children of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#CountCollisions>CountCollisions</a></td><td class=docright>
Returns how many collisions an entity was involved in during the last UpdateWorld.
</td></tr>
<tr><td class=docleft width=1%><a href=#CountSurfaces>CountSurfaces</a></td><td class=docright>
Returns the number of surfaces in a mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#CountTriangles>CountTriangles</a></td><td class=docright>
Returns the number of triangles in a surface.
</td></tr>
<tr><td class=docleft width=1%><a href=#CountVertices>CountVertices</a></td><td class=docright>
Returns the number of vertices in a surface.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateBrush>CreateBrush</a></td><td class=docright>
Creates a brush and returns a brush handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateCamera>CreateCamera</a></td><td class=docright>
Creates a camera entity and returns its handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateCone>CreateCone</a></td><td class=docright>
Creates a cone mesh/entity and returns its handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateCube>CreateCube</a></td><td class=docright>
Creates a cube mesh/entity and returns its handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateCylinder>CreateCylinder</a></td><td class=docright>
Creates a cylinder mesh/entity and returns its handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateLight>CreateLight</a></td><td class=docright>
Creates a light.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateMesh>CreateMesh</a></td><td class=docright>
Create a 'blank' mesh entity and returns its handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreatePivot>CreatePivot</a></td><td class=docright>
Creates a pivot entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreatePlane>CreatePlane</a></td><td class=docright>
Creates a plane entity and returns its handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateSphere>CreateSphere</a></td><td class=docright>
Creates a sphere mesh/entity and returns its handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateSprite>CreateSprite</a></td><td class=docright>
Creates a sprite entity and returns its handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateSurface>CreateSurface</a></td><td class=docright>
Creates a surface attached to a mesh and returns the surface's handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateTerrain>CreateTerrain</a></td><td class=docright>
Creates a terrain entity and returns its handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateTexture>CreateTexture</a></td><td class=docright>
Creates a texture and returns its handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#DeltaPitch>DeltaPitch</a></td><td class=docright>
Returns the pitch angle.
</td></tr>
<tr><td class=docleft width=1%><a href=#DeltaYaw>DeltaYaw</a></td><td class=docright>
Returns the yaw angle.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityAlpha>EntityAlpha</a></td><td class=docright>
Sets the entity alpha level of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityBlend>EntityBlend</a></td><td class=docright>
Sets the blending mode of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityBox>EntityBox</a></td><td class=docright>
Sets the dimensions of an entity's collision box.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityClass>EntityClass</a></td><td class=docright>
Returns a string containing the class of the specified entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityCollided>EntityCollided</a></td><td class=docright>
Returns the handle of the entity of the specified type that collided with  the specified entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityColor>EntityColor</a></td><td class=docright>
Sets the color of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityDistance>EntityDistance</a></td><td class=docright>
Returns the distance between src_entity and dest_entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityFX>EntityFX</a></td><td class=docright>
Sets miscellaneous effects for an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityInView>EntityInView</a></td><td class=docright>
Returns true if the specified entity is visible to the specified camera.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityName>EntityName</a></td><td class=docright>
Returns the name of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityOrder>EntityOrder</a></td><td class=docright>
Sets the drawing order for an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityParent>EntityParent</a></td><td class=docright>
Attaches an entity to a parent.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityPick>EntityPick</a></td><td class=docright>
Returns the nearest entity 'ahead' of the specified entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityPickMode>EntityPickMode</a></td><td class=docright>
Sets the pick mode for an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityPitch>EntityPitch</a></td><td class=docright>
Returns the pitch angle of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityRadius>EntityRadius</a></td><td class=docright>
Sets the radius of an entity's collision ellipsoid.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityRoll>EntityRoll</a></td><td class=docright>
Returns the roll angle of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityShininess>EntityShininess</a></td><td class=docright>
Sets the specular shininess of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityTexture>EntityTexture</a></td><td class=docright>
Applies a texture to an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityType>EntityType</a></td><td class=docright>
Sets the collision type for an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityVisible>EntityVisible</a></td><td class=docright>
Returns true if src_entity and dest_entity can 'see' each other.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityX>EntityX</a></td><td class=docright>
The X-coordinate of the entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityY>EntityY</a></td><td class=docright>
The Y-coordinate of the entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityYaw>EntityYaw</a></td><td class=docright>
Returns the yaw angle of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#EntityZ>EntityZ</a></td><td class=docright>
The Z-coordinate of the entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#ExtractAnimSeq>ExtractAnimSeq</a></td><td class=docright>
This command allows you to convert an animation with an MD2-style series  of anim sequences into a pure Blitz anim sequence.
</td></tr>
<tr><td class=docleft width=1%><a href=#FindChild>FindChild</a></td><td class=docright>
Returns the first child of the specified entity with name matching child_name$
</td></tr>
<tr><td class=docleft width=1%><a href=#FindSurface>FindSurface</a></td><td class=docright>
Attempts to find a surface attached to the specified mesh and created with  the specified brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#FitMesh>FitMesh</a></td><td class=docright>
Scales and translates all vertices of a mesh so that the mesh occupies the specified box.
</td></tr>
<tr><td class=docleft width=1%><a href=#FlipMesh>FlipMesh</a></td><td class=docright>
Flips all the triangles in a mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#FreeBrush>FreeBrush</a></td><td class=docright>
Frees up a brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#FreeEntity>FreeEntity</a></td><td class=docright>
FreeEntity will free up the internal resources associated  with a particular entity and remove it from the scene.
</td></tr>
<tr><td class=docleft width=1%><a href=#FreeTexture>FreeTexture</a></td><td class=docright>
Frees up a texture from memory.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetBrushTexture>GetBrushTexture</a></td><td class=docright>
Returns the texture that is applied to the specified brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetChild>GetChild</a></td><td class=docright>
Returns a child of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetEntityBrush>GetEntityBrush</a></td><td class=docright>
Returns a brush with the same properties as is applied to the specified entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetEntityType>GetEntityType</a></td><td class=docright>
Returns the collision type of an entity as set by the EntityType command.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMatElement>GetMatElement</a></td><td class=docright>
Returns the value of an element from within an entity's transformation matrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetParent>GetParent</a></td><td class=docright>
Returns an entity's parent.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetSurface>GetSurface</a></td><td class=docright>
Returns the handle of the surface attached to the specified mesh and with  the specified index number.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetSurfaceBrush>GetSurfaceBrush</a></td><td class=docright>
Returns a brush with the same properties as is applied to the specified mesh surface.
</td></tr>
<tr><td class=docleft width=1%><a href=#HandleSprite>HandleSprite</a></td><td class=docright>
Sets a sprite handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#HideEntity>HideEntity</a></td><td class=docright>
Hides an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#LightColor>LightColor</a></td><td class=docright>
Sets the color of a light.
</td></tr>
<tr><td class=docleft width=1%><a href=#LightConeAngles>LightConeAngles</a></td><td class=docright>
Sets the 'cone' angle for a 'spot' light.
</td></tr>
<tr><td class=docleft width=1%><a href=#LightRange>LightRange</a></td><td class=docright>
Sets the range of a light.
</td></tr>
<tr><td class=docleft width=1%><a href=#LinePick>LinePick</a></td><td class=docright>
Returns the first entity between x.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadAnimMesh>LoadAnimMesh</a></td><td class=docright>
LoadAnimMesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadAnimSeq>LoadAnimSeq</a></td><td class=docright>
Appends an animation sequence from a file to an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadAnimTexture>LoadAnimTexture</a></td><td class=docright>
Loads an animated texture from an image file and returns the texture's handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadBrush>LoadBrush</a></td><td class=docright>
Creates a brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadMesh>LoadMesh</a></td><td class=docright>
LoadMesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadSprite>LoadSprite</a></td><td class=docright>
Creates a sprite entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadTerrain>LoadTerrain</a></td><td class=docright>
Loads a terrain from an image file and returns the terrain's handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadTexture>LoadTexture</a></td><td class=docright>
Load a texture from an image file and returns the texture's handle.
</td></tr>
<tr><td class=docleft width=1%><a href=#MeshDepth>MeshDepth</a></td><td class=docright>
Returns the depth of a mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#MeshesIntersect>MeshesIntersect</a></td><td class=docright>
Returns true if the specified meshes are currently intersecting.
</td></tr>
<tr><td class=docleft width=1%><a href=#MeshHeight>MeshHeight</a></td><td class=docright>
Returns the height of a mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#MeshWidth>MeshWidth</a></td><td class=docright>
Returns the width of a mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#ModifyTerrain>ModifyTerrain</a></td><td class=docright>
Sets the height of a point on a terrain.
</td></tr>
<tr><td class=docleft width=1%><a href=#MoveEntity>MoveEntity</a></td><td class=docright>
Moves an entity relative to its current position and orientation.
</td></tr>
<tr><td class=docleft width=1%><a href=#NameEntity>NameEntity</a></td><td class=docright>
Sets an entity's name.
</td></tr>
<tr><td class=docleft width=1%><a href=#PaintEntity>PaintEntity</a></td><td class=docright>
Paints a entity with a brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#PaintMesh>PaintMesh</a></td><td class=docright>
Paints a mesh with a brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#PaintSurface>PaintSurface</a></td><td class=docright>
Paints a surface with a brush.
</td></tr>
<tr><td class=docleft width=1%><a href=#PickedEntity>PickedEntity</a></td><td class=docright>
Returns the entity 'picked' by the most recently executed Pick command.
</td></tr>
<tr><td class=docleft width=1%><a href=#PickedNX>PickedNX</a></td><td class=docright>
Returns the x component of the normal of the most recently executed Pick  command.
</td></tr>
<tr><td class=docleft width=1%><a href=#PickedNY>PickedNY</a></td><td class=docright>
Returns the y component of the normal of the most recently executed Pick  command.
</td></tr>
<tr><td class=docleft width=1%><a href=#PickedNZ>PickedNZ</a></td><td class=docright>
Returns the z component of the normal of the most recently executed Pick  command.
</td></tr>
<tr><td class=docleft width=1%><a href=#PickedSurface>PickedSurface</a></td><td class=docright>
Returns the handle of the surface that was 'picked' by the most recently  executed Pick command.
</td></tr>
<tr><td class=docleft width=1%><a href=#PickedTime>PickedTime</a></td><td class=docright>
Returns the time taken to calculate the most recently executed Pick command.
</td></tr>
<tr><td class=docleft width=1%><a href=#PickedTriangle>PickedTriangle</a></td><td class=docright>
Returns the index number of the triangle that was 'picked' by the most recently  executed Pick command.
</td></tr>
<tr><td class=docleft width=1%><a href=#PickedX>PickedX</a></td><td class=docright>
Returns the world x coordinate of the most recently executed Pick command.
</td></tr>
<tr><td class=docleft width=1%><a href=#PickedY>PickedY</a></td><td class=docright>
Returns the world y coordinate of the most recently executed Pick command.
</td></tr>
<tr><td class=docleft width=1%><a href=#PickedZ>PickedZ</a></td><td class=docright>
Returns the world z coordinate of the most recently executed Pick command.
</td></tr>
<tr><td class=docleft width=1%><a href=#PointEntity>PointEntity</a></td><td class=docright>
Points one entity at another.
</td></tr>
<tr><td class=docleft width=1%><a href=#PositionEntity>PositionEntity</a></td><td class=docright>
Positions an entity at an absolute position in 3D space.
</td></tr>
<tr><td class=docleft width=1%><a href=#PositionMesh>PositionMesh</a></td><td class=docright>
Moves all vertices of a mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#PositionTexture>PositionTexture</a></td><td class=docright>
Positions a texture at an absolute position.
</td></tr>
<tr><td class=docleft width=1%><a href=#ProjectedX>ProjectedX</a></td><td class=docright>
Returns the viewport x coordinate of the most recently executed CameraProject.
</td></tr>
<tr><td class=docleft width=1%><a href=#ProjectedY>ProjectedY</a></td><td class=docright>
Returns the viewport y coordinate of the most recently executed CameraProject.
</td></tr>
<tr><td class=docleft width=1%><a href=#ProjectedZ>ProjectedZ</a></td><td class=docright>
Returns the viewport z coordinate of the most recently executed CameraProject.
</td></tr>
<tr><td class=docleft width=1%><a href=#RenderWorld>RenderWorld</a></td><td class=docright>
Renders the current scene to the BackBuffer onto the rectangle defined by each cameras CameraViewport( )
</td></tr>
<tr><td class=docleft width=1%><a href=#ResetEntity>ResetEntity</a></td><td class=docright>
Resets the collision state of an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#RotateEntity>RotateEntity</a></td><td class=docright>
Rotates an entity so that it is at an absolute orientation.
</td></tr>
<tr><td class=docleft width=1%><a href=#RotateMesh>RotateMesh</a></td><td class=docright>
Rotates all vertices of a mesh by the specified rotation.
</td></tr>
<tr><td class=docleft width=1%><a href=#RotateSprite>RotateSprite</a></td><td class=docright>
Rotates a sprite.
</td></tr>
<tr><td class=docleft width=1%><a href=#RotateTexture>RotateTexture</a></td><td class=docright>
Rotates a texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#ScaleEntity>ScaleEntity</a></td><td class=docright>
Scales an entity so that it is of an absolute size.
</td></tr>
<tr><td class=docleft width=1%><a href=#ScaleMesh>ScaleMesh</a></td><td class=docright>
Scales all vertices of a mesh by the specified scaling factors.
</td></tr>
<tr><td class=docleft width=1%><a href=#ScaleSprite>ScaleSprite</a></td><td class=docright>
Scales a sprite.
</td></tr>
<tr><td class=docleft width=1%><a href=#ScaleTexture>ScaleTexture</a></td><td class=docright>
Scales a texture by an absolute amount.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetAnimKey>SetAnimKey</a></td><td class=docright>
Sets an animation key for the specified entity at the specified frame.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetAnimTime>SetAnimTime</a></td><td class=docright>
SetAnimTime allows you to manually animate entities.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetCubeFace>SetCubeFace</a></td><td class=docright>
Selects a cube face for direct rendering to a texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetCubeMode>SetCubeMode</a></td><td class=docright>
Set the rendering mode of a cubemap texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#ShowEntity>ShowEntity</a></td><td class=docright>
Shows an entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#SpriteViewMode>SpriteViewMode</a></td><td class=docright>
Sets the view mode of a sprite.
</td></tr>
<tr><td class=docleft width=1%><a href=#TerrainHeight>TerrainHeight</a></td><td class=docright>
Returns the height of the terrain at terrain grid coordinates x.
</td></tr>
<tr><td class=docleft width=1%><a href=#TerrainX>TerrainX</a></td><td class=docright>
Returns the interpolated x coordinate on a terrain.
</td></tr>
<tr><td class=docleft width=1%><a href=#TerrainY>TerrainY</a></td><td class=docright>
Returns the interpolated y coordinate on a terrain.
</td></tr>
<tr><td class=docleft width=1%><a href=#TerrainZ>TerrainZ</a></td><td class=docright>
Returns the interpolated z coordinate on a terrain.
</td></tr>
<tr><td class=docleft width=1%><a href=#TextureBlend>TextureBlend</a></td><td class=docright>
Sets the blending mode for a texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#TextureCoords>TextureCoords</a></td><td class=docright>
Sets the texture coordinate mode for a texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#TextureFilter>TextureFilter</a></td><td class=docright>
Adds a texture filter.
</td></tr>
<tr><td class=docleft width=1%><a href=#TextureHeight>TextureHeight</a></td><td class=docright>
Returns the height of a texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#TextureName>TextureName</a></td><td class=docright>
Returns a texture's absolute filename.
</td></tr>
<tr><td class=docleft width=1%><a href=#TextureWidth>TextureWidth</a></td><td class=docright>
Returns the width of a texture.
</td></tr>
<tr><td class=docleft width=1%><a href=#TFormedX>TFormedX</a></td><td class=docright>
Returns the X component of the last TFormPoint.
</td></tr>
<tr><td class=docleft width=1%><a href=#TFormedY>TFormedY</a></td><td class=docright>
Returns the Y component of the last TFormPoint.
</td></tr>
<tr><td class=docleft width=1%><a href=#TFormedZ>TFormedZ</a></td><td class=docright>
Returns the Z component of the last TFormPoint.
</td></tr>
<tr><td class=docleft width=1%><a href=#TFormNormal>TFormNormal</a></td><td class=docright>
Transforms between coordinate systems.
</td></tr>
<tr><td class=docleft width=1%><a href=#TFormPoint>TFormPoint</a></td><td class=docright>
Transforms between coordinate systems.
</td></tr>
<tr><td class=docleft width=1%><a href=#TFormVector>TFormVector</a></td><td class=docright>
Transforms between coordinate systems.
</td></tr>
<tr><td class=docleft width=1%><a href=#TranslateEntity>TranslateEntity</a></td><td class=docright>
Translates an entity relative to its current position and not its  orientation.
</td></tr>
<tr><td class=docleft width=1%><a href=#TriangleVertex>TriangleVertex</a></td><td class=docright>
Returns the vertex of a triangle corner.
</td></tr>
<tr><td class=docleft width=1%><a href=#TurnEntity>TurnEntity</a></td><td class=docright>
Turns an entity relative to its current orientation.
</td></tr>
<tr><td class=docleft width=1%><a href=#UpdateNormals>UpdateNormals</a></td><td class=docright>
Recalculates all normals in a mesh.
</td></tr>
<tr><td class=docleft width=1%><a href=#UpdateWorld>UpdateWorld</a></td><td class=docright>
Animates all entities in the world.
</td></tr>
<tr><td class=docleft width=1%><a href=#VectorPitch>VectorPitch</a></td><td class=docright>
Returns the pitch value of a vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#VectorYaw>VectorYaw</a></td><td class=docright>
Returns the yaw value of a vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexAlpha>VertexAlpha</a></td><td class=docright>
Returns the alpha component of a vertices color.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexBlue>VertexBlue</a></td><td class=docright>
Returns the blue component of a vertices color.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexColor>VertexColor</a></td><td class=docright>
Sets the color of an existing vertex.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexCoords>VertexCoords</a></td><td class=docright>
Sets the geometric coordinates of an existing vertex.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexGreen>VertexGreen</a></td><td class=docright>
Returns the green component of a vertices color.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexNormal>VertexNormal</a></td><td class=docright>
Sets the normal of an existing vertex.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexNX>VertexNX</a></td><td class=docright>
Returns the x component of a vertices normal.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexNY>VertexNY</a></td><td class=docright>
Returns the y component of a vertices normal.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexNZ>VertexNZ</a></td><td class=docright>
Returns the z component of a vertices normal.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexRed>VertexRed</a></td><td class=docright>
Returns the red component of a vertices color.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexTexCoords>VertexTexCoords</a></td><td class=docright>
Sets the texture coordinates of an existing vertex.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexU>VertexU</a></td><td class=docright>
Returns the texture u coordinate of a vertex.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexV>VertexV</a></td><td class=docright>
Returns the texture v coordinate of a vertex.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexW>VertexW</a></td><td class=docright>
Returns the texture w coordinate of a vertex.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexX>VertexX</a></td><td class=docright>
Returns the x coordinate of a vertex.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexY>VertexY</a></td><td class=docright>
Returns the y coordinate of a vertex.
</td></tr>
<tr><td class=docleft width=1%><a href=#VertexZ>VertexZ</a></td><td class=docright>
Returns the z coordinate of a vertex.
</td></tr>
<tr><td class=docleft width=1%><a href=#Wireframe>Wireframe</a></td><td class=docright>
Enables or disables wireframe rendering.
</td></tr>
</table>
<h2
 id=functionsdet>Functions
</h2>
<table class=doc width=100% cellspacing=3 id=AddAnimSeq>
<tr><td class=doctop colspan=2>Function AddAnimSeq:Int( ent:TEntity,length:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates an animation sequence for an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
length -
<p>
<b>Description</b>:
<p>
Creates an animation sequence for an entity. This must be done before any  animation keys set by SetAnimKey can be used in  an actual animation however this is optional. You may use it to "bake" the frames you have added previously using SetAnimKey.
<p>
Returns the animation sequence number added.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AddMesh>
<tr><td class=doctop colspan=2>Function AddMesh( mesh1:TMesh,mesh2:TMesh )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Adds the source mesh to the destination mesh.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
source_mesh - source mesh handle
<p>
dest_mesh - destination mesh handle
<p>
<b>Description</b>:
<p>
Adds the source mesh to the destination mesh.
<p>
AddMesh works best with  meshes that have previously only had mesh commands used with them.
<p>
So if you want to manipulate a mesh before adding it to another mesh, make  sure you use ScaleMesh, PositionMesh, PaintMesh etc rather than ScaleEntity,  PositionEntity, EntityTexture etc before using AddMesh.
<p>
However, something to be aware of when using commands such as RotateMesh  is that all mesh commands work from a global origin of 0,0,0. Therefore it is  generally a good idea to scale and rotate a mesh before positioning it, otherwise  your mesh could end up in unexpected positions. Also, when using AddMesh, the  origin of the new all-in-one mesh will be set at 0,0,0.
<p>
After using AddMesh, the original source_mesh will still exist, therefore  use FreeEntity to delete it if you wish to do so.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AddTriangle>
<tr><td class=doctop colspan=2>Function AddTriangle:Int( surf:TSurface,v0:Int,v1:Int,v2:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Adds a triangle to a surface and returns the triangle's index number.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
v0 - index number of first vertex of triangle
<p>
v1 - index number of second vertex of triangle
<p>
v2 - index number of third vertex of triangle
<p>
<b>Description</b>:
<p>
Adds a triangle to a surface and returns the triangle's index number, starting  from 0.
<p>
The v0, v1 and v2 parameters are the index numbers of the vertices  created using AddVertex.
<p>
Depending on how the vertices are arranged, then the triangle will only be  visible from a certain side. Imagine that a triangle's vertex points are like  dot-to-dot pattern, each numbered v0, v1, v2. If these dots, starting from v0,  through to V2, form a clockwise pattern relative to the viewer, then the triangle  will be visible. If these dots form an anti-clockwise pattern relative to the  viewer, then the triangle will not be visible.
<p>
The reason for having one-sided triangles is that it reduces the amount of  triangles that need to be rendered when one side faces the side of an object  which won't be seen (such as the inside of a snooker ball). However, if you  wish for a triangle to be two-sided, then you can either create two triangles,  using the same set of vertex numbers for both but assigning them in opposite  orders, or you can use CopyEntity and FlipMesh together.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AddVertex>
<tr><td class=doctop colspan=2>Function AddVertex:Int( surf:TSurface,x:Float,y:Float,z:Float,u:Float=0,v:Float=0,w:Float=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Adds a vertex to the specified surface and returns the vertices' index number.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
x# - x coordinate of vertex
<p>
y# - y coordinate of vertex
<p>
z# - z coordinate of vertex
<p>
u# (optional) - u texture coordinate of vertex
<p>
v# (optional) - v texture coordinate of vertex
<p>
w# (optional) - w texture coordinate of vertex - not used, included for future expansion
<p>
<b>Description</b>:
<p>
Adds a vertex to the specified surface and returns the vertices' index number,  starting from 0.
<p>
x,y,z are the geometric coordinates of the vertex, and u,v,w are texture mapping coordinates.
<p>
A vertex is a point in 3D space which is used to connect edges of a triangle together. Without any vertices, you can't have any triangles. At least three  vertices are needed to create one triangle; one for each corner.
<p>
The optional u, v and w parameters allow you to specify texture coordinates for a vertex, which will determine how any triangle created using those vertices will be texture mapped. The u, v and w parameters specified will take effect on both texture coordinate sets (0 and 1). This works on the following basis:
<p>
The top left of an image has the uv coordinates 0,0.
The top right has coordinates 1,0
The bottom right is 1,1.
The bottom left 0,1.
<p>
Thus, uv coordinates for a vertex correspond to a point in the image. For example, coordinates 0.9,0.1 would be near the upper right corner of the image.
<p>
So now imagine you have a normal equilateral triangle. By assigning the bottom left vertex a uv coordinate of 0,0, the bottom right a coordinate of 1,0 and the top centre 0.5,1, this will texture map the triangle with an image that fits it.
<p>
When adding a vertex its default color is 255,255,255,255.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AlignToVector>
<tr><td class=doctop colspan=2>Function AlignToVector( entity:TEntity,x:Float,y:Float,z:Float,axis:Int,rate:Int=1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Aligns an entity axis to a vector.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
vector_x# - vector x
<p>
vector_y# - vector y
<p>
vector_z# - vector z
<p>

axis - axis of entity that will be aligned to vector
<p>
1: x-axis
<p>
2: y-axis
<p>
3: z-axis
<p>

rate# (optional) - rate at which entity is aligned from current  orientation to vector orientation. Should be in the range 0 to 1, 0 for smooth  transition and 1 for 'snap' transition. Defaults to 1.
<p>
<b>Description</b>:
<p>
Aligns an entity axis to a vector.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AmbientLight>
<tr><td class=doctop colspan=2>Function AmbientLight( r:Float,g:Float,b:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the ambient lighting colour.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
red# - red ambient light value
<p>
green# - green ambient light value
<p>
blue# - blue ambient light value
<p>

The green, red and blue values should be  in the range 0-255. The default ambient light colour is 127,127,127.
<p>
<b>Description</b>:
<p>
Sets the ambient lighting colour.
<p>
Ambient light is a light source that affects all points on a 3D object equally.  So with ambient light only, all 3D objects will appear flat, as there will be  no shading.
<p>
Ambient light is useful for providing a certain level of light, before adding  other lights to provide a realistic lighting effect.
<p>
An ambient light level of 0,0,0 will result in no ambient light being displayed.
<p>
See also: <a href=#CreateLight>CreateLight</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=Animate>
<tr><td class=doctop colspan=2>Function Animate( ent:TEntity,Mode:Int=1,speed:Float=1,seq:Int=0,trans:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Animates an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>

mode (optional) - mode of animation.
<p>
0: stop animation
<p>
1: loop animation (default)
<p>
2: ping-pong animation
<p>
3: one-shot animation
<p>

speed# (optional) - speed of animation. Defaults to 1.
<p>
sequence (optional) - specifies which sequence of animation frames to play.  Defaults to 0.
<p>
transition# (optional) - used to tween between an entities current position  rotation and the first frame of animation. Defaults to 0.
<p>
<b>Description</b>:
<p>
Animates an entity.
<p>
More info about the optional parameters:
<p>
speed# - a negative speed will play the animation backwards.
<p>
sequence - Initially, an entity loaded with LoadAnimMesh  will have a single animation sequence. More sequences can be added using either LoadAnimSeq or AddAnimSeq.  Animation sequences are numbered 0,1,2...etc.
<p>
transition# - A value of 0 will cause an instant 'leap' to the first frame,  while values greater than 0 will cause a smooth transition.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=Animating>
<tr><td class=doctop colspan=2>Function Animating:Int( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns true if the specified entity is currently animating.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Returns true if the specified entity is currently animating.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AnimLength>
<tr><td class=doctop colspan=2>Function AnimLength:Int( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the length of the specified entity's current animation sequence.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Returns the length of the specified entity's current animation sequence.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AnimSeq>
<tr><td class=doctop colspan=2>Function AnimSeq:Int( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the specified entity's current animation sequence.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Returns the specified entity's current animation sequence.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AnimTime>
<tr><td class=doctop colspan=2>Function AnimTime:Float( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the current animation time of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Returns the current animation time of an entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=AntiAlias>
<tr><td class=doctop colspan=2>Function AntiAlias( samples:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enables or disables fullscreen antialiasing.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
enable - True to enable fullscreen antialiasing, False to disable.
<p>

The default AntiAlias mode is False.
<p>
<b>Description</b>:
<p>
Enables or disables fullscreen antialiasing.
<p>
Fullscreen antialiasing is a technique used to smooth out the entire screen,  so that jagged lines are made less noticeable.
<p>
Some 3D cards have built-in support for fullscreen antialiasing, which should  allow you to enable the effect without much slowdown. However, for cards without  built-in support for fullscreen antialiasing, enabling the effect may cause  severe slowdown.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=BrushAlpha>
<tr><td class=doctop colspan=2>Function BrushAlpha( brush:TBrush,a:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the alpha level of a brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
brush - brush handle
<p>
alpha# - alpha level of brush
<p>
<b>Description</b>:
<p>
Sets the alpha level of a brush.
<p>
The alpha# value should be in the range  0-1. The default brush alpha setting is 1.
<p>
The alpha level is how transparent an entity is. A value of 1 will mean the  entity is non-transparent, i.e. opaque. A value of 0 will mean the entity is  completely transparent, i.e. invisible. Values between 0 and 1 will cause varying  amount of transparency accordingly, useful for imitating the look of objects  such as glass and ice.
<p>
An BrushAlpha value of 0 is especially useful as Blitz3D will not render  entities with such a value, but will still involve the entities in collision  tests. This is unlike HideEntity, which doesn't  involve entities in collisions.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=BrushBlend>
<tr><td class=doctop colspan=2>Function BrushBlend( brush:TBrush,blend:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the blending mode for a brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
brush - brush handle
<p>
blend -
<p>
1: alpha (default)
<p>
2: multiply
<p>
3: add
<p>
<b>Description</b>:
<p>
Sets the blending mode for a brush.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=BrushColor>
<tr><td class=doctop colspan=2>Function BrushColor( brush:TBrush,r:Float,g:Float,b:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the colour of a brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
brush - brush handle
<p>
red# - red value of brush
<p>
green# - green value of brush
<p>
blue# - blue value of brush
<p>
<b>Description</b>:
<p>
Sets the colour of a brush.
<p>
The green, red and blue values should be in  the range 0-255. The default brush color is  255,255,255.
<p>
Please note that if EntityFX or  BrushFX flag 2 is being used, brush colour will have no effect and vertex  colours will be used instead.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=BrushFX>
<tr><td class=doctop colspan=2>Function BrushFX( brush:TBrush,fx:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets miscellaneous effects for a brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
brush - brush handle
<p>

fx -
<p>
0: nothing (default)
<p>
1: full-bright
<p>
2: use vertex colors instead of brush color
<p>
4: flatshaded
<p>
8: disable fog
<p>
16: disable backface culling
<p>
<b>Description</b>:
<p>
Sets miscellaneous effects for a brush.
<p>
Flags can be added to combine  two or more effects. For example, specifying a flag of 3 (1+2) will result in  a full-bright and vertex-coloured brush.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=BrushShininess>
<tr><td class=doctop colspan=2>Function BrushShininess( brush:TBrush,s:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the specular shininess of a brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
brush - brush handle
<p>
shininess# - shininess of brush
<p>
<b>Description</b>:
<p>
Sets the specular shininess of a brush.
<p>
The shininess# value should be  in the range 0-1. The default shininess setting is 0.
<p>
Shininess is how much brighter certain areas of an object will appear to  be when a light is shone directly at them.
<p>
Setting a shininess value of 1 for a medium to high poly sphere, combined  with the creation of a light shining in the direction of it, will give it the  appearance of a shiny snooker ball.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=BrushTexture>
<tr><td class=doctop colspan=2>Function BrushTexture( brush:TBrush,tex:TTexture,frame:Int=0,index:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Assigns a texture to a brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
brush - brush handle
<p>
texture - texture handle
<p>
frame (optional) - texture frame. Defaults to 0.
<p>
index (optional) - texture index. Defaults to 0.
<p>
<b>Description</b>:
<p>
Assigns a texture to a brush.
<p>
The optional frame parameter specifies which  animation frame, if any exist, should be assigned to the brush.
<p>
The optional index parameter specifies texture layer that the texture should  be assigned to. Brushes have up to four texture layers, 0-3 inclusive.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraClsColor>
<tr><td class=doctop colspan=2>Function CameraClsColor( cam:TCamera,r:Float,g:Float,b:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets camera background color.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
camera - camera handle
<p>
red# - red value of camera background color
<p>
green# - green value of camera background color
<p>
blue# - blue value of camera background color
<p>
<b>Description</b>:
<p>
Sets camera background color. Defaults to 0,0,0.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraClsMode>
<tr><td class=doctop colspan=2>Function CameraClsMode( cam:TCamera,cls_depth:Int,cls_zbuffer:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets camera clear mode.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
camera - camera handle
<p>
cls_color - true to clear the color buffer, false not to
<p>
cls_zbuffer - true to clear the z-buffer, false not to
<p>
<b>Description</b>:
<p>
Sets camera clear mode.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraFogColor>
<tr><td class=doctop colspan=2>Function CameraFogColor( cam:TCamera,r:Float,g:Float,b:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets camera fog color.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
camera - camera handle
<p>
red# - red value of value
<p>
green# - green value of fog
<p>
blue# - blue value of fog
<p>
<b>Description</b>:
<p>
Sets camera fog color.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraFogMode>
<tr><td class=doctop colspan=2>Function CameraFogMode( cam:TCamera,Mode:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the camera fog mode.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
camera - camera handle
<p>

mode -
<p>
0: no fog (default)
<p>
1: linear fog
<p>
<b>Description</b>:
<p>
Sets the camera fog mode.
<p>
This will enable/disable fogging, a technique  used to gradually fade out graphics the further they are away from the camera.  This can be used to avoid 'pop-up', the moment at which 3D objects suddenly  appear on the horizon.
<p>
The default fog colour is black and the default fog range is 1-1000, although  these can be changed by using CameraFogColor  and CameraFogRange respectively.
<p>
Each camera can have its own fog mode, for multiple on-screen fog effects.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraFogRange>
<tr><td class=doctop colspan=2>Function CameraFogRange( cam:TCamera,nnear:Float,nfar:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets camera fog range.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
camera - camera handle
<p>
near# - distance in front of camera that fog starts
<p>
far# - distance in front of camera that fog ends
<p>
<b>Description</b>:
<p>
Sets camera fog range.
<p>
The near parameter specifies at what distance  in front of the camera that the fogging effect will start; all 3D object  before this point will not be faded.
<p>
The far parameter specifies at what distance in front of the camera that  the fogging effect will end; all 3D objects beyond this point will be  completely faded out.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraPick>
<tr><td class=doctop colspan=2>Function CameraPick:TEntity( cam:TCamera,x:Float,y:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Picks the entity positioned at the specified viewport coordinates.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
camera - camera handle
<p>
viewport_x# - 2D viewport coordinate
<p>
viewport_z# - 2D viewport coordinate
<p>
<b>Description</b>:
<p>
Picks the entity positioned at the specified viewport coordinates.
<p>
Returns  the entity picked, or 0 if none there.
<p>
An entity must have its EntityPickMode set  to a non-0 value value to be 'pickable'.
<p>
See also: <a href=#EntityPick>EntityPick</a>, <a href=#LinePick>LinePick</a>, <a href=#CameraPick>CameraPick</a>, <a href=#EntityPickMode>EntityPickMode</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraProject>
<tr><td class=doctop colspan=2>Function CameraProject( cam:TCamera,x:Float,y:Float,z:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Projects the world coordinates x.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
camera - camera handle
<p>
x# - world coordinate x
<p>
y# - world coordinate y
<p>
z# - world coordinate z
<p>
<b>Description</b>:
<p>
Projects the world coordinates x,y,z on to the 2D screen.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraProjMode>
<tr><td class=doctop colspan=2>Function CameraProjMode( cam:TCamera,Mode:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the camera projection mode.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
camera - camera handle
<p>
mode - projection mode:
<p>
0: no projection - disables camera (faster than HideEntity)
<p>
1: perspective projection (default)
<p>
2: orthographic projection
<p>
<b>Description</b>:
<p>
Sets the camera projection mode.
<p>
The projection mode is the the technique  used by Blitz to display 3D graphics on the screen. Using projection mode 0,  nothing is displayed on the screen, and this is the fastest method of hiding  a camera. Using camera projection mode 1, the graphics are displayed in their  'correct' form - and this is the default mode for a camera. Camera projection  mode 2 is a special type of projection, used for displaying 3D graphics on screen,  but in a 2D form - that is, no sense of perspective will be given to the graphics.  Two identical objects at varying distances from the camera will both appear  to be the same size. Orthographic projection is useful for 3D editors, where  a sense of perspective is unimportant, and also certain games.
<p>
Use 'CameraZoom' to control the scale of graphics rendered with orthographic  projection. As a general rule, using orthographic projection with the default  camera zoom setting of 1 will result in graphics that are too 'zoomed-in' -  changing the camera zoom to 0.1 should fix this.
<p>
One thing to note with using camera project mode 2, is that terrains will  not be displayed correctly - this is because the level of detail algorithm used  by terrains relies on perspective in order to work properly.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraRange>
<tr><td class=doctop colspan=2>Function CameraRange( cam:TCamera,nnear:Float,nfar:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets camera range.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
camera - camera handle
<p>
near - distance in front of camera that 3D objects start being drawn
<p>
far - distance in front of camera that 3D object stop being drawn
<p>
<b>Description</b>:
<p>
Sets camera range.
<p>
Try and keep the ratio of far/near as small as possible  for optimal z-buffer performance. Defaults to 1,1000.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraViewport>
<tr><td class=doctop colspan=2>Function CameraViewport( cam:TCamera,x:Int,y:Int,width:Int,height:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the camera viewport position and size.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
camera - camera handle
<p>
x - x coordinate of top left hand corner of viewport
<p>
y - y coordinate of top left hand corner of viewport
<p>
width - width of viewport
<p>
height - height of viewport
<p>
<b>Description</b>:
<p>
Sets the camera viewport position and size.
<p>
The camera viewport is the  area of the 2D screen that the 3D graphics as viewed by the camera are  displayed in.
<p>
Setting the camera viewport allows you to achieve spilt-screen and  rear-view mirror effects.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CameraZoom>
<tr><td class=doctop colspan=2>Function CameraZoom( cam:TCamera,zoom:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets zoom factor for a camera.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
camera - camera handle
<p>
zoom# - zoom factor of camera
<p>
<b>Description</b>:
<p>
Sets zoom factor for a camera. Defaults to 1.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ClearCollisions>
<tr><td class=doctop colspan=2>Function ClearCollisions()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Clears the collision information list.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Clears the collision information list.
<p>
Whenever you use the Collisions command to enable collisions between  two different entity types, information is added to the collision list. This  command clears that list, so that no collisions will be detected until the Collisions  command is used again.
<p>
The command will not clear entity collision information. For example, entity  radius, type etc.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ClearSurface>
<tr><td class=doctop colspan=2>Function ClearSurface( surf:TSurface,clear_verts:Int=True,clear_tris:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Removes all vertices and/or triangles from a surface.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
clear_verts (optional) - true to remove all vertices from the specified surface,  false not to. Defaults to true.
<p>
clear_triangles (optional) - true to remove all triangles from the specified  surface, false not to. Defaults to true.
<p>
<b>Description</b>:
<p>
Removes all vertices and/or triangles from a surface.
<p>
This is useful for  clearing sections of mesh. The results will be instantly visible.
<p>
After clearing a surface, you may wish to add vertices and triangles to it  again but with a slightly different polygon count for dynamic level of detail  (LOD).</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ClearTextureFilters>
<tr><td class=doctop colspan=2>Function ClearTextureFilters()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Clears the current texture filter list.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Clears the current texture filter list.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ClearWorld>
<tr><td class=doctop colspan=2>Function ClearWorld( entities:Int=True,brushes:Int=True,textures:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Clears all entities.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entities (optional) - True to clear all entities, False not to. Defaults  to true.
<p>
brushes (optional) - True to clear all brushes, False not to. Defaults to true.
<p>
textures (optional) - True to clear all textures, False not to. Defaults to  true.
<p>
<b>Description</b>:
<p>
Clears all entities, brushes and/or textures from the screen and from memory.
<p>
As soon as you clear something, you will not be able to use it again until you  reload it. Trying to do so will cause a runtime error.
<p>
This command is useful for when a level has finished and you wish to load  a different level with new entities, brushes and textures.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CollisionEntity>
<tr><td class=doctop colspan=2>Function CollisionEntity:TEntity( ent:TEntity,index:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the other entity involved in a particular collision.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
index - index of collision
<p>
<b>Description</b>:
<p>
Returns the other entity involved in a particular collision. Index should  be in the range 1...CountCollisions( entity  ), inclusive.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CollisionNX>
<tr><td class=doctop colspan=2>Function CollisionNX:Float( ent:TEntity,index:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the x component of the normal of a particular collision.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
index - index of collision
<p>
<b>Description</b>:
<p>
Returns the x component of the normal of a particular collision.
<p>
Index  should be in the range 1...CountCollisions(  entity ) inclusive.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CollisionNY>
<tr><td class=doctop colspan=2>Function CollisionNY:Float( ent:TEntity,index:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the y component of the normal of a particular collision.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
index - index of collision
<p>
<b>Description</b>:
<p>
Returns the y component of the normal of a particular collision.
<p>
Index  should be in the range 1...CountCollisions(  entity ) inclusive.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CollisionNZ>
<tr><td class=doctop colspan=2>Function CollisionNZ:Float( ent:TEntity,index:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the z component of the normal of a particular collision.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
index - index of collision
<p>
<b>Description</b>:
<p>
Returns the z component of the normal of a particular collision.
<p>
Index  should be in the range 1...CountCollisions(  entity ) inclusive.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=Collisions>
<tr><td class=doctop colspan=2>Function Collisions( src_no:Int,dest_no:Int,method_no:Int,response_no:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enables collisions between two different entity types.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
src_type - entity type to be checked for collisions.
<p>
dest_type - entity type to be collided with.
<p>

<p>
method - collision detection method.
<p>
1: ellipsoid-to-ellipsoid collisions
<p>
2: ellipsoid-to-polygon collisions
<p>
3: ellipsoid-to-box collisions
<p>

<p>
response - what the source entity does when a collision occurs.
<p>
1: stop
<p>
2: slide1 - full sliding collision
<p>
3: slide2 - prevent entities from sliding down slopes
<p>
<b>Description</b>:
<p>
Enables collisions between two different entity types.
<p>
Entity types are just numbers you assign to an entity using EntityType. Blitz then uses the entity types to check for collisions between all the entities that have those entity types.
<p>
Blitz has many ways of checking for collisions, as denoted by the method parameter. However, collision checking is always ellipsoid to something. In order for Blitz to know what size a source entity is, you must first assign an entity radius to all source entities using EntityRadius.
<p>
In the case of collision detection method 1 being selected (ellipsoid-to-ellipsoid), then the destination entities concerned will need to have an EntityRadius assigned to them too. In the case of method 3 being selected (ellipsoid-to-box), then the destination entities  will need to have an EntityBox assigned to them. Method 2 (ellipsoid-to-polygon) requires nothing to be assigned to the destination entities.
<p>
Not only does Blitz check for collisions, but it acts upon them when it detects them too, as denoted by the response parameter. You have three options in this situation. You can either choose to make the source entity stop, slide or only slide upwards.
<p>
All collision checking occurs, and collision responses are acted out, when UpdateWorld is called.
<p>
Finally, every time the Collision command is used, collision information is added to the collision information list. This can be cleared at any time using the ClearCollisions command.
<p>
See also: <a href=#EntityBox>EntityBox</a>, <a href=#EntityRadius>EntityRadius</a>, <a href=#Collisions>Collisions</a>, <a href=#EntityType>EntityType</a>, <a href=#ResetEntity>ResetEntity</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CollisionSurface>
<tr><td class=doctop colspan=2>Function CollisionSurface:TSurface( ent:TEntity,index:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the handle of the surface belonging to the specified entity that was closest to the point of a particular collision.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
index - index of collision
<p>
<b>Description</b>:
<p>
Returns the handle of the surface belonging to the specified entity that was closest to the point of a particular collision.
<p>
Index should be in  the range 1...CountCollisions( entity ), inclusive.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CollisionTime>
<tr><td class=doctop colspan=2>Function CollisionTime:Float( ent:TEntity,index:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the time taken to calculate a particular collision.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
index - index of collision
<p>
<b>Description</b>:
<p>
Returns the time taken to calculate a particular collision.
<p>
Index should be in the range 1...CountCollisions(  entity ) inclusive.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CollisionTriangle>
<tr><td class=doctop colspan=2>Function CollisionTriangle:Int( ent:TEntity,index:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the index number of the triangle belonging to the specified entity  that was closest to the point of a particular collision.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
index - index of collision
<p>
<b>Description</b>:
<p>
Returns the index number of the triangle belonging to the specified entity  that was closest to the point of a particular collision.
<p>
Index should be in the range 1...CountCollisions(  entity ), inclusive.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CollisionX>
<tr><td class=doctop colspan=2>Function CollisionX:Float( ent:TEntity,index:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the world x coordinate of a particular collision.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
index - index of collision
<p>
<b>Description</b>:
<p>
Returns the world x coordinate of a particular collision.
<p>
Index should  be in the range 1...CountCollisions( entity  ) inclusive.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CollisionY>
<tr><td class=doctop colspan=2>Function CollisionY:Float( ent:TEntity,index:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the world y coordinate of a particular collision.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
index - index of collision
<p>
<b>Description</b>:
<p>
Returns the world y coordinate of a particular collision.
<p>
Index should  be in the range 1...CountCollisions( entity  ) inclusive.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CollisionZ>
<tr><td class=doctop colspan=2>Function CollisionZ:Float( ent:TEntity,index:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the world z coordinate of a particular collision.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
index - index of collision
<p>
<b>Description</b>:
<p>
Returns the world z coordinate of a particular collision.
<p>
Index should  be in the range 1...CountCollisions( entity  ) inclusive.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CopyEntity>
<tr><td class=doctop colspan=2>Function CopyEntity:TEntity( ent:TEntity,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a copy of an entity and returns the handle of the newly created copy.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - Entity Handle
<p>
parent (optional) - Entity that will act as Parent to the copy.
<p>
<b>Description</b>:
<p>
Creates a copy of an entity and returns the handle of the newly created copy. This is a new entity instance of an existing entity's mesh! Anything you do to the original Mesh (such as RotateMesh) will effect all the copies. Other properties (such as EntityColor, Position etc.) since they are 'Entity' properties, will be individual to the copy.
<p>
If a parent entity is specified, the copied entity will be created at the parent entity's position. Otherwise, it will be created at 0,0,0.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CopyMesh>
<tr><td class=doctop colspan=2>Function CopyMesh:TMesh( mesh:TMesh,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a copy of a mesh and returns the newly-created mesh's handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - handle of mesh to be copied
<p>
parent (optional) - handle of entity to be made parent of mesh
<p>
<b>Description</b>:
<p>
Creates a copy of a mesh and returns the newly-created mesh's handle.
<p>
The difference between CopyMesh and CopyEntity  is that CopyMesh performs a 'deep' copy of a mesh.
<p>
CopyMesh is identical to performing new_mesh=CreateMesh() : AddMesh mesh,new_mesh.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CountChildren>
<tr><td class=doctop colspan=2>Function CountChildren:Int( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the number of children of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Returns the number of children of an entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CountCollisions>
<tr><td class=doctop colspan=2>Function CountCollisions:Int( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns how many collisions an entity was involved in during the last UpdateWorld.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Returns how many collisions an entity was involved in during the last UpdateWorld.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CountSurfaces>
<tr><td class=doctop colspan=2>Function CountSurfaces:Int( mesh:TMesh )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the number of surfaces in a mesh.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
<b>Description</b>:
<p>
Returns the number of surfaces in a mesh.
<p>
Surfaces are sections of mesh.  A mesh may contain only one section, or very many.
<p>
See also: <a href=#GetSurface>GetSurface</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CountTriangles>
<tr><td class=doctop colspan=2>Function CountTriangles:Int( surf:TSurface )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the number of triangles in a surface.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
<b>Description</b>:
<p>
Returns the number of triangles in a surface.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CountVertices>
<tr><td class=doctop colspan=2>Function CountVertices:Int( surf:TSurface )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the number of vertices in a surface.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
<b>Description</b>:
<p>
Returns the number of vertices in a surface.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateBrush>
<tr><td class=doctop colspan=2>Function CreateBrush:TBrush( r:Float=255,g:Float=255,b:Float=255 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a brush and returns a brush handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
red# (optional) - brush red value
<p>
green# (optional) - brush green value
<p>
blue# (optional) - brush blue value
<p>
<b>Description</b>:
<p>
Creates a brush and returns a brush handle.
<p>
The optional green, red and  blue values allow you to set the colour of the brush. Values should be in the  range 0-255. If omitted the values default to 255.
<p>
A brush is a collection of properties such as Colour, Alpha, Shininess, Texture  etc that are all stored as part of the brush. Then, all these properties can  be applied to an entity, mesh or surface at once just by using PaintEntity, PaintMesh  or PaintSurface.
<p>
When creating your own mesh, if you wish for certain surfaces to look differently  from one another, then you will need to use brushes to paint individual surfaces.  Using commands such as EntityColor, EntityAlpha will apply the effect to all  surfaces at once, which may not be what you wish to achieve.
<p>
See also: <a href=#LoadBrush>LoadBrush</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateCamera>
<tr><td class=doctop colspan=2>Function CreateCamera:TCamera( parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a camera entity and returns its handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
parent (optional) - parent entity of camera
<p>
<b>Description</b>:
<p>
Creates a camera entity and returns its handle.
<p>
Without  at least one camera, you won't be able to see anything in your 3D world. With more than one camera, you will be to achieve effect such as  split-screen modes and rear-view mirrors.
<p>
A camera can only render to the backbuffer. If you wish to display 3D  graphics on an image or a texture then copy the contents of the backbuffer  to the appropriate buffer.
<p>
The optional parent parameter allow you to specify a parent entity for  the camera so that when the parent is moved the child camera will move with  it. However, this relationship is one way; applying movement commands to the  child will not affect the parent.
<p>
Specifying a parent entity will still result in the camera being created  at position 0,0,0 rather than at the parent entity's position.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateCone>
<tr><td class=doctop colspan=2>Function CreateCone:TMesh( segments:Int=8,solid:Int=True,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a cone mesh/entity and returns its handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
segments (optional) - cone detail. Defaults to 8.
<p>
solid (optional) - true for a cone with a base, false for a cone without a base.  Defaults to true.
<p>
parent (optional) - parent entity of cone
<p>
<b>Description</b>:
<p>
Creates a cone mesh/entity and returns its handle.
<p>
The cone will be centred  at 0,0,0 and the base of the cone will have a radius of 1.
<p>
The segments value must be in the range 3-100 inclusive, although this is  only checked in debug mode. A common mistake is to leave debug mode off and  specify the parent parameter (usually an eight digit memory address) in the  place of the segments value. As the amount of polygons used to create a cone  is exponentially proportional to the segments value, this will result in Blitz  trying to create a cone with unimaginable amounts of polygons! Depending on  how unlucky you are, your computer will then crash.
<p>
Example segments values (solid=true):
4: 6 polygons - a pyramid
8: 14 polygons - bare minimum amount of polygons for a cone
16: 30 polygons - smooth cone at medium-high distances
32: 62 polygons - smooth cone at close distances
<p>
The optional parent parameter allow you to specify a parent entity for the  cone so that when the parent is moved the child cone will move with it. However,  this relationship is one way; applying movement commands to the child will not  affect the parent.
<p>
Specifying a parent entity will still result in the cone being created at  position 0,0,0 rather than at the parent entity's position.
<p>
See also: <a href=#CreateCube>CreateCube</a>, <a href=#CreateSphere>CreateSphere</a>, <a href=#CreateCylinder>CreateCylinder</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateCube>
<tr><td class=doctop colspan=2>Function CreateCube:TMesh( parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a cube mesh/entity and returns its handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
[parent] (optional) - This allows you to set the parent entity of Cube.
<p>
<b>Description</b>:
<p>
Creates a cube mesh/entity and returns its handle.
<p>
The cube will extend from  -1,-1,-1 to +1,+1,+1.
<p>
The optional parent parameter allow you to specify a parent entity for  the cube so that when the parent is moved the child cube will move with it.  However, this relationship is one way; applying movement commands to the  child will not affect the parent.
<p>
Specifying a parent entity will still result in the cube being created at  position 0,0,0 rather than at the parent entity's position.
<p>
Creation of cubes, cylinders and cones are a great way of getting scenes set up quickly, as they can act as placeholders for more complex pre-modeled meshes later on in program development.
<p>
See also: <a href=#CreateSphere>CreateSphere</a>, <a href=#CreateCylinder>CreateCylinder</a>, <a href=#CreateCone>CreateCone</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateCylinder>
<tr><td class=doctop colspan=2>Function CreateCylinder:TMesh( segments:Int=8,solid:Int=True,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a cylinder mesh/entity and returns its handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
segments (optional) - cylinder detail. Defaults to 8.
<p>
solid (optional) - true for a cylinder, false for a tube. Defaults to true.
<p>
parent (optional) - parent entity of cylinder
<p>
<b>Description</b>:
<p>
Creates a cylinder mesh/entity and returns its handle.
<p>
The cylinder will  be centred at 0,0,0 and will have a radius of 1.
<p>
The segments value must be in the range 3-100 inclusive, although this is  only checked in debug mode. A common mistake is to leave debug mode off and  specify the parent parameter (usually an eight digit memory address) in the  place of the segments value. As the amount of polygons used to create a cylinder  is exponentially proportional to the segments value, this will result in Blitz  trying to create a cylinder with unimaginable amounts of polygons! Depending  on how unlucky you are, your computer may then crash.
<p>
Example segments values (solid=true):
3: 8 polygons - a prism
8: 28 polygons - bare minimum amount of polygons for a cylinder
16: 60 polygons - smooth cylinder at medium-high distances
32: 124 polygons - smooth cylinder at close distances
<p>
The optional parent parameter allow you to specify a parent entity for the  cylinder so that when the parent is moved the child cylinder will move with  it. However, this relationship is one way; applying movement commands to the  child will not affect the parent.
<p>
Specifying a parent entity will still result in the cylinder being created  at position 0,0,0 rather than at the parent entity's position.
<p>
See also: <a href=#CreateCube>CreateCube</a>, <a href=#CreateSphere>CreateSphere</a>, <a href=#CreateCone>CreateCone</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateLight>
<tr><td class=doctop colspan=2>Function CreateLight:TLight( light_type:Int=1,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a light.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
type (optional) - type of light
<p>
1: directional (default)
<p>
2: point
<p>
3: spot
<p>

parent (optional) - parent entity of light
<p>
<b>Description</b>:
<p>
Creates a light.
<p>
Lights work by affecting the colour of all vertices within  the light's range. You need at to create at least one light if you wish to use 3D graphics otherwise everything will appear flat.
<p>
The optional type parameter allows you to specify the type of light you wish to create. A value of 1 creates a directional light. This works similar to a  sun shining on a house. All walls facing a certain direction are lit the same.  How much they are lit by depends on the angle of the light reaching them.  Directional lights have infinite 'position' and infinite range.
<p>
A value of 2 creates a point (or omni) light. This works a little bit like a light bulb  in a house, starting from a central point and gradually fading outwards.
<p>
A value of 3 creates a spot light. This is a cone of light. This works similar  to shining a torch in a house. It starts with an inner angle of light, and then  extends towards an outer angle of light.  You can adjust the angles of a 'spot' light with the LightConeAngles command.
<p>
The optional parent parameter allow you to specify a parent entity for the  light so that when the parent is moved the child light will move with it. However,  this relationship is one way; applying movement commands to the child will not affect the parent.
<p>
Specifying a parent entity will still result in the light being created at  position 0,0,0 rather than at the parent entity's position.
<p>

Other notes:
There is a DirectX limit on the number of lights available per scene - this is either 8 or 16 depending on your video card, but you should always assume 8.
<p>
Also, you should remember that each light added effects the rendering speed.
<p>
Lights do not cast shadows, like they do in real life.
<p>
Most games get around these issues by the use of a pre-calculated 'baked' lightmap texture for the static geometry in the scene.
<p>
Other lighting techniques include: adjusting vertex colors, dynamic shadows, and/or dynamic lights (ie. moving the lights around in the scene as they are needed).
<p>
See also: <a href=#LightRange>LightRange</a>, <a href=#LightColor>LightColor</a>, <a href=#LightConeAngles>LightConeAngles</a>, <a href=#AmbientLight>AmbientLight</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateMesh>
<tr><td class=doctop colspan=2>Function CreateMesh:TMesh( parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a 'blank' mesh entity and returns its handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
parent (optional) - This optional parameter allows you to specify another entity which will act as the parent to this mesh.
<p>
<b>Description</b>:
<p>
Create a 'blank' mesh entity and returns its handle.
<p>
When a mesh is first created it has no surfaces, vertices or triangles associated with it.
<p>
To add geometry to this mesh, you will need to:
<p>
CreateSurface() ; To make a surface
AddVertex ; You will need to add at least 3 to make a Triangle
AddTriangle ; This will add a triangle by connecting the Vertices (points) you added to the mesh.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreatePivot>
<tr><td class=doctop colspan=2>Function CreatePivot:TPivot( parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a pivot entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
parent (optional) - parent entity of pivot
<p>
<b>Description</b>:
<p>
Creates a pivot entity.
<p>
A pivot entity is an invisible  point in 3D space that's main use is to act as a parent entity to other entities.  The pivot can then be used to control lots of entities at once, or act as new  centre of rotation for other entities.
<p>
To enforce this relationship; use EntityParent  or make use of the optional parent entity parameter available with all entity  load/creation commands.
<p>
Indeed, this parameter is also available with the CreatePivot command if  you wish for the pivot to have a parent entity itself.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreatePlane>
<tr><td class=doctop colspan=2>Function CreatePlane:TMesh( divisions:Int=1,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a plane entity and returns its handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
sub_divs (optional) - sub divisions of plane. Should be in the range 1-16.  The default value is 1.
<p>
parent (optional) - parent entity of plane
<p>
<b>Description</b>:
<p>
Creates a plane entity and returns its handle.
<p>
A plane entity is basically  a flat, infinite 'ground'. It is useful for outdoor games where you never want  the player to see/reach the edge of the game world.
<p>
The optional sub_divs parameter determines how many sub divisions of polygons  the plane will have. Although a plane is flat and so adding extra polygons will  not make it smoother, adding more polygons will allow more vertices to be lit  for more detailed lighting effects.
<p>
The optional parent parameter allows you to specify a parent  entity for the plane so that when the parent is moved the child plane will move  with it. However, this relationship is one way; applying movement commands to  the child will not affect the parent.
<p>
Specifying a parent entity will still result in the plane being created at  position 0,0,0 rather than at the parent entity's position.
<p>
See also: <a href=#CreateMirror>CreateMirror</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateSphere>
<tr><td class=doctop colspan=2>Function CreateSphere:TMesh( segments:Int=8,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a sphere mesh/entity and returns its handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
segments (optional) - sphere detail. Defaults to 8.
<p>
parent (optional) - parent entity of sphere
<p>
<b>Description</b>:
<p>
Creates a sphere mesh/entity and returns its handle.
<p>
The sphere will  be centred  at 0,0,0 and will have a radius of 1.
<p>
The segments value must be in the range 2-100 inclusive, although this is  only checked in debug mode. A common mistake  is to leave debug mode off and specify the parent parameter  (usually an eight digit memory address) in the place of the segments value.  As the amount of polygons used to create a sphere is exponentially  proportional to the segments value, this will result in Blitz trying to create a sphere  with unimaginable amounts of polygons! Depending on how unlucky you are,  your computer will then crash.
<p>
Example segments values:
8: 224 polygons - bare minimum amount of polygons for a sphere
16: 960 polygons - smooth looking sphere at medium-high distances
32: 3968 polygons - smooth sphere at close distances
<p>
The  optional parent parameter allow you to specify a parent entity for the  sphere so that when the parent is moved the child sphere will move with it.  However, this relationship is one way; applying movement commands to the  child will not affect the parent.
<p>
Specifying a parent entity will still result in the sphere being created  at position 0,0,0 rather than at the parent entity's position.
<p>
See also: <a href=#CreateCube>CreateCube</a>, <a href=#CreateCylinder>CreateCylinder</a>, <a href=#CreateCone>CreateCone</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateSprite>
<tr><td class=doctop colspan=2>Function CreateSprite:TSprite( parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a sprite entity and returns its handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
parent (optional) - parent entity of sprite
<p>
<b>Description</b>:
<p>
Creates a sprite entity and returns its handle.  Sprites are simple flat (usually textured) rectangles made from two triangles.  Unlike other entity objects they don't actually have a mesh that can be manipulated.
<p>
The sprite will be positioned  at 0,0,0 and extend from 1,-1 to +1,+1.
<p>
Sprites have two real strengths. The first is that they consist of only two  polygons; meaning you can use many of them at once. This makes them ideal for  particle effects and 2D-using-3D games where you want lots of sprites on-screen  at once.
<p>
Secondly, sprites can be assigned a view mode using SpriteViewMode. By default this view mode is  set to 1, which means the sprite will always face the camera. So no matter what  the orientation of the camera is relative to the sprite, you will never actually  notice that they are flat; by giving them a spherical texture, you can make  them appear to look no different than a normal sphere.
<p>
The optional parent parameter allow you to specify a parent entity for the  sprite so that when the parent is moved the child sprite will move with it.  However, this relationship is one way; applying movement commands to the child  will not affect the parent.
<p>
Specifying a parent entity will still result in the sprite being created  at position 0,0,0 rather than at the parent entity's position.
<p>
Note:  Sprites have their own commands for rotation and scaling.
<p>
See also: <a href=#LoadSprite>LoadSprite</a>, <a href=#RotateSprite>RotateSprite</a>, <a href=#ScaleSprite>ScaleSprite</a>, <a href=#HandleSprite>HandleSprite</a>, <a href=#SpriteViewMode>SpriteViewMode</a>, <a href=#PositionEntity>PositionEntity</a>, <a href=#MoveEntity>MoveEntity</a>, <a href=#TranslateEntity>TranslateEntity</a>, <a href=#EntityAlpha>EntityAlpha</a>, <a href=#FreeEntity>FreeEntity</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateSurface>
<tr><td class=doctop colspan=2>Function CreateSurface:TSurface( mesh:TMesh,brush:TBrush=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a surface attached to a mesh and returns the surface's handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
brush (optional) - brush handle
<p>
<b>Description</b>:
<p>
Creates a surface attached to a mesh and returns the surface's handle.
<p>
Surfaces are sections of mesh which are then used to attach triangles to. You  must have at least one surface per mesh in order to create a visible mesh, however  you can use as many as you like. Splitting a mesh up into lots of sections allows  you to affect those sections individually, which can be a lot more useful than  if all the surfaces are combined into just one.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateTerrain>
<tr><td class=doctop colspan=2>Function CreateTerrain:TTerrain( size:Int,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a terrain entity and returns its handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
grid_size - no of grid squares along each side of terrain, and must be a  power of 2 value, e.g. 32, 64, 128, 256, 512, 1024.
<p>
parent (optional) - parent entity of terrain
<p>
<b>Description</b>:
<p>
Creates a terrain entity and returns its handle.
<p>
The terrain  extends from 0,0,0 to grid_size,1,grid_size.
<p>
A terrain is a special type of polygon object that uses real-time level of  detail (LOD) to display landscapes which should theoretically consist of over  a million polygons with only a few thousand. The way it does this is by constantly  rearranging a certain amount of polygons to display high levels of detail close  to the viewer and low levels further away.
<p>
This constant rearrangement of polygons is occasionally noticeable however,  and is a well-known side-effect of all LOD landscapes. This 'pop-in' effect  can be reduced in lots of ways though, as the other terrain help files will  go on to explain.
<p>
The optional parent parameter allows you to specify a parent entity for the  terrain so that when the parent is moved the child terrain will move with it.  However, this relationship is one way; applying movement commands to the child  will not affect the parent.
<p>
Specifying a parent entity will still result in the terrain being created  at position 0,0,0 rather than at the parent entity's position.
<p>
See also: <a href=#LoadTerrain>LoadTerrain</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=CreateTexture>
<tr><td class=doctop colspan=2>Function CreateTexture:TTexture( width:Int,height:Int,flags:Int=9,frames:Int=1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a texture and returns its handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
width - width of texture
<p>
height - height of texture
<p>

flags (optional) - texture flag:
<p>
1: Color (default)
<p>
2: Alpha
<p>
4: Masked
<p>
8: Mipmapped
<p>
16: Clamp U
<p>
32: Clamp V
<p>
64: Spherical environment map
<p>
128: Cubic environment map
<p>
256: Store texture in vram
<p>
512: Force the use of high color textures
<p>

frames (optional) - no of frames texture will have. Defaults to 1.
<p>
<b>Description</b>:
<p>
Creates a texture and returns its handle.
<p>
Width and height are the size  of the texture. Note that the actual texture size may be different from the  width and height requested, as different types of 3D hardware support different  sizes of texture.
<p>
The optional flags parameter allows you to apply certain effects to the texture.  Flags can be added to combine two or more effects, e.g. 3 (1+2) = texture with  color and alpha maps.
<p>
Here some more detailed descriptions of the flags:
<p>
1: Color - colour map, what you see is what you get.
<p>
2: Alpha - alpha map. If an image contains an alpha map, this will be used to  make certain areas of the texture transparent. Otherwise, the colour map will  be used as an alpha map. With alpha maps, the dark areas always equal high-transparency,  light areas equal low-transparency.
<p>
4: Masked - all areas of a texture coloured 0,0,0 will not be drawn to the screen.
<p>
8: Mipmapped - low detail versions of the texture will be used at high distance.  Results in a smooth, blurred look.
<p>
16: Clamp u - Any part of a texture that lies outsides the U coordinates of 0-1 will not be drawn. Prevents texture-wrapping.
<p>
32: Clamp v - Any part of a texture that lies outsides the v coordinates of 0-1 will not be drawn. Prevents texture-wrapping.
<p>
64: Spherical environment map - a form of environment mapping. This works by taking a single image, and then applying it to a 3D mesh in such a way that the image appears to be reflected. When used with a texture that contains light sources, it can give some meshes such as a teapot a shiny appearance.
<p>
128: Cubic environment map - a form of environment mapping. Cube mapping is similar to spherical mapping, except it uses six images each representing a particular 'face' of an imaginary cube, to give the appearance of an image that perfectly reflects its surroundings.
<p>
When creating cubic environment maps with the CreateTexture command, cubemap textures *must* be square 'power of 2' sizes. See the <a href=#SetCubeFace>SetCubeFace</a> command for information on how to then draw to the cubemap.
<p>
When loading cubic environments maps into Blitz using LoadTexture, all six images relating to the six faces of the cube must be contained within the one texture, and be laid out in a horizontal strip in the following order - left, forward, right, backward, up, down. The images comprising the cubemap must all be power of two sizes.
<p>
Please note that not some older graphics cards do not support cubic mapping. In order to find out if a user's graphics card can support it, use <a href=#GfxDriverCaps3D>GfxDriverCaps3D</a> .
<p>
256: Store texture in vram. In some circumstances, this makes for much faster dynamic textures - ie. when using CopyRect between two textures. When drawing to cube maps in real-time, it is preferable to use this flag.
<p>
512: Force the use of high color textures in low bit depth graphics modes. This is useful for when you are in 16-bit color mode, and wish to create/load textures with the alpha flag - it should give better results.
<p>
Once you have created a texture, use SetBuffer TextureBuffer to draw to it. However, to display 2D graphics on a texture, it is usually quicker to draw to an image and then copy it to the texturebuffer, and to display 3D graphics on a texture, your only option is to copy from the backbuffer to the texturebuffer.
<p>
See also: <a href=#LoadTexture>LoadTexture</a>, <a href=#LoadAnimTexture>LoadAnimTexture</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=DeltaPitch>
<tr><td class=doctop colspan=2>Function DeltaPitch:Float( ent1:TEntity,ent2:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the pitch angle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
src_entity - source entity handle
<p>
dest_entity - destination entity handle
<p>
<b>Description</b>:
<p>
Returns the pitch angle, that src_entity should be rotated by in order to face dest_entity.
<p>
This command can be used to be point one entity at another, rotating on the x axis only.
<p>
See also: <a href=#DeltaYaw>DeltaYaw</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=DeltaYaw>
<tr><td class=doctop colspan=2>Function DeltaYaw:Float( ent1:TEntity,ent2:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the yaw angle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
src_entity - source entity handle
<p>
dest_entity - destination entity handle
<p>
<b>Description</b>:
<p>
Returns the yaw angle, that src_entity should be rotated by in order to face dest_entity.
<p>
This command can be used to be point one entity at another, rotating on the y axis only.
<p>
See also: <a href=#DeltaPitch>DeltaPitch</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityAlpha>
<tr><td class=doctop colspan=2>Function EntityAlpha( ent:TEntity,alpha:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the entity alpha level of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
Entity - entity handle
<p>
Alpha# - alpha level of entity
<p>
<b>Description</b>:
<p>
Sets the entity alpha level of an entity.
<p>
The alpha# value should be in a floating point value in the range 0-1. The default entity alpha setting is 1.
<p>
The alpha level is how transparent an entity is. A value of 1 will mean the entity is opaque. A value of 0 will mean the entity is completely transparent, i.e. invisible. Values between 0 and 1 will cause varying amount of transparency. This is useful for imitating the look of objects such as glass and other translucent materials.
<p>
An EntityAlpha value of 0 is especially useful as Blitz3D will not render entities with such a value, but will still involve the entities in collision tests. This is unlike HideEntity, which doesn't involve entities in collisions.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityBlend>
<tr><td class=doctop colspan=2>Function EntityBlend( ent:TEntity,blend:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the blending mode of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
Entity - Entity handle
<p>

Blend - Blend mode of the entity.
<p>
1: Alpha (default)
<p>
2: Multiply
<p>
3: Add
<p>
<b>Description</b>:
<p>
Sets the blending mode of an entity. This blending mode determines the way in which the new RGBA of the pixel being rendered is combined with the RGB of the background.
<p>
To calculate the new RGBA of the pixel being rendered, the texture RGBA for the pixel (see <a href=#TextureBlend>TextureBlend</a> for more information on how the texture RGBA is calculated) is taken, its alpha component multiplied by the entities/brushes (where applicable) alpha value and its color compentent multiplied by the entities/brushes colour. This is the RGBA which will then be blended into the background pixel, and how this is done depends on the EntityBlend value.
<p>
Alpha:
This blends the pixels according to the Alpha value. This is rougly done to the formula:
<p>
Rr = ( An * Rn ) + ( ( 1.0 - An ) * Ro )
Gr = ( An * Gn ) + ( ( 1.0 - An ) * Go )
Br = ( An * Bn ) + ( ( 1.0 - An ) * Bo )
<p>
Where R = Red, G = Green, B = Blue, n = new pixel colour values, r = resultant colour values, o = old pixel colour values.
<p>
Alpha blending is the default blending mode and is used with most world objects.
<p>
Multiply:
This blend mode will darken the underlying pixels. If you think of each RGB value as being on a scale from 0% to 100%, where 0 = 0% and 255 = 100%, the multiply blend mode will multiply the red, green and blue values individually together in order to get the new RGB value, roughly according to:
<p>
Rr = ( ( Rn / 255.0 ) * ( Ro / 255.0 ) ) * 255.0
Gr = ( ( Gn / 255.0 ) * ( Go / 255.0 ) ) * 255.0
Br = ( ( Bn / 255.0 ) * ( Bo / 255.0 ) ) * 255.0
<p>
The alpha value has no effect with multiplicative blending. Blending a RGB value of 255, 255, 255 will make no difference, while an RGB value of 128, 128, 128 will darken the pixels by a factor of 2 and an RGB value of 0, 0, 0 will completely blacken out the resultant pixels. An RGB value of 0, 255, 255 will remove the red component of the underlying pixel while leaving the other color values
untouched.
<p>
Multiply blending is most often used for lightmaps, shadows or anything else that needs to 'darken' the resultant pixels.
<p>
Add:
Additive blending will add the new color values to the old, roughly according to:
<p>
Rr = ( Rn * An ) + Ro
Gr = ( Gn * An ) + Go
Br = ( Bn * An ) + Bo
<p>
The resultant RGB values are clipped out at 255, meaning that multiple additive effects can quickly cause visible banding from smooth gradients.
<p>
Additive blending is extremely useful for effects such as laser shots and fire.
<p>
See also: <a href=#TextureBlend>TextureBlend</a>, <a href=#EntityAlpha>EntityAlpha</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityBox>
<tr><td class=doctop colspan=2>Function EntityBox( ent:TEntity,x:Float,y:Float,z:Float,w:Float,h:Float,d:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the dimensions of an entity's collision box.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle#
<p>
x# - x position of entity's collision box
<p>
y# - y position of entity's collision box
<p>
z# - z position of entity's collision box
<p>
width# - width of entity's collision box
<p>
height# - height of entity's collision box
<p>
depth# - depth of entity's collision box
<p>
<b>Description</b>:
<p>
Sets the dimensions of an entity's collision box.
<p>
See also: <a href=#EntityRadius>EntityRadius</a>, <a href=#Collisions>Collisions</a>, <a href=#EntityType>EntityType</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityClass>
<tr><td class=doctop colspan=2>Function EntityClass:String( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a string containing the class of the specified entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - a valid entity handle
<p>
<b>Description</b>:
<p>
Returns a string containing the class of the specified entity.
<p>
Possible return values are:
<p>
Pivot
Light
Camera
Mirror
Listener
Sprite
Terrain
Plane
Mesh
MD2
BSP
<p>
Note that the command will fail if a valid entity handle is not supplied, and will not just return an empty string.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityCollided>
<tr><td class=doctop colspan=2>Function EntityCollided:TEntity( ent:TEntity,type_no:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the handle of the entity of the specified type that collided with  the specified entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
type - type of entity
<p>
<b>Description</b>:
<p>
Returns the handle of the entity of the specified type that collided with  the specified entity.
<p>
See also: <a href=#CollisionX>CollisionX</a>, <a href=#CollisionY>CollisionY</a>, <a href=#CollisionZ>CollisionZ</a>, <a href=#CollisionNX>CollisionNX</a>, <a href=#CollisionNY>CollisionNY</a>, <a href=#CollisionNZ>CollisionNZ</a>, <a href=#CountCollisions>CountCollisions</a>, <a href=#EntityCollided>EntityCollided</a>, <a href=#CollisionTime>CollisionTime</a>, <a href=#CollisionEntity>CollisionEntity</a>, <a href=#CollisionSurface>CollisionSurface</a>, <a href=#CollisionTriangle>CollisionTriangle</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityColor>
<tr><td class=doctop colspan=2>Function EntityColor( ent:TEntity,red:Float,green:Float,blue:Float,recursive:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the color of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
Red# - red value of entity
<p>
Green# - green value of entity
<p>
Blue# - blue value of entity
<p>
<b>Description</b>:
<p>
Sets the color of an entity.
<p>
The Red, Green and Blue values should be in the range 0-255 with 0 being darkest and 255 brightest. The default entity color is 255,255,255 (White).</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityDistance>
<tr><td class=doctop colspan=2>Function EntityDistance:Float( ent1:TEntity,ent2:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the distance between src_entity and dest_entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
src_entity - source entity handle
<p>
dest_entity - destination entity handle
<p>
<b>Description</b>:
<p>
Returns the distance between src_entity and dest_entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityFX>
<tr><td class=doctop colspan=2>Function EntityFX( ent:TEntity,fx:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets miscellaneous effects for an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>

fx -
<p>
0: nothing (default)
<p>
1: full-bright
<p>
2: use vertex colors instead of brush color
<p>
4: flatshaded
<p>
8: disable fog
<p>
16: disable backface culling
<p>
32: force alpha-blending
<p>
<b>Description</b>:
<p>
Sets miscellaneous effects for an entity.
<p>
Flags can be added to combine  two or more effects. For example, specifying a flag of 3 (1+2) will result in  a full-bright and vertex-coloured brush.
<p>
Flag 32, to force alpha-blending, must be used in order to enable vertex alpha (see VertexColor).
<p>
See also: <a href=#VertexColor>VertexColor</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityInView>
<tr><td class=doctop colspan=2>Function EntityInView:Int( ent:TEntity,cam:TCamera )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns true if the specified entity is visible to the specified camera.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
camera - camera handle
<p>
<b>Description</b>:
<p>
Returns true if the specified entity is visible to the specified camera.
<p>
If the entity is a mesh, its bounding box will be checked for visibility.
<p>
For all other types of entities, only their centre position will be checked.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityName>
<tr><td class=doctop colspan=2>Function EntityName:String( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the name of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Returns the name of an entity. An entity's name may be set in a modelling  program, or manually set using NameEntity.
<p>
See also: <a href=#NameEntity>NameEntity</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityOrder>
<tr><td class=doctop colspan=2>Function EntityOrder( ent:TEntity,order:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the drawing order for an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
order - order that entity will be drawn in
<p>
<b>Description</b>:
<p>
Sets the drawing order for an entity.
<p>
An order value of 0 will mean the  entity is drawn normally. A value greater than 0 will mean that entity is drawn  first, behind everything else. A value less than 0 will mean the entity is drawn  last, in front of everything else.
<p>
Setting an entity's order to non-0 also disables z-buffering for the entity,  so should be only used for simple, convex entities like skyboxes, sprites etc.
<p>
EntityOrder affects the specified entity but none of its child entities,  if any exist.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityParent>
<tr><td class=doctop colspan=2>Function EntityParent( ent:TEntity,parent_ent:TEntity,glob:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Attaches an entity to a parent.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
parent - parent entity handle
<p>
global (optional) - true for the child entity to retain its global position  and orientation. Defaults to true.
<p>
<b>Description</b>:
<p>
Attaches an entity to a parent.
<p>
Parent may be 0, in which case the entity  will have no parent.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityPick>
<tr><td class=doctop colspan=2>Function EntityPick:TEntity( ent:TEntity,Range:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the nearest entity 'ahead' of the specified entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
range# - range of pick area around entity
<p>
<b>Description</b>:
<p>
Returns the nearest entity 'ahead' of the specified entity. An entity must  have a non-zero EntityPickMode to be pickable.
<p>
See also: <a href=#EntityPick>EntityPick</a>, <a href=#LinePick>LinePick</a>, <a href=#CameraPick>CameraPick</a>, <a href=#EntityPickMode>EntityPickMode</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityPickMode>
<tr><td class=doctop colspan=2>Function EntityPickMode( ent:TEntity,pick_mode:Int,obscurer:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the pick mode for an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>

pick_geometry - type of geometry used for picking:
<p>
0: Unpickable (default)
<p>
1: Sphere (EntityRadius is used)
<p>
2: Polygon
<p>
3: Box (EntityBox is used)
<p>

obscurer (optional) - True to determine that the entity 'obscures' other entities  during an EntityVisible call. Defaults to True.
<p>
<b>Description</b>:
<p>
Sets the pick mode for an entity.
<p>
The optional obscurer parameter is used  with EntityVisible to determine just what can  get in the way of the line-of-sight between 2 entities. This allows some entities  to be pickable using the other pick commands, but to be ignored (i.e. 'transparent')  when using EntityVisible. So, its very much EntityVisible specific.
<p>
Please note that only Sphere and Box picking will work with Blitz3D sprites. For polygon picking, you will need a valid mesh.
<p>
See also: <a href=#EntityPick>EntityPick</a>, <a href=#LinePick>LinePick</a>, <a href=#CameraPick>CameraPick</a>, <a href=#EntityPickMode>EntityPickMode</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityPitch>
<tr><td class=doctop colspan=2>Function EntityPitch:Float( ent:TEntity,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the pitch angle of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - name of entity that will have pitch angle returned
<p>
global (optional) - true if the pitch angle returned should be relative to 0 rather than a parent entity's pitch angle. False by default.
<p>
<b>Description</b>:
<p>
Returns the pitch angle of an entity.
<p>
The pitch angle is also the x angle of an entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityRadius>
<tr><td class=doctop colspan=2>Function EntityRadius( ent:TEntity,radius_x:Float,radius_y:Float=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the radius of an entity's collision ellipsoid.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
x_radius# - x radius of entity's collision ellipsoid
<p>
y_radius# (optional) - y radius of entity's collision ellipsoid. If omitted the x_radius# will be used for the y_radius#.
<p>
<b>Description</b>:
<p>
Sets the radius of an entity's collision ellipsoid.
<p>
An entity radius should be set for all entities involved in ellipsoidal collisions, which is all source entities (as collisions are always ellipsoid-to-something), and  whatever destination entities are involved in ellipsoid-to-ellipsoid collisions (collision method No.1).
<p>
See also: <a href=#EntityBox>EntityBox</a>, <a href=#Collisions>Collisions</a>, <a href=#EntityType>EntityType</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityRoll>
<tr><td class=doctop colspan=2>Function EntityRoll:Float( ent:TEntity,glob:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the roll angle of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - name of entity that will have roll angle returned
<p>
global (optional) - true if the roll angle returned should be relative to 0 rather than a parent entity's  roll angle. False by default.
<p>
<b>Description</b>:
<p>
Returns the roll angle of an entity.
<p>
The roll angle is also the z angle of an entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityShininess>
<tr><td class=doctop colspan=2>Function EntityShininess( ent:TEntity,shine:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the specular shininess of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
Entity - entity handle
<p>
Shininess# - shininess of entity
<p>
<b>Description</b>:
<p>
Sets the specular shininess of an entity.
<p>
The shininess# value should be a floting point number in the range 0-1. The default shininess setting is 0.
<p>
Shininess is how much brighter certain areas of an object will appear to be when a light is shone directly at them.
<p>
Setting a shininess value of 1 for a medium to high poly sphere, combined  with the creation of a light shining in the direction of it, will give it the  appearance of a shiny snooker ball.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityTexture>
<tr><td class=doctop colspan=2>Function EntityTexture( ent:TEntity,tex:TTexture,frame:Int=0,index:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Applies a texture to an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
texture - texture handle
<p>
frame (optional) - frame of texture. Defaults to 0.
<p>
index (optional) - index number of texture. Should be in the range to 0-7. Defaults  to 0.
<p>
<b>Description</b>:
<p>
Applies a texture to an entity.
<p>
The optional frame parameter specifies  which texture animation frame should be used as the texture.
<p>
The optional index parameter specifies which index number should be assigned  to the texture. Index numbers are used for the purpose of multitexturing. See TextureBlend.
<p>
A little note about multitexturing and slowdown. Graphics cards support a  maximum amount of textures per object, which can be used with very little, if  any, slowdown. For most cards this is two, but for a GeForce3 it is four. However,  once you use more than this amount, Blitz will emulate the effect itself by  duplicating objects and textures. Obviously, this may then cause slowdown.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityType>
<tr><td class=doctop colspan=2>Function EntityType( ent:TEntity,type_no:Int,recursive:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the collision type for an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
collision_type - collision type of entity. Must be in the range 0-999.
<p>
recursive (optional) - true to apply collision type to entity's children. Defaults  to false.
<p>
<b>Description</b>:
<p>
Sets the collision type for an entity.
<p>
A collision_type value of 0 indicates that no collision checking will occur with that entity. A collision value of 1-999 will mean collision checking will occur.
<p>
See also: <a href=#Collisions>Collisions</a>, <a href=#GetEntityType>GetEntityType</a>, <a href=#EntityBox>EntityBox</a>, <a href=#EntityRadius>EntityRadius</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityVisible>
<tr><td class=doctop colspan=2>Function EntityVisible:Int( src_ent:TEntity,dest_ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns true if src_entity and dest_entity can 'see' each other.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
src_entity - source entity handle
<p>
dest_entity - destination entity handle
<p>
<b>Description</b>:
<p>
Returns true if src_entity and dest_entity can 'see' each other.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityX>
<tr><td class=doctop colspan=2>Function EntityX:Float( ent:TEntity,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The X-coordinate of the entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity = handle of Loaded or Created Entity
<p>
global = True for Global coordinates,  False for Local. Optional, defaults to False.
<p>
<b>Description</b>:
<p>
The X-coordinate of the entity.
If the global flag is set to False then the parent's local coordinate system is used.
<p>
NOTE: If the entity has no parent then local and global coordinates are the same.
In this case you can think of the 3d world as the parent.
<p>
Global coordinates refer to the 3d world. Blitz 3D uses a left-handed system:
<p>
X+ is to the right
Y+ is up
Z+ is forward ( into the screen )
<p>
Every entity also has its own Local coordinate system.
<p>
The global system never changes.
But the local system is carried along as an entity moves and turns.
<p>
This same concept is used in the entity movement commands:
<p>
MoveEntity entity, 0,0,1
<p>
No matter what the orientation this moves one unit forward.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityY>
<tr><td class=doctop colspan=2>Function EntityY:Float( ent:TEntity,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The Y-coordinate of the entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity = handle of Loaded or Created Entity
<p>
global = True for Global coordinates,  False for Local. Optional, defaults to False.
<p>
<b>Description</b>:
<p>
The Y-coordinate of the entity.
If the global flag is set to False then the parent's local coordinate system is used.
<p>
See EntityX() for an overview of Local and Global coordinates.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityYaw>
<tr><td class=doctop colspan=2>Function EntityYaw:Float( ent:TEntity,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the yaw angle of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - name of entity that will have yaw angle returned
<p>
global (optional) - true if the yaw angle returned should be relative to 0 rather than a parent entity's  yaw angle. False by default.
<p>
<b>Description</b>:
<p>
Returns the yaw angle of an entity.
<p>
The yaw angle is also the y angle of an entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=EntityZ>
<tr><td class=doctop colspan=2>Function EntityZ:Float( ent:TEntity,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The Z-coordinate of the entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity = handle of Loaded or Created Entity
<p>
global = True for Global coordinates,  False for Local. Optional, defaults to False.
<p>
<b>Description</b>:
<p>
The Z-coordinate of the entity.
If the global flag is set to False then the parent's local coordinate system is used.
<p>
See EntityX() for an overview of Local and Global coordinates.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ExtractAnimSeq>
<tr><td class=doctop colspan=2>Function ExtractAnimSeq:Int( ent:TEntity,first_frame:Int,last_frame:Int,seq:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>This command allows you to convert an animation with an MD2-style series  of anim sequences into a pure Blitz anim sequence.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
first_frame - first frame of anim sequence to extract
<p>
last_frame - last frame of anim sequence to extract
<p>
anim_seq (optional) - anim sequence to extract from. This is usually 0, and  as such defaults to 0.
<p>
<b>Description</b>:
<p>
This command allows you to convert an animation with an MD2-style series  of anim sequences into a pure Blitz anim sequence, and play it back as such  using Animate.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FindChild>
<tr><td class=doctop colspan=2>Function FindChild:TEntity( ent:TEntity,child_name:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the first child of the specified entity with name matching child_name$</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
child_name$ - child name to find within entity
<p>
<b>Description</b>:
<p>
Returns the first child of the specified entity with name matching child_name$.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FindSurface>
<tr><td class=doctop colspan=2>Function FindSurface:TSurface( mesh:TMesh,brush:TBrush )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Attempts to find a surface attached to the specified mesh and created with  the specified brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
brush - brush handle
<p>
<b>Description</b>:
<p>
Attempts to find a surface attached to the specified mesh and created with  the specified brush. Returns the surface handle if found or 0 if not.
<p>
See  also: CountSurfaces, GetSurface.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FitMesh>
<tr><td class=doctop colspan=2>Function FitMesh( mesh:TMesh,x:Float,y:Float,z:Float,width:Float,height:Float,depth:Float,uniform:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Scales and translates all vertices of a mesh so that the mesh occupies the specified box.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
x# - x position of mesh
<p>
y# - y position of mesh
<p>
z# - z position of mesh
<p>
width# - width of mesh
<p>
height# - height of mesh
<p>
depth# - depth of mesh
<p>
uniform (optional) - if true, the mesh will be scaled by the same amounts in x, y and z, so will not be distorted. Defaults to false.
<p>
<b>Description</b>:
<p>
Scales and translates all vertices of a mesh so that the mesh occupies the specified box.
<p>
Do not use a width#, height# or depth# value of 0, otherwise all mesh data will be destroyed and your mesh will not be displayed. Use a value of 0.001 instead for a flat mesh along one axis.
<p>
See also: <a href=#ScaleMesh>ScaleMesh</a>, <a href=#ScaleEntity>ScaleEntity</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FlipMesh>
<tr><td class=doctop colspan=2>Function FlipMesh( mesh:TMesh )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Flips all the triangles in a mesh.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
<b>Description</b>:
<p>
Flips all the triangles in a mesh.
<p>
This is useful for a couple of reasons.  Firstly though, it is important to understand a little bit of the theory behind  3D graphics. A 3D triangle is represented by three points; only when these points  are presented to the viewer in a clockwise-fashion is the triangle visible.  So really, triangles only have one side.
<p>
Normally, for example in the case of a sphere, a model's triangles face the  inside of the model, so it doesn't matter that you can't see them. However,  what about if you wanted to use the sphere as a huge sky for your world, i.e.  so you only needed to see the inside? In this case you would just use FlipMesh.
<p>
Another use for FlipMesh is to make objects two-sided, so you can see them from  the inside and outside if you can't already. In this case, you can copy the  original mesh using CopyEntity, specifying the  original mesh as the parent, and flip it using FlipMesh. You will now have two  meshes occupying the same space - this will make it double-sided, but beware,  it will also double the polygon count!
<p>
The above technique is worth trying when an external modelling program has  exported a model in such a way that some of the triangles appear to be missing.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FreeBrush>
<tr><td class=doctop colspan=2>Function FreeBrush( brush:TBrush )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Frees up a brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
brush - brush handle
<p>
<b>Description</b>:
<p>
Frees up a brush.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FreeEntity>
<tr><td class=doctop colspan=2>Function FreeEntity( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>FreeEntity will free up the internal resources associated  with a particular entity and remove it from the scene.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
EntityHandle - Handle returned by an Entity creating function such as CreateCube(), CreateLight(), LoadMesh() etc.
<p>
<b>Description</b>:
<p>
FreeEntity will free up the internal resources associated  with a particular entity and remove it from the scene.
<p>
This command will also free all children entities parented to the entity.
<p>
Note that the variable holding the handle (and any variables referencing children handles) are not reset as it is up to the Blitz programmer to zero or ignore their contents following a call to FreeEntity().</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=FreeTexture>
<tr><td class=doctop colspan=2>Function FreeTexture( tex:TTexture )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Frees up a texture from memory.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
texture - texture handle
<p>
<b>Description</b>:
<p>
Frees up a texture from memory.
<p>
Freeing a texture means you will not be  able to use it again; however, entities already textured with it will not lose  the texture.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GetBrushTexture>
<tr><td class=doctop colspan=2>Function GetBrushTexture:TTexture( brush:TBrush,index:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the texture that is applied to the specified brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
brush - brush handle
<p>
index (optional) - index of texture applied to brush, from 0-7. Defaults to 0.
<p>
<b>Description</b>:
<p>
Returns the texture that is applied to the specified brush.
<p>
The optional index parameter allows you to specify which particular texture you'd like returning, if there are more than one textures applied to a brush.
<p>
You should release the texture returned by GetBrushTexture after use to prevent leaks! Use <a href=#FreeTexture>FreeTexture</a> to do this.
<p>
To find out the name of the texture, use <a href=#TextureName>TextureName</a>
<p>
See also: <a href=#TextureName>TextureName</a>, <a href=#FreeTexture>FreeTexture</a>, <a href=#GetEntityBrush>GetEntityBrush</a>, <a href=#GetSurfaceBrush>GetSurfaceBrush</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GetChild>
<tr><td class=doctop colspan=2>Function GetChild:TEntity( ent:TEntity,child_no:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a child of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
index - index of child entity. Should be in the range 1...CountChildren(  entity ) inclusive.
<p>
<b>Description</b>:
<p>
Returns a child of an entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GetEntityBrush>
<tr><td class=doctop colspan=2>Function GetEntityBrush:TBrush( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a brush with the same properties as is applied to the specified entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Returns a brush with the same properties as is applied to the specified entity.
<p>
If this command does not appear to be returning a valid brush, try using <a href=#GetSurfaceBrush>GetSurfaceBrush</a> instead with the first surface available.
<p>
Remember, GetEntityBrush actually creates a new brush so don't forget to free it afterwards using FreeBrush to prevent memory leaks.
<p>
Once you have got the brush handle from an entity, you can use GetBrushTexture and TextureName to get the details of what texture(s) are applied to the brush.
<p>
See also: <a href=#GetSurfaceBrush>GetSurfaceBrush</a>, <a href=#FreeBrush>FreeBrush</a>, <a href=#GetBrushTexture>GetBrushTexture</a>, <a href=#TextureName>TextureName</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GetEntityType>
<tr><td class=doctop colspan=2>Function GetEntityType:Int( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the collision type of an entity as set by the EntityType command.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Returns the collision type of an entity as set by the EntityType command.
<p>
See also: <a href=#EntityType>EntityType</a>, <a href=#EntityBox>EntityBox</a>, <a href=#EntityRadius>EntityRadius</a>, <a href=#Collisions>Collisions</a>, <a href=#ResetEntity>ResetEntity</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GetMatElement>
<tr><td class=doctop colspan=2>Function GetMatElement:Float( ent:TEntity,row:Int,col:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the value of an element from within an entity's transformation matrix.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
row - matrix row index
<p>
column - matrix column index
<p>
<b>Description</b>:
<p>
Returns the value of an element from within an entity's transformation matrix.
<p>
The transformation matrix is what is used by Blitz internally to position, scale and rotate entities.
<p>
GetMatElement is intended for use by advanced users only.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GetParent>
<tr><td class=doctop colspan=2>Function GetParent:TEntity( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns an entity's parent.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Returns an entity's parent.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GetSurface>
<tr><td class=doctop colspan=2>Function GetSurface:TSurface( mesh:TMesh,surf_no:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the handle of the surface attached to the specified mesh and with  the specified index number.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
index - index of surface
<p>
<b>Description</b>:
<p>
Returns the handle of the surface attached to the specified mesh and with  the specified index number.
<p>
Index should be in the range 1...CountSurfaces(  mesh ), inclusive.
<p>
You need to 'get a surface', i.e. get its handle, in order to be able to  then use that particular surface with other commands.
<p>
See also: <a href=#CountSurfaces>CountSurfaces</a>, <a href=#FindSurface>FindSurface</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=GetSurfaceBrush>
<tr><td class=doctop colspan=2>Function GetSurfaceBrush:TBrush( surf:TSurface )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a brush with the same properties as is applied to the specified mesh surface.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
<b>Description</b>:
<p>
Returns a brush with the same properties as is applied to the specified mesh surface.
<p>
If this command does not appear to be returning a valid brush, try using <a href=#GetEntityBrush>GetEntityBrush</a> instead.
<p>
Remember, GetSurfaceBrush actually creates a new brush so don't forget to free it afterwards using <a href=#FreeBrush>FreeBrush</a> to prevent memory leaks.
<p>
Once you have got the brush handle from a surface, you can use <a href=#GetBrushTexture>GetBrushTexture</a> and <a href=#TextureName>TextureName</a> to get the details of what texture(s) are applied to the brush.
<p>
See also: <a href=#GetEntityBrush>GetEntityBrush</a>, <a href=#FreeBrush>FreeBrush</a>, <a href=#GetSurface>GetSurface</a>, <a href=#GetBrushTexture>GetBrushTexture</a>, <a href=#TextureName>TextureName</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=HandleSprite>
<tr><td class=doctop colspan=2>Function HandleSprite( sprite:TSprite,h_x:Float,h_y:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets a sprite handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
sprite - sprite handle. Not to be confused with HandleSprite - ie. the handle  used to position the sprite, rather than the sprite's actual handle
<p>
<b>Description</b>:
<p>
Sets a sprite handle. Defaults to 0,0.
<p>
A sprite extends from -1,-1 to +1,+1.
<p>
See also: <a href=#LoadSprite>LoadSprite</a>, <a href=#CreateSprite>CreateSprite</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=HideEntity>
<tr><td class=doctop colspan=2>Function HideEntity( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Hides an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Hides an entity, so that it is no longer visible, and is no longer involved  in collisions.
<p>
The main purpose of hide entity is to allow you to create entities  at the beginning of a program, hide them, then copy them and show as necessary  in the main game. This is more efficient than creating entities mid-game.
<p>
If you wish to hide an entity so that it is no longer visible but still involved  in collisions, then use EntityAlpha 0 instead.  This will make an entity completely transparent.
<p>
HideEntity affects the specified entity and all of its child entities, if  any exist.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LightColor>
<tr><td class=doctop colspan=2>Function LightColor( light:TLight,red:Float,green:Float,blue:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the color of a light.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
light - light handle
<p>
red# - red value of light
<p>
green# - green value of light
<p>
blue# - blue value of light
<p>
<b>Description</b>:
<p>
Sets the color of a light.
<p>
An r,g,b value of 255,255,255 will brighten  anything the light shines on.
<p>
An r,g,b value of 0,0,0 will have no affect on anything it shines on.
<p>
An r,g,b value of -255,-255,-255 will darken anything it shines on. This is  known as 'negative lighting', and is useful for shadow effects.
<p>
See also: <a href=#CreateLight>CreateLight</a>, <a href=#LightRange>LightRange</a>, <a href=#LightConeAngles>LightConeAngles</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LightConeAngles>
<tr><td class=doctop colspan=2>Function LightConeAngles( light:TLight,inner_ang:Float,outer_ang:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the 'cone' angle for a 'spot' light.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
light - light handle
<p>
inner_angle# - inner angle of cone
<p>
outer_angle# - outer angle of cone
<p>
<b>Description</b>:
<p>
Sets the 'cone' angle for a 'spot' light.
<p>
The default light cone angles setting  is 0,90.
<p>
See also: <a href=#CreateLight>CreateLight</a>, <a href=#LightRange>LightRange</a>, <a href=#LightColor>LightColor</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LightRange>
<tr><td class=doctop colspan=2>Function LightRange( light:TLight,Range:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the range of a light.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
light - light handle
<p>
range# - range of light (default: 1000.0)
<p>
<b>Description</b>:
<p>
Sets the range of a light.
<p>
The range of a light is how far it reaches.  Everything outside the range of the light will not be affected by it.
<p>
The value is very approximate, and should be experimented with for best results.
<p>
See also: <a href=#CreateLight>CreateLight</a>, <a href=#LightColor>LightColor</a>, <a href=#LightConeAngles>LightConeAngles</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LinePick>
<tr><td class=doctop colspan=2>Function LinePick:TEntity( x:Float,y:Float,z:Float,dx:Float,dy:Float,dz:Float,radius:Float=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the first entity between x.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
x# - x coordinate of start of line pick
<p>
y# - y coordinate of start of line pick
<p>
z# - z coordinate of start of line pick
<p>
dx# - distance x of line pick
<p>
dy# - distance y of line pick
<p>
dz# - distance z of line pick
<p>
radius (optional) - radius of line pick
<p>
<b>Description</b>:
<p>
Returns the first entity between x,y,z to x+dx,y+dy,z+dz.
<p>
See also: <a href=#EntityPick>EntityPick</a>, <a href=#LinePick>LinePick</a>, <a href=#CameraPick>CameraPick</a>, <a href=#EntityPickMode>EntityPickMode</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadAnimMesh>
<tr><td class=doctop colspan=2>Function LoadAnimMesh:TMesh( file:String,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>LoadAnimMesh.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
Filename$ - Name of the file containing the model to load.
<p>
Parent (optional) - Specify an entity to act as a Parent to the loaded mesh.
<p>
<b>Description</b>:
<p>
LoadAnimMesh, similar to LoadMesh, Loads a mesh from an .X, .3DS or .B3D file and returns a mesh handle.
<p>
The difference between LoadMesh and LoadAnimMesh is that any hierarchy and animation information present in the file is retained. You can then either activate the animation by using the Animate command or find child entities within the hierarchy by using the FindChild(), GetChild() functions.
<p>
The optional parent parameter allows you to specify a parent entity for the mesh so that when the parent is moved the child mesh will move with it. However, this relationship is one way;  applying movement commands to the child will not affect the parent.
<p>
Specifying a parent entity will still result in the mesh being created at position 0,0,0 rather than at the parent entity's position.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadAnimSeq>
<tr><td class=doctop colspan=2>Function LoadAnimSeq:Int( ent:TEntity,file:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Appends an animation sequence from a file to an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
filename$ - filename of animated 3D object
<p>
<b>Description</b>:
<p>
Appends an animation sequence from a file to an entity.
<p>
Returns the animation  sequence number added.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadAnimTexture>
<tr><td class=doctop colspan=2>Function LoadAnimTexture:TTexture( file:String,flags:Int,frame_width:Int,frame_height:Int,first_frame:Int,frame_count:Int,tex:TTexture=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Loads an animated texture from an image file and returns the texture's handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
file$ - name of image file with animation frames laid out in left-right,  top-to-bottom order
<p>

flags (optional) - texture flag:
<p>
1: Color (default)
<p>
2: Alpha
<p>
4: Masked
<p>
8: Mipmapped
<p>
16: Clamp U
<p>
32: Clamp V
<p>
64: Spherical reflection map
<p>
128: Cubic environment map
<p>
256: Store texture in vram
<p>
512: Force the use of high color textures
<p>

frame_width - width of each animation frame
<p>
frame_height - height of each animation frame
<p>
first_frame - the first frame to be used as an animation frame
<p>
frame_count - the amount of frames to be used
<p>
<b>Description</b>:
<p>
Loads an animated texture from an image file and returns the texture's handle.
<p>
The flags parameter allows you to apply certain effects to the texture. Flags  can be added to combine two or more effects, e.g. 3 (1+2) = texture with colour  and alpha maps.
<p>
See <a href=#CreateTexture>CreateTexture</a> for more detailed descriptions of the texture flags.
<p>
The frame_width, frame_height, first_frame and frame_count parameters determine how Blitz will separate the image file into individual animation frames.
<p>
See also: <a href=#CreateTexture>CreateTexture</a>, <a href=#LoadTexture>LoadTexture</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadBrush>
<tr><td class=doctop colspan=2>Function LoadBrush:TBrush( file:String,flags:Int=9,u_scale:Float=1,v_scale:Float=1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
texture_file$ - filename of texture
<p>
flags - brush flags
<p>

flags (optional) - flags can be added to combine effects:
<p>
1: Color
<p>
2: Alpha
<p>
4: Masked
<p>
8: Mipmapped
<p>
16: Clamp U
<p>
32: Clamp V
<p>
64: Spherical reflection map
<p>

u_scale - brush u_scale
<p>
v_scale - brush v_scale
<p>
<b>Description</b>:
<p>
Creates a brush, loads and assigns a texture to it, and returns a brush handle.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadMesh>
<tr><td class=doctop colspan=2>Function LoadMesh:TMesh( file:String,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>LoadMesh.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
Filename$ - Name of the file containing the model to load.
<p>
Parent (optional) - Specify an entity to act as a Parent to the loaded mesh.
<p>
<b>Description</b>:
<p>
LoadMesh, as the name suggests, Loads a mesh from an .X, .3DS or .B3D file (Usually created in advance by one of a number of 3D model creation packages) and returns the mesh handle.
<p>
Any hierarchy and animation information in the file will be ignored. Use LoadAnimMesh to maintain hierarchy and  animation information.
<p>
The optional parent parameter allows you to specify a parent entity for the mesh so that when the parent is moved the child mesh will move with it. However, this relationship is one way;  applying movement commands to the child will not affect the parent.
<p>
Specifying a parent entity will still result in the mesh being created at position 0,0,0 rather than at the parent entity's position.
<p>
See also: <a href=#LoadAnimMesh>LoadAnimMesh</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadSprite>
<tr><td class=doctop colspan=2>Function LoadSprite:TSprite( tex_file:String,tex_flag:Int=1,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a sprite entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
text_file$ - filename of image file to be used as sprite
<p>

tex_flag (optional) - texture flag:
<p>
1: Color
<p>
2: Alpha
<p>
4: Masked
<p>
8: Mipmapped
<p>
16: Clamp U
<p>
32: Clamp V
<p>
64: Spherical reflection map
<p>

parent - parent of entity
<p>
<b>Description</b>:
<p>
Creates a sprite entity, and assigns a texture to it.
<p>
See also: <a href=#LoadSprite>LoadSprite</a>, <a href=#RotateSprite>RotateSprite</a>, <a href=#ScaleSprite>ScaleSprite</a>, <a href=#HandleSprite>HandleSprite</a>, <a href=#SpriteViewMode>SpriteViewMode</a>, <a href=#PositionEntity>PositionEntity</a>, <a href=#MoveEntity>MoveEntity</a>, <a href=#TranslateEntity>TranslateEntity</a>, <a href=#EntityAlpha>EntityAlpha</a>, <a href=#FreeEntity>FreeEntity</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadTerrain>
<tr><td class=doctop colspan=2>Function LoadTerrain:TTerrain( file:String,parent:TEntity=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Loads a terrain from an image file and returns the terrain's handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
file$ - filename of image file to be used as height map
<p>
parent (optional) - parent entity of terrain
<p>
<b>Description</b>:
<p>
Loads a terrain from an image file and returns the terrain's handle.
<p>
The  image's red channel is used to determine heights. Terrain is initially the same  width and depth as the image, and 1 unit high.
<p>
Tips on generating nice terrain:
<p>
* Smooth or blur the height map
* Reduce the y scale of the terrain
* Increase the x/z scale of the terrain
* Reduce the camera range
<p>
When texturing an entity, a texture with a scale of 1,1,1 (default) will  be the same size as one of the terrain's grid squares. A texture that is scaled  to the same size as the size of the bitmap used to load it or the no. of grid  square used to create it, will be the same size as the terrain.
<p>
The optional parent parameter allows you to specify a parent  entity for the terrain so that when the parent is moved the child terrain will  move with it. However, this relationship is one way; applying movement commands  to the child will not affect the parent.
<p>
Specifying a parent entity will still result in the terrain being created  at position 0,0,0 rather than at the parent entity's position.
<p>
A heightmaps dimensions (width and height) must be the same and must be a power of 2, e.g. 32, 64, 128, 256, 512, 1024.
<p>
See also: <a href=#CreateTerrain>CreateTerrain</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=LoadTexture>
<tr><td class=doctop colspan=2>Function LoadTexture:TTexture( file:String,flags:Int=9,tex:TTexture=Null )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Load a texture from an image file and returns the texture's handle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
file$ - filename of image file to be used as texture
<p>

<p>
flags (optional) - texture flag:
<p>
1: Color (default)
<p>
2: Alpha
<p>
4: Masked
<p>
8: Mipmapped
<p>
16: Clamp U
<p>
32: Clamp V
<p>
64: Spherical environment map
<p>
128: Cubic environment map
<p>
256: Store texture in vram
<p>
512: Force the use of high color textures
<p>
<b>Description</b>:
<p>
Load a texture from an image file and returns the texture's handle.  Supported file formats include: BMP, PNG, TGA and JPG.  Only PNG and TGA support alpha.
<p>

The optional flags parameter allows you to apply certain effects to the texture. Flags can be added to combine two or more effects, e.g. 3 (1+2) = texture with colour and alpha maps.
<p>

See <a href=#CreateTexture>CreateTexture</a> for more detailed descriptions of the texture flags.
<p>

Something to consider when applying texture flags to loaded textures is that the texture may have already had certain flags applied to it via the <a href=#TextureFilter>TextureFilter</a> command. The default for the <a href=#TextureFilter>TextureFilter</a> command is 9 (1+8), which is a coloured, mipmapped texture. This cannot be overridden via the flags parameter of the LoadTexture command - if you wish for the filters to be removed you will need to use the <a href=#ClearTextureFilters>ClearTextureFilters</a> command, which must be done after setting the graphics mode (setting the graphics mode restores the default texture filters).
<p>
See also: <a href=#CreateTexture>CreateTexture</a>, <a href=#LoadAnimTexture>LoadAnimTexture</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=MeshDepth>
<tr><td class=doctop colspan=2>Function MeshDepth:Float( mesh:TMesh )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the depth of a mesh.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
<b>Description</b>:
<p>
Returns the depth of a mesh. This is calculated by the actual vertex positions and so the scale of the entity (set by ScaleEntity) will not have an effect on the resultant depth. Mesh operations, on the other hand, will effect the result.
<p>
See also: <a href=#MeshWidth>MeshWidth</a>, <a href=#MeshHeight>MeshHeight</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=MeshesIntersect>
<tr><td class=doctop colspan=2>Function MeshesIntersect:Int( mesh1:TMesh,mesh2:TMesh )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns true if the specified meshes are currently intersecting.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh_a - mesh_a handle
<p>
mesh_b - mesh_b handle
<p>
<b>Description</b>:
<p>
Returns true if the specified meshes are currently intersecting.
<p>
This  is a fairly slow routine - use with discretion...
<p>
This command is  currently the only  polygon->polygon collision checking routine available in Blitz3D.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=MeshHeight>
<tr><td class=doctop colspan=2>Function MeshHeight:Float( mesh:TMesh )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the height of a mesh.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
<b>Description</b>:
<p>
Returns the height of a mesh. This is calculated by the actual vertex positions and so the scale of the entity (set by ScaleEntity) will not have an effect on the resultant height. Mesh operations, on the other hand, will effect the result.
<p>
See also: <a href=#MeshWidth>MeshWidth</a>, <a href=#MeshDepth>MeshDepth</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=MeshWidth>
<tr><td class=doctop colspan=2>Function MeshWidth:Float( mesh:TMesh )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the width of a mesh.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
<b>Description</b>:
<p>
Returns the width of a mesh. This is calculated by the actual vertex positions and so the scale of the entity (set by ScaleEntity) will not have an effect on the resultant width. Mesh operations, on the other hand, will effect the result.
<p>
See also: <a href=#MeshHeight>MeshHeight</a>, <a href=#MeshDepth>MeshDepth</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ModifyTerrain>
<tr><td class=doctop colspan=2>Function ModifyTerrain( terr:TTerrain,x:Int,z:Int,new_height:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the height of a point on a terrain.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
terrain - terrain handle
<p>
grid_x - grid x coordinate of terrain
<p>
grid_y - grid y coordinate of terrain
<p>
height# - height of point on terrain. Should be in the range 0-1.
<p>
realtime (optional) - True to modify terrain immediately. False to modify terrain  when RenderWorld in next called. Defaults to False.
<p>
<b>Description</b>:
<p>
Sets the height of a point on a terrain.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=MoveEntity>
<tr><td class=doctop colspan=2>Function MoveEntity( ent:TEntity,x:Float,y:Float,z:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Moves an entity relative to its current position and orientation.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - name of entity to be moved
<p>
x# - x amount that entity will be moved by
<p>
y# - y amount that entity will be moved by
<p>
z# - z amount that entity will be moved by
<p>
<b>Description</b>:
<p>
Moves an entity relative to its current position and orientation.
<p>
What this means is that an entity will move in whatever direction it is facing. So for example if you have an game character is upright when first loaded into Blitz3D and it remains upright (i.e. turns left or right only), then moving it by a z amount will always see it move forward or backward, moving it by a y amount will always see it move up or down, and moving it by an x amount will always see it strafe.
<p>
See also: <a href=#TranslateEntity>TranslateEntity</a>, <a href=#PositionEntity>PositionEntity</a>, <a href=#PositionMesh>PositionMesh</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=NameEntity>
<tr><td class=doctop colspan=2>Function NameEntity( ent:TEntity,name:String )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets an entity's name.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
name$ - name of entity
<p>
<b>Description</b>:
<p>
Sets an entity's name.
<p>
See also: <a href=#EntityName>EntityName</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PaintEntity>
<tr><td class=doctop colspan=2>Function PaintEntity( ent:TEntity,brush:TBrush )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Paints a entity with a brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
brush - brush handle
<p>
<b>Description</b>:
<p>
Paints a entity with a brush.
<p>
The reason for using PaintEntity to apply  specific properties to a entity using a brush rather than just using EntityTexture,  EntityColor, EntityShininess etc, is that you can pre-define one brush, and  then paint entities over and over again using just the one command rather than  lots of separate ones.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PaintMesh>
<tr><td class=doctop colspan=2>Function PaintMesh( mesh:TMesh,brush:TBrush )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Paints a mesh with a brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
brush - brush handle
<p>
<b>Description</b>:
<p>
Paints a mesh with a brush.
<p>
This has the effect of instantly altering  the visible appearance of the mesh, assuming the brush's properties are different  to what was was applied to the surface before.
<p>
The reason for using PaintMesh to apply specific properties to a mesh using  a brush rather than just using EntityTexture, EntityColor, EntityShininess etc,  is that you can pre-define one brush, and then paint meshes over and over again  using just the one command rather than lots of separate ones.
<p>
See also: <a href=#PaintEntity>PaintEntity</a>, <a href=#PaintSurface>PaintSurface</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PaintSurface>
<tr><td class=doctop colspan=2>Function PaintSurface( surf:TSurface,brush:TBrush )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Paints a surface with a brush.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
brush - brush handle
<p>
<b>Description</b>:
<p>
Paints a surface with a brush.
<p>
This has the effect of instantly altering  the visible appearance of that particular surface, i.e. section of mesh, assuming  the brush's properties are different to what was applied to the surface before.
<p>
See also: <a href=#PaintEntity>PaintEntity</a>, <a href=#PaintMesh>PaintMesh</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PickedEntity>
<tr><td class=doctop colspan=2>Function PickedEntity:TEntity()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the entity 'picked' by the most recently executed Pick command.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the entity 'picked' by the most recently executed Pick command.  This might have been CameraPick, EntityPick or LinePick.
<p>
Returns 0 if no entity was picked.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PickedNX>
<tr><td class=doctop colspan=2>Function PickedNX:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the x component of the normal of the most recently executed Pick  command.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the x component of the normal of the most recently executed Pick  command. This might have been CameraPick, EntityPick or LinePick.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PickedNY>
<tr><td class=doctop colspan=2>Function PickedNY:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the y component of the normal of the most recently executed Pick  command.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the y component of the normal of the most recently executed Pick  command. This might have been CameraPick, EntityPick or LinePick.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PickedNZ>
<tr><td class=doctop colspan=2>Function PickedNZ:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the z component of the normal of the most recently executed Pick  command.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the z component of the normal of the most recently executed Pick  command. This might have been CameraPick, EntityPick or LinePick.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PickedSurface>
<tr><td class=doctop colspan=2>Function PickedSurface:TSurface()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the handle of the surface that was 'picked' by the most recently  executed Pick command.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the handle of the surface that was 'picked' by the most recently  executed Pick command. This might have been CameraPick, EntityPick or LinePick.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PickedTime>
<tr><td class=doctop colspan=2>Function PickedTime:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the time taken to calculate the most recently executed Pick command.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the time taken to calculate the most recently executed Pick command.  This might have been CameraPick, EntityPick or LinePick.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PickedTriangle>
<tr><td class=doctop colspan=2>Function PickedTriangle:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the index number of the triangle that was 'picked' by the most recently  executed Pick command.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the index number of the triangle that was 'picked' by the most recently  executed Pick command. This might have been CameraPick, EntityPick or LinePick.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PickedX>
<tr><td class=doctop colspan=2>Function PickedX:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the world x coordinate of the most recently executed Pick command.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the world x coordinate of the most recently executed Pick command.  This might have been CameraPick, EntityPick or LinePick.
<p>
The coordinate represents the exact point of where something was picked.
<p>
See also: <a href=#PickedY>PickedY</a>, <a href=#PickedZ>PickedZ</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PickedY>
<tr><td class=doctop colspan=2>Function PickedY:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the world y coordinate of the most recently executed Pick command.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the world y coordinate of the most recently executed Pick command.  This might have been CameraPick, EntityPick or LinePick.
<p>
The coordinate represents the exact point of where something was picked.
<p>
See also: <a href=#PickedX>PickedX</a>, <a href=#PickedZ>PickedZ</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PickedZ>
<tr><td class=doctop colspan=2>Function PickedZ:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the world z coordinate of the most recently executed Pick command.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the world z coordinate of the most recently executed Pick command.  This might have been CameraPick, EntityPick or LinePick.
<p>
The coordinate represents the exact point of where something was picked.
<p>
See also: <a href=#PickedX>PickedX</a>, <a href=#PickedY>PickedY</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PointEntity>
<tr><td class=doctop colspan=2>Function PointEntity( ent:TEntity,target_ent:TEntity,roll:Float=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Points one entity at another.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
target - target entity handle
<p>
roll# (optional) - roll angle of entity
<p>
<b>Description</b>:
<p>
Points one entity at another.
<p>
The optional roll parameter allows you to  specify a roll angle as pointing an entity only sets pitch and yaw angles.
<p>
If you wish for an entity to point at a certain position rather than another  entity, simply create a pivot entity at your desired position, point the entity  at this and then free the pivot.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PositionEntity>
<tr><td class=doctop colspan=2>Function PositionEntity( ent:TEntity,x:Float,y:Float,z:Float,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Positions an entity at an absolute position in 3D space.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - name of entity to be positioned
<p>
x# - x co-ordinate that entity will be positioned at
<p>
y# - y co-ordinate that entity will be positioned at
<p>
z# - z co-ordinate that entity will be positioned at
<p>
global (optional) - true if the position should be relative to 0,0,0 rather than a parent entity's position. False by default.
<p>
<b>Description</b>:
<p>
Positions an entity at an absolute position in 3D space.
<p>
Entities are positioned using an x,y,z coordinate system. x, y and z each have their own axis, and each axis has its own set of values. By specifying a value for each axis, you can position an entity anywhere in 3D space. 0,0,0 is the centre of 3D space, and if the camera is pointing in the default positive z direction, then positioning an entity with a z value of above 0 will make it appear in front of the camera, whereas a negative z value would see it disappear behind the camera. Changing the x value would see it moving sideways, and changing the y value would see it moving up/down.
<p>
Of course, the direction in which entities appear to move is relative to the position and orientation of the camera.
<p>
See also: <a href=#MoveEntity>MoveEntity</a>, <a href=#TranslateEntity>TranslateEntity</a>, <a href=#PositionMesh>PositionMesh</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PositionMesh>
<tr><td class=doctop colspan=2>Function PositionMesh( mesh:TMesh,px:Float,py:Float,pz:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Moves all vertices of a mesh.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
x# - x position of mesh
<p>
y# - y position of mesh
<p>
z# - z position of mesh
<p>
<b>Description</b>:
<p>
Moves all vertices of a mesh.
<p>
See also: <a href=#PositionEntity>PositionEntity</a>, <a href=#MoveEntity>MoveEntity</a>, <a href=#TranslateEntity>TranslateEntity</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=PositionTexture>
<tr><td class=doctop colspan=2>Function PositionTexture( tex:TTexture,u_pos:Float,v_pos:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Positions a texture at an absolute position.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
texture - texture handle
<p>
u_position# - u position of texture
<p>
v_position# - v position of texture
<p>
<b>Description</b>:
<p>
Positions a texture at an absolute position.
<p>
This will have an  immediate effect on all instances of the texture being used.
<p>
Positioning a texture is useful for performing scrolling texture effects,  such as for water etc.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ProjectedX>
<tr><td class=doctop colspan=2>Function ProjectedX:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the viewport x coordinate of the most recently executed CameraProject.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the viewport x coordinate of the most recently executed CameraProject.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ProjectedY>
<tr><td class=doctop colspan=2>Function ProjectedY:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the viewport y coordinate of the most recently executed CameraProject.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the viewport y coordinate of the most recently executed CameraProject.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ProjectedZ>
<tr><td class=doctop colspan=2>Function ProjectedZ:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the viewport z coordinate of the most recently executed CameraProject.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the viewport z coordinate of the most recently executed CameraProject.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=RenderWorld>
<tr><td class=doctop colspan=2>Function RenderWorld()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Renders the current scene to the BackBuffer onto the rectangle defined by each cameras CameraViewport( )</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
tween# (optional) - defaults to 1.
<p>
<b>Description</b>:
<p>
Renders the current scene to the BackBuffer onto the rectangle defined by each cameras CameraViewport( ). Every camera not hidden by HideEntity( ) or with a CameraProjMode( ) of 0 is rendered. Rendering to other buffers is currently not supported by Blitz3D.
<p>
The optional tween parameter should only be specified when RenderWorld is used in conjunction with CaptureWorld. CaptureWorld is used to store the 'old' position, rotation and scale, alpha and colour of each entity in the game world, and a tween value of
<p>
The use of tweening allows you to render more than one frame per game logic update, while still keeping the display smooth. This allows you to cut down on the CPU time that would be required to update your game logic every render. Note, however, that the bottleneck in almost all 3D applications is the graphics card and the CPU time involved in updating game logic is often very little. A good alternative to render tweening is the use of a delta time, that is, moving your entities each frame depending on the time it took for the program to process and render that frame.
<p>
Render tweening is quite an advanced technique, and it is not necessary to  use it, so don't worry if you don't quite understand it. See the castle demo  included in the mak (nickname of Mark Sibly, author of Blitz3D) directory of  the Blitz3D samples section for a demonstration of render tweening.
<p>
See also: <a href=#CaptureWorld>CaptureWorld</a>, <a href=#CameraViewport>CameraViewport</a>, <a href=#CameraProjMode>CameraProjMode</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ResetEntity>
<tr><td class=doctop colspan=2>Function ResetEntity( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Resets the collision state of an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Resets the collision state of an entity.
<p>
See also: <a href=#EntityBox>EntityBox</a>, <a href=#EntityRadius>EntityRadius</a>, <a href=#Collisions>Collisions</a>, <a href=#EntityType>EntityType</a>, <a href=#GetEntityType>GetEntityType</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=RotateEntity>
<tr><td class=doctop colspan=2>Function RotateEntity( ent:TEntity,x:Float,y:Float,z:Float,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotates an entity so that it is at an absolute orientation.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - name of the entity to be rotated
<p>
pitch# - angle in degrees of pitch rotation
<p>
yaw# - angle in degrees of yaw rotation
<p>
roll# - angle in degrees of roll rotation
<p>
global (optional) - true if the angle rotated should be relative to 0,0,0 rather than a parent entity's orientation. False by default.
<p>
<b>Description</b>:
<p>
Rotates an entity so that it is at an absolute orientation.
<p>
Pitch is the same as the x angle of an entity, and is equivalent to tilting forward/backwards.
<p>
Yaw is the same as the y angle of an entity, and is equivalent to turning left/right.
<p>
Roll is the same as the z angle of an entity, and is equivalent to tilting left/right.
<p>
See also: <a href=#TurnEntity>TurnEntity</a>, <a href=#RotateMesh>RotateMesh</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=RotateMesh>
<tr><td class=doctop colspan=2>Function RotateMesh( mesh:TMesh,pitch:Float,yaw:Float,roll:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotates all vertices of a mesh by the specified rotation.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
pitch# - pitch of mesh
<p>
yaw# - yaw of mesh
<p>
roll# - roll of mesh
<p>
<b>Description</b>:
<p>
Rotates all vertices of a mesh by the specified rotation.
<p>
See also: <a href=#RotateEntity>RotateEntity</a>, <a href=#TurnEntity>TurnEntity</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=RotateSprite>
<tr><td class=doctop colspan=2>Function RotateSprite( sprite:TSprite,ang:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotates a sprite.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
sprite - sprite handle
<p>
angle# - absolute angle of sprite rotation
<p>
<b>Description</b>:
<p>
Rotates a sprite.
<p>
See also: <a href=#CreateSprite>CreateSprite</a>, <a href=#LoadSprite>LoadSprite</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=RotateTexture>
<tr><td class=doctop colspan=2>Function RotateTexture( tex:TTexture,ang:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Rotates a texture.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
texture - texture handle
<p>
angle# - absolute angle of texture rotation
<p>
<b>Description</b>:
<p>
Rotates a texture.
<p>
This will have an immediate effect on all instances  of the texture being used.
<p>
Rotating a texture is useful for performing swirling texture effects,  such as for smoke etc.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ScaleEntity>
<tr><td class=doctop colspan=2>Function ScaleEntity( ent:TEntity,x:Float,y:Float,z:Float,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Scales an entity so that it is of an absolute size.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - name of the entity to be scaled
<p>
x_scale# - x size of entity
<p>
y_scale# - y size of entity
<p>
z_scale# - z size of entity
<p>
global (optional) -
<p>
<b>Description</b>:
<p>
Scales an entity so that it is of an absolute size.
<p>
Scale values of 1,1,1 are the default size when creating/loading entities.
<p>
Scale values of 2,2,2 will double the size of an entity.
<p>
Scale values of 0,0,0 will make an entity disappear.
<p>
Scale values of less than 0,0,0 will invert an entity and make it bigger.
<p>
See also: <a href=#ScaleMesh>ScaleMesh</a>, <a href=#FitMesh>FitMesh</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ScaleMesh>
<tr><td class=doctop colspan=2>Function ScaleMesh( mesh:TMesh,sx:Float,sy:Float,sz:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Scales all vertices of a mesh by the specified scaling factors.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
x_scale# - x scale of mesh
<p>
y_scale# - y scale of mesh
<p>
z_scale# - z scale of mesh
<p>
<b>Description</b>:
<p>
Scales all vertices of a mesh by the specified scaling factors.
<p>
See also: <a href=#FitMesh>FitMesh</a>, <a href=#ScaleEntity>ScaleEntity</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ScaleSprite>
<tr><td class=doctop colspan=2>Function ScaleSprite( sprite:TSprite,s_x:Float,s_y:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Scales a sprite.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
sprite - sprite handle
<p>
x_scale# - x scale of sprite
<p>
y scale# - y scale of sprite
<p>
<b>Description</b>:
<p>
Scales a sprite.
<p>
See also: <a href=#LoadSprite>LoadSprite</a>, <a href=#CreateSprite>CreateSprite</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ScaleTexture>
<tr><td class=doctop colspan=2>Function ScaleTexture( tex:TTexture,u_scale:Float,v_scale:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Scales a texture by an absolute amount.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
texture - name of texture
<p>
u_scale# - u scale
<p>
v_scale# - v scale
<p>
<b>Description</b>:
<p>
Scales a texture by an absolute amount.
<p>
This will have an immediate  effect on all instances of the texture being used.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetAnimKey>
<tr><td class=doctop colspan=2>Function SetAnimKey( ent:TEntity,frame:Float,pos_key:Int=True,rot_key:Int=True,scale_key:Int=True )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets an animation key for the specified entity at the specified frame.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
frame - frame of animation to be used as anim key
<p>
pos_key (optional) - true to include entity position information when setting  key. Defaults to true.
<p>
rot_key (optional) - true to include entity rotation information when setting  key. Defaults to true.
<p>
scale_key (optional) - true to include entity scale information when setting  key. Defaults to true.
<p>
<b>Description</b>:
<p>
Sets an animation key for the specified entity at the specified frame.  The entity must have a valid animation sequence to work with.
<p>
This is most useful when you've got a character, or a complete set of complicated moves to perform, and you want to perform them en-masse.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetAnimTime>
<tr><td class=doctop colspan=2>Function SetAnimTime( ent:TEntity,time:Float,seq:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>SetAnimTime allows you to manually animate entities.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - a valid entity handle.
<p>
time# - a floating point time value.
<p>
anim_seq - an optional animation sequence number.
<p>
<b>Description</b>:
<p>
SetAnimTime allows you to manually animate entities.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetCubeFace>
<tr><td class=doctop colspan=2>Function SetCubeFace( tex:TTexture,face:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Selects a cube face for direct rendering to a texture.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
texture - texture
<p>
face - face of cube to select. This should be one of the following values:
<p>
0: left (negative X) face
<p>
1: forward (positive Z) face - this is the default.
<p>
2: right (positive X) face
<p>
3: backward (negative Z) face
<p>
4: up (positive Y) face
<p>
5: down (negative Y) face
<p>
<b>Description</b>:
<p>
Selects a cube face for direct rendering to a texture.
<p>
This command should only be used when you wish to draw directly to a cubemap texture in real-time. Otherwise, just loading a pre-rendered cubemap with a flag of 128 will suffice.
<p>
To understand how this command works exactly it is important to recognise that Blitz treats cubemap textures slightly differently to how it treats other textures. Here's how it works...
<p>
A cubemap texture in Blitz actually consists of six images, each of which must be square 'power' of two size - e.g. 32, 64, 128 etc. Each corresponds to a particular cube face. These images are stored internally by Blitz, and the texture handle that is returned by LoadTexture/CreateTexture when specifying the cubemap flag, only provides access to one of these six images at once (by default the first one, or '0' face).
<p>
This is why, when loading a cubemap texture into Blitz using LoadTexture, all the six cubemap images must be laid out in a specific order (0-5, as described above), in a horizontal strip. Then Blitz takes this texture and internally converts it into six separate images.
<p>
So seeing as the texture handle returned by <a href=#CreateTexture>CreateTexture</a> / <a href=#LoadTexture>LoadTexture</a> only provides access to one of these images at once (no. 1 by default), how do we get access to the other five images? This is where SetCubeFace comes in. It will tell Blitz that whenever you next draw to a cubemap texture, to draw to the particular image representing the face you have specified with the face parameter.
<p>
Now you have the ability to draw to a cubemap in real-time.
<p>
To give you some idea of how this works in code, here's a function that updates a cubemap in real-time. It works by rendering six different views and copying them to the cubemap texture buffer, using SetCubeFace to specify which particular cubemap image should be drawn to.
<p>
; Start of code
<p>
Function UpdateCubeMap( tex,camera )
<p>
tex_sz=TextureWidth(tex)
<p>
; do left view
SetCubeFace tex,0
RotateEntity camera,0,90,0
RenderWorld
<p>
; copy contents of backbuffer to cubemap
CopyRect 0,0,tex_sz,tex_sz,0,0,BackBuffer(),TextureBuffer(tex)
<p>
; do forward view
SetCubeFace tex,1
RotateEntity camera,0,0,0
RenderWorld
CopyRect 0,0,tex_sz,tex_sz,0,0,BackBuffer(),TextureBuffer(tex)
<p>
; do right view
SetCubeFace tex,2
RotateEntity camera,0,-90,0
RenderWorld
CopyRect 0,0,tex_sz,tex_sz,0,0,BackBuffer(),TextureBuffer(tex)
<p>
; do backward view
SetCubeFace tex,3
RotateEntity camera,0,180,0
RenderWorld
CopyRect 0,0,tex_sz,tex_sz,0,0,BackBuffer(),TextureBuffer(tex)
<p>
; do up view
SetCubeFace tex,4
RotateEntity camera,-90,0,0
RenderWorld
CopyRect 0,0,tex_sz,tex_sz,0,0,BackBuffer(),TextureBuffer(tex)
<p>
; do down view
SetCubeFace tex,5
RotateEntity camera,90,0,0
RenderWorld
CopyRect 0,0,tex_sz,tex_sz,0,0,BackBuffer(),TextureBuffer(tex)
<p>
EndFunction
<p>
; End of code
<p>
All rendering to a texture buffer affects the currently selected face. Do not change the selected cube face while a buffer is locked.
<p>
Finally, you may wish to combine the vram 256 flag with the cubic mapping flag when drawing to cubemap textures for faster access.
<p>
See also: <a href=#CreateTexture>CreateTexture</a>, <a href=#LoadTexture>LoadTexture</a>, <a href=#SetCubeMode>SetCubeMode</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SetCubeMode>
<tr><td class=doctop colspan=2>Function SetCubeMode( tex:TTexture,Mode:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the rendering mode of a cubemap texture.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
texture - a valid texture handle
<p>

<p>
mode - the rendering mode of the cubemap texture:
<p>
1: Specular (default)
<p>
2: Diffuse
<p>
3: Refraction
<p>
<b>Description</b>:
<p>
Set the rendering mode of a cubemap texture.
<p>
The available rendering modes are as follows:
<p>
1: Specular (default). Use this to give your cubemapped objects a shiny effect.
<p>
2: Diffuse. Use this to give your cubemapped objects a non-shiny, realistic lighting effect.
<p>
3: Refraction. Good for 'cloak'-style effects.
<p>
See also: <a href=#CreateTexture>CreateTexture</a>, <a href=#LoadTexture>LoadTexture</a>, <a href=#SetCubeFace>SetCubeFace</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=ShowEntity>
<tr><td class=doctop colspan=2>Function ShowEntity( ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Shows an entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - entity handle
<p>
<b>Description</b>:
<p>
Shows an entity. Very much the opposite of HideEntity.
<p>
Once an entity has been hidden using HideEntity,  use show entity to make it visible and involved in collisions again.  Note that ShowEntity has no effect if the enitities parent object is hidden.
<p>
Entities are shown by default after creating/loading them, so you should  only need to use ShowEntity after using HideEntity.
<p>
ShowEntity affects the specified entity only - child entities are not affected.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=SpriteViewMode>
<tr><td class=doctop colspan=2>Function SpriteViewMode( sprite:TSprite,Mode:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the view mode of a sprite.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
sprite - sprite handle
<p>

view_mode - view_mode of sprite
<p>
1: fixed (sprite always faces camera - default)
<p>
2: free (sprite is independent of camera)
<p>
3: upright1 (sprite always faces camera, but rolls with camera as well, unlike  mode no.1)
<p>
4: upright2 (sprite always remains upright. Gives a 'billboard' effect. Good  for trees, spectators etc.)
<p>
<b>Description</b>:
<p>
Sets the view mode of a sprite.
<p>
The view mode determines how a sprite  alters its orientation in respect to the camera. This allows the sprite to in  some instances give the impression that it is more than two dimensional.
<p>
In technical terms, the four sprite modes perform the following changes:
<p>
1: Sprite changes its pitch and yaw values to face camera, but doesn't roll.
2: Sprite does not change either its pitch, yaw or roll values.
3: Sprite changes its yaw and pitch to face camera, and changes its roll value  to match cameras.
4: Sprite changes its yaw value to face camera, but not its pitch value, and  changes its roll value to match cameras.
<p>
Note that if you use sprite view mode 2, then because it is independent from  the camera, you will only be able to see it from one side unless you use EntityFx  flag 16 with it to disable backface culling.
<p>
See also: <a href=#CreateSprite>CreateSprite</a>, <a href=# LoadSprite> LoadSprite</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TerrainHeight>
<tr><td class=doctop colspan=2>Function TerrainHeight:Float( terr:TTerrain,x:Int,z:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the height of the terrain at terrain grid coordinates x.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
terrain - terrain handle
<p>
grid_x - grid x coordinate of terrain
<p>
grid_z - grid z coordinate of terrain
<p>
<b>Description</b>:
<p>
Returns the height of the terrain at terrain grid coordinates x,z. The value  returned is in the range 0 to 1.
<p>
See also: <a href=#TerrainY>TerrainY</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TerrainX>
<tr><td class=doctop colspan=2>Function TerrainX:Float( terr:TTerrain,x:Float,y:Float,z:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the interpolated x coordinate on a terrain.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
terrain - terrain handle
<p>
x# - world x coordinate
<p>
y# - world y coordinate
<p>
z# - world z coordinate
<p>
<b>Description</b>:
<p>
Returns the interpolated x coordinate on a terrain.
<p>
See also: <a href=#TerrainY>TerrainY</a>, <a href=#TerrainZ>TerrainZ</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TerrainY>
<tr><td class=doctop colspan=2>Function TerrainY:Float( terr:TTerrain,x:Float,y:Float,z:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the interpolated y coordinate on a terrain.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
terrain - terrain handle
<p>
x# - world x coordinate
<p>
y# - world y coordinate
<p>
z# - world z coordinate
<p>
<b>Description</b>:
<p>
Returns the interpolated y coordinate on a terrain.
<p>
Gets the ground's  height, basically.
<p>
See also: <a href=#TerrainX>TerrainX</a>, <a href=#TerrainZ>TerrainZ</a>, <a href=#TerrainHeight>TerrainHeight</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TerrainZ>
<tr><td class=doctop colspan=2>Function TerrainZ:Float( terr:TTerrain,x:Float,y:Float,z:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the interpolated z coordinate on a terrain.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
terrain - terrain handle
<p>
x# - world x coordinate
<p>
y# - world y coordinate
<p>
z# - world z coordinate
<p>
<b>Description</b>:
<p>
Returns the interpolated z coordinate on a terrain.
<p>
See also: <a href=#TerrainX>TerrainX</a>, <a href=#TerrainY>TerrainY</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TextureBlend>
<tr><td class=doctop colspan=2>Function TextureBlend( tex:TTexture,blend:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the blending mode for a texture.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
Texture - Texture handle.
<p>
Blend - Blend mode of texture.
<p>

<p>
0: Do not blend
<p>
1: No blend, or Alpha (alpha when texture loaded with alpha flag - not recommended  for multitexturing - see below)
<p>
2: Multiply (default)
<p>
3: Add
<p>
4: Dot3
<p>
5: Multiply 2
<p>
<b>Description</b>:
<p>
Sets the blending mode for a texture.
<p>
The texture blend mode determines how the texture will blend with the texture or polygon which is 'below' it. Texture 0 will blend with the polygons of the entity it is applied to. Texture 1 will blend with texture 0. Texture 2 will blend with texture 1. And so on.
<p>
Texture blending in Blitz effectively takes the highest order texture (the one with the highest index) and it blends with the texture below it, then that result to the texture directly below again, and so on until texture 0 which is blended with the polygons of the entity it is applied to and thus the world, depending on the <a href=#EntityBlend>EntityBlend</a> of the object.
<p>
Each of the blend modes are identical to their <a href=#EntityBlend>EntityBlend</a> counterparts.
<p>
In the case of multitexturing (more than one texture applied to an entity), it is not recommended you blend textures that have been loaded with the alpha flag, as this can cause unpredictable results on a variety of different graphics cards.
<p>
Use <a href=#EntityTexture>EntityTexture</a> to set the index number of a texture.
<p>
See also: <a href=#EntityBlend>EntityBlend</a>, <a href=#EntityTexture>EntityTexture</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TextureCoords>
<tr><td class=doctop colspan=2>Function TextureCoords( tex:TTexture,coords:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the texture coordinate mode for a texture.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
texture - name of texture
<p>
coords -
<p>
0: UV coordinates are from first UV set in vertices (default)
<p>
1: UV coordinates are from second UV set in vertices
<p>
<b>Description</b>:
<p>
Sets the texture coordinate mode for a texture.
<p>
This determines where  the UV values used to look up a texture come from.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TextureFilter>
<tr><td class=doctop colspan=2>Function TextureFilter( match_text:String,flags:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Adds a texture filter.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
match_text$ - text that, if found in texture filename, will activate certain  filters
<p>

flags - filter texture flags:
<p>
1: Color
<p>
2: Alpha
<p>
4: Masked
<p>
8: Mipmapped
<p>
16: Clamp U
<p>
32: Clamp V
<p>
64: Spherical reflection map
<p>
128:
<p>
256: Store texture in vram
<p>
512: Force the use of high color textures
<p>
<b>Description</b>:
<p>
Adds a texture filter. Any textures loaded that contain the text specified  by match_text$ will have the provided flags added.
<p>
This is mostly of use when loading a mesh.
<p>
By default, the following texture filter is used:
<p>
TextureFilter "",1+8
<p>
This means that all loaded textures will have color and be mipmapped by default.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TextureHeight>
<tr><td class=doctop colspan=2>Function TextureHeight:Int( tex:TTexture )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the height of a texture.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
texture - texture handle
<p>
<b>Description</b>:
<p>
Returns the height of a texture.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TextureName>
<tr><td class=doctop colspan=2>Function TextureName:String( tex:TTexture )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a texture's absolute filename.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
texture - a valid texture handle
<p>
<b>Description</b>:
<p>
Returns a texture's absolute filename.
<p>
To find out just the name of the texture, you will need to parse the string returned by TextureName. One such function to do this is:
<p>
; start of code
Function StripPath$(file$)
<p>
If Len(file$)>0
<p>
For i=Len(file$) To 1 Step -1
<p>
mi$=Mid$(file$,i,1)
If mi$="\" Or mi$="/" Then Return name$ Else name$=mi$+name$
<p>
Next
<p>
EndIf
<p>
Return name$
<p>
End Function
; end of code
<p>
See also: <a href=#GetBrushTexture>GetBrushTexture</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TextureWidth>
<tr><td class=doctop colspan=2>Function TextureWidth:Int( tex:TTexture )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the width of a texture.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
texture - texture handle
<p>
<b>Description</b>:
<p>
Returns the width of a texture.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TFormedX>
<tr><td class=doctop colspan=2>Function TFormedX:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the X component of the last TFormPoint.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the X component of the last TFormPoint, TFormVector or TFormNormal  operation.
<p>
See those commands for examples.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TFormedY>
<tr><td class=doctop colspan=2>Function TFormedY:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the Y component of the last TFormPoint.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the Y component of the last TFormPoint, TFormVector or TFormNormal  operation.
<p>
See those commands for examples.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TFormedZ>
<tr><td class=doctop colspan=2>Function TFormedZ:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the Z component of the last TFormPoint.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
None.
<p>
<b>Description</b>:
<p>
Returns the Z component of the last TFormPoint,  TFormVector or TFormNormal operation.
<p>
See those commands for examples.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TFormNormal>
<tr><td class=doctop colspan=2>Function TFormNormal( x:Float,y:Float,z:Float,src_ent:TEntity,dest_ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Transforms between coordinate systems.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
x#, y#, z# = components of a vector in 3d space
<p>

source_entity = handle of source entity, or 0 for 3d world
<p>
dest_entity = handle of destination entity, or 0 for 3d world
<p>
<b>Description</b>:
<p>
Transforms between coordinate systems. After using TFormNormal the new
components can be read with TFormedX(), TFormedY() and TFormedZ().
<p>
This is exactly the same as TFormVector but with one added feature.
After the transformation the new vector is 'normalized', meaning it
is scaled to have length 1.
<p>
For example, suppose the result of TFormVector is (1,2,2).
This vector has length Sqr( 1*1 + 2*2 + 2*2 ) = Sqr( 9 ) = 3.
<p>
This means TFormNormal would produce ( 1/3, 2/3, 2/3 ).</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TFormPoint>
<tr><td class=doctop colspan=2>Function TFormPoint( x:Float,y:Float,z:Float,src_ent:TEntity,dest_ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Transforms between coordinate systems.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
x#, y#, z# = coordinates of a point in 3d space
<p>

source_entity = handle of source entity, or 0 for 3d world
<p>
dest_entity = handle of destination entity, or 0 for 3d world
<p>
<b>Description</b>:
<p>
Transforms between coordinate systems. After using TFormPoint the new
coordinates can be read with TFormedX(), TFormedY() and TFormedZ().
<p>

See EntityX() for details about local coordinates.
<p>
Consider a sphere built with CreateSphere(). The 'north pole' is at (0,1,0).
At first, local and global coordinates are the same. As the sphere is moved,
turned and scaled the global coordinates of the point change.
<p>
But it is always at (0,1,0) in the sphere's local space.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TFormVector>
<tr><td class=doctop colspan=2>Function TFormVector( x:Float,y:Float,z:Float,src_ent:TEntity,dest_ent:TEntity )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Transforms between coordinate systems.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
x#, y#, z# = components of a vector in 3d space
<p>

source_entity = handle of source entity, or 0 for 3d world
<p>
dest_entity = handle of destination entity, or 0 for 3d world
<p>
<b>Description</b>:
<p>
Transforms between coordinate systems. After using TFormVector the new
components can be read with TFormedX(), TFormedY() and TFormedZ().
<p>

See EntityX() for details about local coordinates.
<p>

Similar to TFormPoint, but operates on a vector. A vector can be thought of
as 'displacement relative to current location'.
<p>
For example, vector (1,2,3) means one step to the right, two steps up
and three steps forward.
<p>
This is analogous to PositionEntity and MoveEntity:
<p>
PositionEntity entity, x,y,z   ; put entity at point (x,y,z)
<p>
MoveEntity entity, x,y,z       ; add vector (x,y,z) to current position.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TranslateEntity>
<tr><td class=doctop colspan=2>Function TranslateEntity( ent:TEntity,x:Float,y:Float,z:Float,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Translates an entity relative to its current position and not its  orientation.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - name of entity to be translated
<p>
x# - x amount that entity will be translated by
<p>
y# - y amount that entity will be translated by
<p>
z# - z amount that entity will be translated by
<p>
global (optional) -
<p>
<b>Description</b>:
<p>
Translates an entity relative to its current position and not its  orientation.
<p>
What this means is that an entity will move in a certain direction despite where it may be facing. Imagine that you have a game character that you want to make jump in the air at the same time as doing a triple somersault. Translating the character by a positive y amount will mean the character will always travel directly up in their air, regardless of where it may be facing due to the somersault action.
<p>
See also: <a href=#MoveEntity>MoveEntity</a>, <a href=#PositionEntity>PositionEntity</a>, <a href=#PositionMesh>PositionMesh</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TriangleVertex>
<tr><td class=doctop colspan=2>Function TriangleVertex:Int( surf:TSurface,tri_no:Int,corner:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the vertex of a triangle corner.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
triangle_index - triangle index
<p>
corner - corner of triangle. Should be 0, 1 or 2.
<p>
<b>Description</b>:
<p>
Returns the vertex of a triangle corner.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TurnEntity>
<tr><td class=doctop colspan=2>Function TurnEntity( ent:TEntity,x:Float,y:Float,z:Float,glob:Int=False )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Turns an entity relative to its current orientation.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
entity - name of entity to be rotated
<p>
pitch# - angle in degrees that entity will be pitched
<p>
yaw# - angle in degrees that entity will be yawed
<p>
roll# - angle in degrees that entity will be rolled
<p>
global (optional) -
<p>
<b>Description</b>:
<p>
Turns an entity relative to its current orientation.
<p>
Pitch is the same as the x angle of an entity, and is equivalent to tilting forward/backwards.
<p>
Yaw is the same as the y angle of an entity, and is equivalent to turning left/right.
<p>
Roll is the same as the z angle of an entity, and is equivalent to tilting left/right.
<p>
See also: <a href=#RotateEntity>RotateEntity</a>, <a href=#RotateMesh>RotateMesh</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UpdateNormals>
<tr><td class=doctop colspan=2>Function UpdateNormals( mesh:TMesh )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Recalculates all normals in a mesh.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
mesh - mesh handle
<p>
<b>Description</b>:
<p>
Recalculates all normals in a mesh. This is necessary for correct lighting  if you have not set surface normals using 'VertexNormals' commands.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=UpdateWorld>
<tr><td class=doctop colspan=2>Function UpdateWorld( anim_speed:Float=1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Animates all entities in the world.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
anim_speed# (optional) - a master control for animation speed. Defaults  to 1.
<p>
<b>Description</b>:
<p>
Animates all entities in the world, and performs collision checking.
<p>
The  optional anim_speed# parameter allows you affect the animation speed of all  entities at once. A value of 1 will animate entities at their usual animation  speed, a value of 2 will animate entities at double their animation speed, and  so on.
<p>
For best results use this command once per main loop, just before calling RenderWorld.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VectorPitch>
<tr><td class=doctop colspan=2>Function VectorPitch:Float( vx:Float,vy:Float,vz:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the pitch value of a vector.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
x# - x vector length
<p>
y# - y vector length
<p>
z# - z vector length
<p>
<b>Description</b>:
<p>
Returns the pitch value of a vector.
<p>
Using this command will return the same result as using <a href=#EntityPitch>EntityPitch</a> to get the pitch value of an entity that is pointing in the vector's direction.
<p>
See also: <a href=#VectorYaw>VectorYaw</a>, <a href=#EntityPitch>EntityPitch</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VectorYaw>
<tr><td class=doctop colspan=2>Function VectorYaw:Float( vx:Float,vy:Float,vz:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the yaw value of a vector.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
x# - x vector length
<p>
y# - y vector length
<p>
z# - z vector length
<p>
<b>Description</b>:
<p>
Returns the yaw value of a vector.
<p>
Using this command will return the same result as using <a href=#EntityYaw>EntityYaw</a> to get the yaw value of an entity that is pointing in the vector's direction.
<p>
See also: <a href=#VectorPitch>VectorPitch</a>, <a href=#EntityYaw>EntityYaw</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexAlpha>
<tr><td class=doctop colspan=2>Function VertexAlpha:Float( surf:TSurface,vid:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the alpha component of a vertices color.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
<b>Description</b>:
<p>
Returns the alpha component of a vertices color, set using <a href=#VertexColor>VertexColor</a>
<p>
See also: <a href=#VertexRed>VertexRed</a>, <a href=#VertexGreen>VertexGreen</a>, <a href=#VertexBlue>VertexBlue</a>, <a href=#VertexColor>VertexColor</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexBlue>
<tr><td class=doctop colspan=2>Function VertexBlue:Float( surf:TSurface,vid:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the blue component of a vertices color.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
<b>Description</b>:
<p>
Returns the blue component of a vertices color.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexColor>
<tr><td class=doctop colspan=2>Function VertexColor( surf:TSurface,vid:Int,r:Float,g:Float,b:Float,a:Float=1 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the color of an existing vertex.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
red# - red value of vertex
<p>
green# - green value of vertex
<p>
blue# - blue value of vertex
<p>
alpha# - optional alpha transparency of vertex (0.0 to 1.0 - default: 1.0)
<p>
<b>Description</b>:
<p>
Sets the color of an existing vertex.
<p>
NB. If you want to set the alpha individually for vertices using the alpha# parameter then you need to use EntityFX 32 (to force alpha-blending) on the entity.
<p>
See also: <a href=#EntityFX>EntityFX</a>.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexCoords>
<tr><td class=doctop colspan=2>Function VertexCoords( surf:TSurface,vid:Int,x:Float,y:Float,z:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the geometric coordinates of an existing vertex.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
x# - x position of vertex
<p>
y# - y position of vertex
<p>
z# - z position of vertex
<p>
<b>Description</b>:
<p>
Sets the geometric coordinates of an existing vertex.
<p>
This is the command  used to perform what is commonly referred to as 'dynamic mesh deformation'.  It will reposition a vertex so that all the triangle edges connected to it,  will move also. This will give the effect of parts of the mesh suddenly deforming.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexGreen>
<tr><td class=doctop colspan=2>Function VertexGreen:Float( surf:TSurface,vid:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the green component of a vertices color.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
<b>Description</b>:
<p>
Returns the green component of a vertices color.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexNormal>
<tr><td class=doctop colspan=2>Function VertexNormal( surf:TSurface,vid:Int,nx:Float,ny:Float,nz:Float )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the normal of an existing vertex.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
nx# - normal x of vertex
<p>
ny# - normal y of vertex
<p>
nz# - normal z of vertex
<p>
<b>Description</b>:
<p>
Sets the normal of an existing vertex.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexNX>
<tr><td class=doctop colspan=2>Function VertexNX:Float( surf:TSurface,vid:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the x component of a vertices normal.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
<b>Description</b>:
<p>
Returns the x component of a vertices normal.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexNY>
<tr><td class=doctop colspan=2>Function VertexNY:Float( surf:TSurface,vid:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the y component of a vertices normal.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
<b>Description</b>:
<p>
Returns the y component of a vertices normal.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexNZ>
<tr><td class=doctop colspan=2>Function VertexNZ:Float( surf:TSurface,vid:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the z component of a vertices normal.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
<b>Description</b>:
<p>
Returns the z component of a vertices normal.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexRed>
<tr><td class=doctop colspan=2>Function VertexRed:Float( surf:TSurface,vid:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the red component of a vertices color.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
<b>Description</b>:
<p>
Returns the red component of a vertices color.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexTexCoords>
<tr><td class=doctop colspan=2>Function VertexTexCoords( surf:TSurface,vid:Int,u:Float,v:Float,w:Float=0,coord_set:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the texture coordinates of an existing vertex.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
u# - u# coordinate of vertex
<p>
v# - v# coordinate of vertex
<p>
w# (optional) - w# coordinate of vertex
<p>
coord_set (optional) - co_oord set. Should be set to 0 or 1.
<p>
<b>Description</b>:
<p>
Sets the texture coordinates of an existing vertex.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexU>
<tr><td class=doctop colspan=2>Function VertexU:Float( surf:TSurface,vid:Int,coord_set:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the texture u coordinate of a vertex.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
coord_set (optional) - UV mapping coordinate set. Should be set to 0 or 1.
<p>
<b>Description</b>:
<p>
Returns the texture u coordinate of a vertex.
<p>
See also: <a href=#VertexV>VertexV</a>,</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexV>
<tr><td class=doctop colspan=2>Function VertexV:Float( surf:TSurface,vid:Int,coord_set:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the texture v coordinate of a vertex.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
coord_set (optional) - UV mapping coordinate set. Should be set to 0 or 1.
<p>
<b>Description</b>:
<p>
Returns the texture v coordinate of a vertex.
<p>
See also: <a href=#VertexU>VertexU</a>,</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexW>
<tr><td class=doctop colspan=2>Function VertexW:Float( surf:TSurface,vid:Int,coord_set:Int=0 )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the texture w coordinate of a vertex.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
<b>Description</b>:
<p>
Returns the texture w coordinate of a vertex.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexX>
<tr><td class=doctop colspan=2>Function VertexX:Float( surf:TSurface,vid:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the x coordinate of a vertex.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
<b>Description</b>:
<p>
Returns the x coordinate of a vertex.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexY>
<tr><td class=doctop colspan=2>Function VertexY:Float( surf:TSurface,vid:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the y coordinate of a vertex.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
<b>Description</b>:
<p>
Returns the y coordinate of a vertex.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=VertexZ>
<tr><td class=doctop colspan=2>Function VertexZ:Float( surf:TSurface,vid:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the z coordinate of a vertex.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
surface - surface handle
<p>
index - index of vertex
<p>
<b>Description</b>:
<p>
Returns the z coordinate of a vertex.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=Wireframe>
<tr><td class=doctop colspan=2>Function Wireframe( enable:Int )</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enables or disables wireframe rendering.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>Parameters</b>:
<p>
enable - True to enable wireframe rendering, False to disable.
<p>

The default  Wireframe mode is False.
<p>
<b>Description</b>:
<p>
Enables or disables wireframe rendering.
<p>
This will show the outline of  each polygon on the screen, with no shaded-in areas.
<p>
Wireframe mode should only be used for debugging purposes, as driver support  is patchy. For the same reason, no support is offered for the wireframe rendering  of individual polygon entities.</td></tr>
</table>
<br>
<h2 id=modinfo>Module Information</h2>
<table width=100%>
<tr><th width=1%>Version</th><td>1.26</td></tr>
<tr><th width=1%>License</th><td>zlib</td></tr>
<tr><th width=1%>Copyright</th><td>Wrapper - 2014-2021 Mark Mcvittie</td></tr>
<tr><th width=1%>Copyright</th><td>Library - 2010-2021 Angelo Rosina</td></tr>
</body></html>
